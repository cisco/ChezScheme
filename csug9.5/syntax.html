<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Syntactic Extension and Modules</title>
<link href="csug.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g98"></a>
<a name="./syntax:h0"></a>

<h1>Chapter 11. Syntactic Extension and Modules<a name="CHPTSYNTAX"></a></h1>





<p>
This chapter describes the <i>Chez&nbsp;Scheme</i> extensions to the
syntax-case syntactic abstraction mechanism now standardized in
the Revised<sup>6</sup> Report.
These extensions include
the module system (Section&nbsp;<a href="./syntax.html#g103">11.5</a>),
meta definitions (Section&nbsp;<a href="./syntax.html#g106">11.8</a>),
conditional expansion (Section&nbsp;<a href="./syntax.html#g107">11.9</a>)
<tt>syntax-rules</tt> fenders,
<tt>fluid-let-syntax</tt>,
and <tt>include</tt>.


<p>

<h3><a name="g99"></a><a name="./syntax:h1"></a>Section 11.1. Fluid Keyword Bindings<a name="SECTSYNTAXDEFINITIONS"></a></h3>



<p>
Keyword bindings established via the Revised<sup>6</sup> Report
<tt>define-syntax</tt>, <tt>let-syntax</tt>, or <tt>letrec-syntax</tt>
forms may be rebound temporarily with <tt>fluid-let-syntax</tt>.

<p>
<a name="./syntax:s0"></a><span class=formdef><b>syntax</b>: <tt>(fluid-let-syntax&nbsp;((<i>keyword</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>form<sub>1</sub></i>&nbsp;<i>form<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see explanation
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Each <tt><i>expr</i></tt> must evaluate to a transformer.
<tt>fluid-let-syntax</tt> is similar to the standard <tt>let-syntax</tt>, except
that instead of introducing new bindings for the keywords
<tt><i>keyword</i>&nbsp;...</tt>,
<tt>fluid-let-syntax</tt> temporarily alters the existing bindings
for the keywords during the expansion of its body.
That is, during the expansion of <tt><i>form<sub>1</sub></i>&nbsp;<i>form<sub>2</sub></i>&nbsp;...</tt>,
the visible lexical (or top-level) binding
for each <tt>keyword</tt> is temporarily replaced by a new association
between the keyword and the corresponding transformer.
This affects any references to the keyword that resolve
to the same lexical (or top-level) binding whether the references occur
in the text of the body or are introduced during its expansion.
In contrast, <tt>let-syntax</tt> captures only those references that
occur within the text of its body.

<p>
The following example shows how <tt>fluid-let-syntax</tt>
differs from <tt>let-syntax</tt>.

<p>

<p><tt>(let&nbsp;([f&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;1))])<br>

&nbsp;&nbsp;(let-syntax&nbsp;([g&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x)&nbsp;(f&nbsp;x)])])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let-syntax&nbsp;([f&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x)&nbsp;x])])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(g&nbsp;1))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2
<br>
<br>
(let&nbsp;([f&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;1))])<br>

&nbsp;&nbsp;(let-syntax&nbsp;([g&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x)&nbsp;(f&nbsp;x)])])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(fluid-let-syntax&nbsp;([f&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x)&nbsp;x])])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(g&nbsp;1))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1</tt>
<p>The two expressions are identical except that the inner
<tt>let-syntax</tt> form
in the first expression is a <tt>fluid-let-syntax</tt> form in the second.
In the first expression, the <tt>f</tt> occurring in the expansion of
<tt>(g&nbsp;1)</tt> refers to
the <tt>let</tt>-bound variable <tt>f</tt>, whereas in the second it refers
to the keyword <tt>f</tt> by virtue of the fluid syntax binding for
<tt>f</tt>.

<p>
<a name="./syntax:s1"></a><a name="./syntax:s2"></a>The following code employs <tt>fluid-let-syntax</tt> in the definition
of a <tt>define-integrable</tt> form that is similar
to <tt>define</tt> for procedure definitions except that it causes the
code for the procedure to be <i>integrated</i>, or inserted, wherever
a direct call to the procedure is found.
No semantic difference is visible between procedures defined with
<tt>define-integrable</tt> and those defined with <tt>define</tt>, except that
a top-level <tt>define-integrable</tt> form must appear before the first
reference to the defined identifier.
Lexical scoping is preserved, the actual parameters
in an integrated call are evaluated once and at the proper time,
integrable procedures may be used as first-class values, and
recursive procedures do not cause indefinite recursive expansion.

<p>

<p><tt>(define-syntax&nbsp;define-integrable<br>

&nbsp;&nbsp;(syntax-rules&nbsp;(lambda)<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;name&nbsp;(lambda&nbsp;formals&nbsp;form1&nbsp;form2&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;xname<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fluid-let-syntax&nbsp;([name&nbsp;(identifier-syntax&nbsp;xname)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;formals&nbsp;form1&nbsp;form2&nbsp;...)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-syntax&nbsp;name<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[_&nbsp;(identifier?&nbsp;x)&nbsp;#'xname]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;arg&nbsp;(...&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((fluid-let-syntax&nbsp;([name&nbsp;(identifier-syntax&nbsp;xname)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;formals&nbsp;form1&nbsp;form2&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arg<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(...&nbsp;...))]))))]))</tt>
<p>A <tt>define-integrable</tt> has the following form.

<p>

<p><tt>(define-integrable&nbsp;<i>name</i>&nbsp;<i>lambda-expression</i>)</tt>
<p>A <tt>define-integrable</tt> form expands into a pair of definitions: a syntax
definition of <tt><i>name</i></tt> and a variable definition of <tt>xname</tt>.
The transformer for <tt><i>name</i></tt> converts apparent calls to
<tt><i>name</i></tt> into direct calls to <tt><i>lambda-expression</i></tt>.
Since the resulting forms are merely direct <tt>lambda</tt> applications
(the equivalent of <tt>let</tt> expressions),
the actual parameters are evaluated exactly once and before evaluation
of the procedure's body, as required.
All other references to <tt><i>name</i></tt> are replaced with references to
<tt>xname</tt>.
The definition of <tt>xname</tt> binds it to the value of
<tt><i>lambda-expression</i></tt>.
This allows the procedure to be used as a first-class value.
Because <tt>xname</tt> is introduced by the transformer, the binding for
<tt>xname</tt> is not visible anywhere except where references to it
are introduced by the transformer for <tt><i>name</i></tt>.

<p>
Within <tt><i>lambda-expression</i></tt>, wherever it appears, <tt><i>name</i></tt>
is rebound to a transformer that expands all references into references
to <tt>xname</tt>.
The use of <a name="./syntax:s3"></a><tt>fluid-let-syntax</tt>
for this purpose prevents indefinite
expansion from indirect recursion among integrable procedures.
This allows the procedure to be recursive without causing indefinite
expansion.
Nothing special is done by <tt>define-integrable</tt> to maintain lexical
scoping, since lexical scoping is maintained automatically by the
expander.

<p>
<i>Chez&nbsp;Scheme</i> integrates locally defined procedures automatically when it is
appropriate to do so.
It cannot integrate procedures defined at top-level,
however, since code that assigns top-level variables can be introduced
into the system (via <tt>eval</tt> or <tt>load</tt>) at any time.
<tt>define-integrable</tt> can be used to force the integration of
procedures bound at top-level, even if the integration of locally bound
procedures is left to the compiler.
It can also be used to force the integration of large procedures that
the compiler would not normally integrate.
(The <tt>expand/optimize</tt> procedure is useful for determining when
integration does or does not take place.)

<p>

<h3><a name="g100"></a><a name="./syntax:h2"></a>Section 11.2. Syntax-Rules Transformers<a name="SECTSYNTAXRULES"></a></h3>



<p>
<i>Chez&nbsp;Scheme</i> extends <tt>syntax-rules</tt> to permit clause to include
fenders just like those allowed within <tt>syntax-case</tt> clauses.

<p>
<a name="./syntax:s4"></a><span class=formdef><b>syntax</b>: <tt>(syntax-rules&nbsp;(<i>literal</i>&nbsp;...)&nbsp;<i>clause</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>a transformer
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Each <a name="./syntax:s5"></a><tt><i>literal</i></tt> must be an identifier other than
an underscore (&nbsp;<tt>_</tt>&nbsp;) or ellipsis (&nbsp;<tt>...</tt>&nbsp;).
Each clause must take the form below.

<p>

<p><tt>(<i>pattern</i>&nbsp;<i>template</i>)<br>

(<i>pattern</i>&nbsp;<i>fender</i>&nbsp;<i>template</i>)</tt>
<p>The first form is the only form supported by the Revised<sup>6</sup> Report.


<p>

<h3><a name="g101"></a><a name="./syntax:h3"></a>Section 11.3. Syntax-Case Transformers<a name="SECTSYNTAXCASE"></a></h3>



<p>
<i>Chez&nbsp;Scheme</i> provides several procedures and syntactic forms that may
be used to simplify the coding of certain syntactic abstractions.

<p>
<a name="./syntax:s6"></a><span class=formdef><b>procedure</b>: <tt>(syntax-&gt;list&nbsp;<i>syntax-object</i>)</tt></span>
<br>
<b>returns: </b>a list of syntax objects
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure takes a syntax object representing
a list-structured form and returns a list of syntax objects, each representing
the corresponding subform of the input form.


<p>
<tt>syntax-&gt;list</tt> may be defined as follows.

<p>

<p><tt>(define&nbsp;syntax-&gt;list<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;ls&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[()&nbsp;'()]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(x&nbsp;.&nbsp;r)&nbsp;(cons&nbsp;#'x&nbsp;(syntax-&gt;list&nbsp;#'r))])))
<br>
<br>
#'(a&nbsp;b&nbsp;c)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;syntax&nbsp;(a&nbsp;b&nbsp;c)&gt;<br>

(syntax-&gt;list&nbsp;#'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(#&lt;syntax&nbsp;a&gt;&nbsp;#&lt;syntax&nbsp;b&gt;&nbsp;#&lt;syntax&nbsp;c&gt;)</tt>
<p><tt>syntax-&gt;list</tt> is not required for list structures constructed
from individual pattern variable values or sequences of pattern-variable
values, since such structures are already lists.
For example:

<p>

<p><tt>(list?&nbsp;(with-syntax&nbsp;([x&nbsp;#'a]&nbsp;[y&nbsp;#'b]&nbsp;[z&nbsp;#'c])&nbsp;#'(x&nbsp;y&nbsp;z))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(list?&nbsp;(with-syntax&nbsp;([(x&nbsp;...)&nbsp;#'(a&nbsp;b&nbsp;c)])&nbsp;#'(x&nbsp;...)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./syntax:s7"></a><span class=formdef><b>procedure</b>: <tt>(syntax-&gt;vector&nbsp;<i>syntax-object</i>)</tt></span>
<br>
<b>returns: </b>a vector of syntax objects
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure takes a syntax object representing
a vector-structured form and returns a vector of syntax objects, each representing
the corresponding subform of the input form.


<p>
<tt>syntax-&gt;vector</tt> may be defined as follows.

<p>

<p><tt>(define&nbsp;syntax-&gt;vector<br>

&nbsp;&nbsp;(lambda&nbsp;(v)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;v&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[#(x&nbsp;...)&nbsp;(apply&nbsp;vector&nbsp;(syntax-&gt;list&nbsp;#'(x&nbsp;...)))])))
<br>
<br>
#'#(a&nbsp;b&nbsp;c)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;syntax&nbsp;#(a&nbsp;b&nbsp;c)&gt;<br>

(syntax-&gt;vector&nbsp;#'#(a&nbsp;b&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#(#&lt;syntax&nbsp;a&gt;&nbsp;#&lt;syntax&nbsp;b&gt;&nbsp;#&lt;syntax&nbsp;c&gt;)</tt>
<p><tt>syntax-&gt;vector</tt> is not required for vector structures constructed
from individual pattern variable values or sequences of pattern-variable
values, since such structures are already vectors.
For example:

<p>

<p><tt>(vector?&nbsp;(with-syntax&nbsp;([x&nbsp;#'a]&nbsp;[y&nbsp;#'b]&nbsp;[z&nbsp;#'c])&nbsp;#'#(x&nbsp;y&nbsp;z))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(vector?&nbsp;(with-syntax&nbsp;([(x&nbsp;...)&nbsp;#'(a&nbsp;b&nbsp;c)])&nbsp;#'#(x&nbsp;...)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./syntax:s8"></a><span class=formdef><b>procedure</b>: <tt>(syntax-object-&gt;datum&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt><i>obj</i></tt> stripped of syntactic information
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>syntax-object-&gt;datum</tt> is identical to the Revised<sup>6</sup> Report
<tt>syntax-&gt;datum</tt>.


<p>
<a name="./syntax:s9"></a><span class=formdef><b>syntax</b>: <tt>(datum&nbsp;<i>template</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>(datum&nbsp;<i>template</i>)</tt> is a convenient shorthand syntax for

<p>

<p><tt>(syntax-&gt;datum&nbsp;(syntax&nbsp;<i>template</i>))</tt>
<p><tt><i>datum</i></tt> may be defined simply as follows.

<p>

<p><tt>(define-syntax&nbsp;datum<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;t)&nbsp;(syntax-&gt;datum&nbsp;#'t)]))
<br>
<br>
(with-syntax&nbsp;((a&nbsp;#'(a&nbsp;b&nbsp;c)))&nbsp;(datum&nbsp;a))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)</tt>
<p><a name="./syntax:s10"></a><span class=formdef><b>procedure</b>: <tt>(datum-&gt;syntax-object&nbsp;<i>template-identifier</i>&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>a syntax object
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>datum-&gt;syntax-object</tt> is identical to the Revised<sup>6</sup> Report
<tt>datum-&gt;syntax</tt>.

<p>
<a name="./syntax:s11"></a><span class=formdef><b>syntax</b>: <tt>(with-implicit&nbsp;(<i>id<sub>0</sub></i>&nbsp;<i>id<sub>1</sub></i>&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This form abstracts over the common usage of <tt>datum-&gt;syntax</tt>
for creating implicit identifiers (see above).
The form

<p>

<p><tt>(with-implicit&nbsp;(<i>id<sub>0</sub></i>&nbsp;<i>id<sub>1</sub></i>&nbsp;...)<br>

&nbsp;&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p>is equivalent to

<p>

<p><tt>(with-syntax&nbsp;([<i>id<sub>1</sub></i>&nbsp;(datum-&gt;syntax&nbsp;#'<i>id<sub>0</sub></i>&nbsp;'<i>id<sub>1</sub></i>)]&nbsp;...)<br>

&nbsp;&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p><tt>with-implicit</tt> can be defined simply as follows.

<p>

<p><tt>(define-syntax&nbsp;with-implicit<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(tid&nbsp;id&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([id&nbsp;(datum-&gt;syntax&nbsp;#'tid&nbsp;'id)]&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b1&nbsp;b2&nbsp;...)]))</tt>
<p>We can use <tt>with-implicit</tt> to simplify the (correct version of)
<tt>loop</tt> above.

<p>

<p><tt>(define-syntax&nbsp;loop<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(k&nbsp;e&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-implicit&nbsp;(k&nbsp;break)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(call-with-current-continuation<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(break)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;()&nbsp;e&nbsp;...&nbsp;(f)))))])))</tt>
<p><a name="./syntax:s12"></a><span class=formdef><b>syntax</b>: <tt>(include&nbsp;<i>path</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt>include</tt> expands into a <tt>begin</tt> expression containing
the forms found in the file named by <tt><i>path</i></tt>.
For example, if the file <tt>f-def.ss</tt> contains
<tt>(define&nbsp;f&nbsp;(lambda&nbsp;()&nbsp;x))</tt>, the expression

<p>

<p><tt>(let&nbsp;([x&nbsp;"okay"])<br>

&nbsp;&nbsp;(include&nbsp;"f-def.ss")<br>

&nbsp;&nbsp;(f))</tt>
<p>evaluates to <tt>"okay"</tt>.
An include form is treated as a definition if it appears within a
sequence of definitions and the forms on the file named by
<tt><i>path</i></tt> are all definitions, as in the above example.
If the file contains expressions instead, the <tt>include</tt> form is
treated as an expression.

<p>
<tt>include</tt> may be defined portably as follows, although
<i>Chez&nbsp;Scheme</i> uses an implementation-dependent definition that allows
it to capture and maintain source information for included code.

<p>

<p><tt>(define-syntax&nbsp;include<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;read-file<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(fn&nbsp;k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([p&nbsp;(open-input-file&nbsp;fn)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([x&nbsp;(read&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eof-object?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(close-input-port&nbsp;p)&nbsp;'())<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(datum-&gt;syntax&nbsp;k&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;(read&nbsp;p))))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(k&nbsp;filename)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([fn&nbsp;(datum&nbsp;filename)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([(exp&nbsp;...)&nbsp;(read-file&nbsp;fn&nbsp;#'k)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(begin&nbsp;exp&nbsp;...)))])))</tt>
<p>The definition of <tt>include</tt> uses <tt>datum-&gt;syntax</tt> to convert
the objects read from the file into syntax objects in the proper
lexical context, so that identifier references and definitions within
those expressions are scoped where the <tt>include</tt> form appears.

<p>
In <i>Chez&nbsp;Scheme</i>'s implementation of <tt>include</tt>,
the parameter <tt>source-directories</tt> (Section&nbsp;<a href="./system.html#g116">12.5</a>)
determines the set of directories searched for source files not identified
by absolute path names.


<p>
<a name="./syntax:s13"></a><a name="desc:syntax-error"></a>
<span class=formdef><b>procedure</b>: <tt>(syntax-error&nbsp;<i>obj</i>&nbsp;<i>string</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>does not return
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Syntax errors may be reported with <tt>syntax-error</tt>, which produces
a message by concatenating <tt><i>string</i>&nbsp;...</tt> and a printed
representation of <tt><i>obj</i></tt>.
If no string arguments are provided, the string <tt>"invalid&nbsp;syntax"</tt>
is used instead.
When <tt><i>obj</i></tt> is a syntax object, the syntax-object wrapper is
stripped (as with <tt>syntax-&gt;datum</tt>) before the printed representation
is created.
If source file information is present in the syntax-object wrapper,
<tt>syntax-error</tt> incorporates this information into the error
message.

<p>
<tt>syntax-case</tt> and <tt>syntax-rules</tt> call <tt>syntax-error</tt>
automatically if the input fails to match one of the clauses.

<p>
We can use <tt>syntax-error</tt> to precisely report the cause
of the errors detected in the following definition of
(unnamed) <tt>let</tt>.

<p>

<p><tt>(define-syntax&nbsp;let<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;check-ids!<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(identifier?&nbsp;(car&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-error&nbsp;(car&nbsp;ls)&nbsp;"let&nbsp;cannot&nbsp;bind&nbsp;non-identifier"))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check-ids!&nbsp;(cdr&nbsp;ls)))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;check-unique!<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([x&nbsp;(car&nbsp;ls)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;(let&nbsp;mem?&nbsp;([ls&nbsp;(cdr&nbsp;ls)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(not&nbsp;(null?&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(bound-identifier=?&nbsp;x&nbsp;(car&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(mem?&nbsp;(cdr&nbsp;ls)))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-error&nbsp;x&nbsp;"let&nbsp;cannot&nbsp;bind&nbsp;two&nbsp;occurrences&nbsp;of")))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check-unique!&nbsp;(cdr&nbsp;ls)))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((i&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check-ids!&nbsp;#'(i&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check-unique!&nbsp;#'(i&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((lambda&nbsp;(i&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;e&nbsp;...))])))</tt>
<p>With this change, the expression

<p>

<p><tt>(let&nbsp;([a&nbsp;3]&nbsp;[a&nbsp;4])&nbsp;(+&nbsp;a&nbsp;a))</tt>
<p>produces the error message "let cannot bind two occurrences of <tt>a</tt>."

<p>
<a name="./syntax:s14"></a><span class=formdef><b>procedure</b>: <tt>(literal-identifier=?&nbsp;<i>identifier<sub>1</sub></i>&nbsp;<i>identifier<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure is identical to the Revised<sup>6</sup> Report
<tt>free-identifier=?</tt>, and is provided for backward
compatibility only.

<p>

<h3><a name="g102"></a><a name="./syntax:h4"></a>Section 11.4. Compile-time Values and Properties<a name="SECTSYNTAXCTVS"></a></h3>



<p>
When defining sets of dependent macros, it is often convenient to attach
information to identifiers in the same <i>compile time environment</i>
that the expander uses to record information about variables, keywords,
module names, etc.
For example, a record-type definition macro, like
<tt>define-record-type</tt>, might need to attach information to the
record-type name in the compile-time environment for use in handling child
record-type definitions.

<p>
<i>Chez&nbsp;Scheme</i> provides two mechanisms for attaching information to
identifiers in the compile-time environment: compile-time values and
compile-time properties.
A compile-time value is a kind of transformer that can be
associated with an identifier via <tt>define-syntax</tt>,
<tt>let-syntax</tt>, <tt>letrec-syntax</tt>, and <tt>fluid-let-syntax</tt>.
When an identifier is associated with a compile-time value, it cannot
also have any other meaning, and an attempt to reference it as an
ordinary identifier results in a syntax error.
A compile-time property, on the other hand, is maintained alongside
an existing binding, providing additional information about the
binding.
Properties are ignored when ordinary references to an identifier
occur.

<p>
The mechanisms used by a macro to obtain compile-time values and
properties are similar.
In both cases, the macro's transformer returns a procedure <tt><i>p</i></tt>
rather than a syntax object.
The expander invokes <tt><i>p</i></tt> with one argument, an environment-lookup
procedure <tt><i>lookup</i></tt>, which <tt><i>p</i></tt> can then use to obtain compile-time
values and properties for one or more identifiers before it constructs the
macro's final output.
<tt><i>lookup</i></tt> accepts one or two identifier arguments.
With one argument, <tt><i>id</i></tt>, <tt><i>lookup</i></tt> returns the compile-time
value of <tt><i>id</i></tt>, or <tt>#f</tt> if <tt><i>id</i></tt> has no compile-time value.
With two arguments, <tt><i>id</i></tt> and <tt><i>key</i></tt>, <tt><i>lookup</i></tt> returns the
value of  <tt><i>id</i></tt>'s <tt><i>key</i></tt> property, or <tt>#f</tt> if <tt><i>id</i></tt>
has no <tt><i>key</i></tt> property.


<p>
<a name="./syntax:s15"></a><span class=formdef><b>procedure</b>: <tt>(make-compile-time-value&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>a compile-time value
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A compile time value is a kind of transformer with which a keyword may
be associated by any of the keyword binding constructs, e.g., <tt>define-syntax</tt>
or <tt>let-syntax</tt>.
The transformer encapsulates the supplied <tt><i>obj</i></tt>.
The encapsulated object may be retrieved as described above.

<p>
The following example illustrates how this feature might be used to define
a simple syntactic record-definition mechanism where the record type descriptor
is generated at expansion time.

<p>

<p><tt>(define-syntax&nbsp;drt<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;construct-name<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(template-identifier&nbsp;.&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(datum-&gt;syntax&nbsp;template-identifier<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;symbol<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;string-append<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(string?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(symbol-&gt;string&nbsp;(syntax-&gt;datum&nbsp;x))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;do-drt<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(rname&nbsp;fname*&nbsp;prtd)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([rname&nbsp;rname]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[rtd&nbsp;(make-record-type-descriptor<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-&gt;datum&nbsp;rname)&nbsp;prtd&nbsp;#f&nbsp;#f&nbsp;#f<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-&gt;vector<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(fname)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`(immutable&nbsp;,(syntax-&gt;datum&nbsp;fname)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fname*)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[make-rname&nbsp;(construct-name&nbsp;rname&nbsp;"make-"&nbsp;rname)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[rname?&nbsp;(construct-name&nbsp;rname&nbsp;rname&nbsp;"?")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(rname-fname&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(fname)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(construct-name&nbsp;fname&nbsp;rname&nbsp;"-"&nbsp;fname))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fname*)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(i&nbsp;...)&nbsp;(enumerate&nbsp;fname*)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-syntax&nbsp;rname&nbsp;(make-compile-time-value&nbsp;'rtd))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;rcd&nbsp;(make-record-constructor-descriptor&nbsp;'rtd&nbsp;#f&nbsp;#f))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;make-rname&nbsp;(record-constructor&nbsp;rcd))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;rname?&nbsp;(record-predicate&nbsp;'rtd))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;rname-fname&nbsp;(record-accessor&nbsp;'rtd&nbsp;i))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;(parent)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;rname&nbsp;(fname&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for-all&nbsp;identifier?&nbsp;#'(rname&nbsp;fname&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do-drt&nbsp;#'rname&nbsp;#'(fname&nbsp;...)&nbsp;#f)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;rname&nbsp;pname&nbsp;(fname&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for-all&nbsp;identifier?&nbsp;#'(rname&nbsp;pname&nbsp;fname&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(lookup)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([prtd&nbsp;(lookup&nbsp;#'pname)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(record-type-descriptor?&nbsp;prtd)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-error&nbsp;#'pname&nbsp;"unrecognized&nbsp;parent&nbsp;record&nbsp;type"))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do-drt&nbsp;#'rname&nbsp;#'(fname&nbsp;...)&nbsp;prtd)))])))</tt>
<p>
<p><tt>(drt&nbsp;prec&nbsp;(x&nbsp;y))<br>

(drt&nbsp;crec&nbsp;prec&nbsp;(z))<br>

(define&nbsp;r&nbsp;(make-crec&nbsp;1&nbsp;2&nbsp;3))<br>

(prec?&nbsp;r)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(prec-x&nbsp;r)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(crec-z&nbsp;r)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

prec&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;invalid&nbsp;syntax&nbsp;prec</i></tt>
<p><a name="./syntax:s16"></a><span class=formdef><b>procedure</b>: <tt>(compile-time-value?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a compile-time value; <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>(define-syntax&nbsp;x&nbsp;(make-compile-time-value&nbsp;"eggs"))<br>

(compile-time-value?&nbsp;(top-level-syntax&nbsp;'x))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./syntax:s17"></a><span class=formdef><b>procedure</b>: <tt>(compile-time-value-value&nbsp;<i>ctv</i>)</tt></span>
<br>
<b>returns: </b>the value of a compile-time value
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>(define-syntax&nbsp;x&nbsp;(make-compile-time-value&nbsp;"eggs"))<br>

(compile-time-value-value&nbsp;(top-level-syntax&nbsp;'x))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"eggs"</tt>
<p><a name="./syntax:s18"></a><span class=formdef><b>syntax</b>: <tt>(define-property&nbsp;<i>id</i>&nbsp;<i>key</i>&nbsp;<i>expr</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A <tt>define-property</tt> form attaches a property to an
existing identifier binding without disturbing the existing meaning
of the identifier in the scope of that binding.
It is typically used by one macro to record information about a binding
for use by another macro.
Both <tt><i>id</i></tt> and <tt><i>key</i></tt> must be identifiers.
The expression <tt><i>expr</i></tt> is evaluated when the <tt>define-property</tt>
form is expanded, and a new property associating <tt><i>key</i></tt> with the
value of <tt><i>expr</i></tt> is attached to the existing binding of
<tt><i>id</i></tt>, which must have a visible local or top-level binding.

<p>
<tt>define-property</tt> is a definition and can appear anywhere
other definitions can appear.
The scope of a property introduced by <tt>define-property</tt> is the
entire body in which the <tt>define-property</tt> form appears or global
if it appears at top level, except
where it is replaced by a property for the same <tt><i>id</i></tt> and
<tt><i>key</i></tt> or where the binding to which it is attached is shadowed.
Any number of properties can be attached to the same binding with
different keys.
Attaching a new property with the same name as an property already
attached to a binding shadows the existing property with the new
property.

<p>
The following example defines a macro, <tt>get-info</tt>, that retrieves
the <tt>info</tt> property of a binding, defines the variable <tt>x</tt>,
attaches an <tt>info</tt> property to the binding of <tt>x</tt>, retrieves
the property via <tt>get-info</tt>, references <tt>x</tt> to show that
its normal binding is still intact, and uses <tt>get-info</tt> again
within the scope of a different binding of <tt>x</tt> to show that the
properties are shadowed as well as the outer binding of <tt>x</tt>.

<p>

<p><tt>(define&nbsp;info)<br>

(define-syntax&nbsp;get-info<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(lookup)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;q)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([info-value&nbsp;(lookup&nbsp;#'q&nbsp;#'info)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#`'#,(datum-&gt;syntax&nbsp;#'*&nbsp;info-value))]))))<br>

(define&nbsp;x&nbsp;"x-value")<br>

(define-property&nbsp;x&nbsp;info&nbsp;"x-info")<br>

(get-info&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"x-info"<br>

x&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"x-value"<br>

(let&nbsp;([x&nbsp;"inner-x-value"])&nbsp;(get-info&nbsp;x))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>For debugging, it is often useful to have a form that retrieves
an arbitrary property, given an identifier and a key.
The <a name="./syntax:s19"></a><tt>get-property</tt> macro below does
just that.

<p>

<p><tt>(define-syntax&nbsp;get-property<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(r)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;id&nbsp;key)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#`'#,(datum-&gt;syntax&nbsp;#'*&nbsp;(r&nbsp;#'id&nbsp;#'key))]))))<br>

(get-property&nbsp;x&nbsp;info)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"x-info"</tt>
<p>The bindings for both identifiers must be visible where
<tt>get-property</tt> is used.

<p>
The version of <tt>drt</tt> defined below is like the one defined using
<tt>make-compile-time-value</tt> above, except that it defines the
record name as a macro that raises an exception with a more descriptive
message, while attaching the record type descriptor to the binding as a
separate property.
The variable <tt>drt-key</tt> defined along with <tt>drt</tt> is used
only as the key for the property that <tt>drt</tt> attaches to a record
name.
Both <tt>drt-key</tt> and <tt>drt</tt> are defined within a module that
exports only the latter, ensuring that the properties used by <tt>drt</tt>
cannot be accessed or forged.

<p>

<p><tt>(library&nbsp;(drt)&nbsp;(export&nbsp;drt)&nbsp;(import&nbsp;(chezscheme))<br>

&nbsp;&nbsp;(define&nbsp;drt-key)<br>

&nbsp;&nbsp;(define-syntax&nbsp;drt<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;construct-name<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(template-identifier&nbsp;.&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(datum-&gt;syntax&nbsp;template-identifier<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;symbol<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;string-append<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(string?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(symbol-&gt;string&nbsp;(syntax-&gt;datum&nbsp;x))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;do-drt<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(rname&nbsp;fname*&nbsp;prtd)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([rname&nbsp;rname]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[rtd&nbsp;(make-record-type-descriptor<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-&gt;datum&nbsp;rname)&nbsp;prtd&nbsp;#f&nbsp;#f&nbsp;#f<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-&gt;vector<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(fname)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`(immutable&nbsp;,(syntax-&gt;datum&nbsp;fname)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fname*)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[make-rname&nbsp;(construct-name&nbsp;rname&nbsp;"make-"&nbsp;rname)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[rname?&nbsp;(construct-name&nbsp;rname&nbsp;rname&nbsp;"?")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(rname-fname&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(fname)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(construct-name&nbsp;fname&nbsp;rname&nbsp;"-"&nbsp;fname))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fname*)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(i&nbsp;...)&nbsp;(enumerate&nbsp;fname*)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-syntax&nbsp;rname<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-error&nbsp;x&nbsp;"invalid&nbsp;use&nbsp;of&nbsp;record&nbsp;name")))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;rcd&nbsp;(make-record-constructor-descriptor&nbsp;'rtd&nbsp;#f&nbsp;#f))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-property&nbsp;rname&nbsp;drt-key&nbsp;'rtd)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;make-rname&nbsp;(record-constructor&nbsp;rcd))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;rname?&nbsp;(record-predicate&nbsp;'rtd))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;rname-fname&nbsp;(record-accessor&nbsp;'rtd&nbsp;i))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;(parent)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;rname&nbsp;(fname&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for-all&nbsp;identifier?&nbsp;#'(rname&nbsp;fname&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do-drt&nbsp;#'rname&nbsp;#'(fname&nbsp;...)&nbsp;#f)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;rname&nbsp;pname&nbsp;(fname&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for-all&nbsp;identifier?&nbsp;#'(rname&nbsp;pname&nbsp;fname&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(lookup)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([prtd&nbsp;(lookup&nbsp;#'pname&nbsp;#'drt-key)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;prtd<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-error&nbsp;#'pname&nbsp;"unrecognized&nbsp;parent&nbsp;record&nbsp;type"))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do-drt&nbsp;#'rname&nbsp;#'(fname&nbsp;...)&nbsp;prtd)))]))))</tt>
<p>
<p><tt>(import&nbsp;(drt))<br>

(drt&nbsp;prec&nbsp;(x&nbsp;y))<br>

(drt&nbsp;crec&nbsp;prec&nbsp;(z))<br>

(define&nbsp;r&nbsp;(make-crec&nbsp;1&nbsp;2&nbsp;3))<br>

(prec?&nbsp;r)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(prec-x&nbsp;r)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(crec-z&nbsp;r)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

prec&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;invalid&nbsp;use&nbsp;of&nbsp;record&nbsp;name&nbsp;prec</i></tt>
<p>
<h3><a name="g103"></a><a name="./syntax:h5"></a>Section 11.5. Modules<a name="SECTSYNTAXMODULES"></a></h3>



<p>
<a name="./syntax:s20"></a>Modules are used to help organize programs into separate
parts that interact cleanly via declared interfaces.
Although modular programming is typically used to facilitate the development
of large programs possibly written by many individuals, it may also be
used in <i>Chez&nbsp;Scheme</i> at a "micro-modular" level, since <i>Chez&nbsp;Scheme</i>
module and import forms are definitions and may appear anywhere any other
kind of definition may appear, including within a <tt>lambda</tt> body
or other local scope.

<p>
Modules control visibility of bindings and can be viewed as extending
lexical scoping to allow more precise control over where bindings are
or are not visible.
Modules export identifier bindings, i.e., variable bindings, keyword
bindings, or module name bindings.
Modules may be <i>named</i> or <i>anonymous</i>.
Bindings exported from a named module may be made visible via an import
form wherever the module's name is visible.
Bindings exported from an anonymous module are implicitly imported where
the module form appears.
Anonymous modules are useful for hiding some of a set of bindings while
allowing the remaining bindings in the set to be visible.

<p>
Some of the text and examples given in this section are
adapted from the paper
"Extending the scope of syntactic
abstraction"&nbsp;[<a class=citation href="./bibliography.html#g183">32</a>], which describes modules and their
implementation in more detail.

<p>
<a name="./syntax:s21"></a><span class=formdef><b>syntax</b>: <tt>(module&nbsp;<i>name</i>&nbsp;<i>interface</i>&nbsp;<i>defn</i>&nbsp;...&nbsp;<i>init</i>&nbsp;...)</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>(module&nbsp;<i>interface</i>&nbsp;<i>defn</i>&nbsp;...&nbsp;<i>init</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>name</i></tt> is an identifier, <tt><i>defn</i>&nbsp;...</tt>
are definitions, and <tt><i>init</i>&nbsp;...</tt> are expressions.
<tt><i>interface</i></tt> is a list of exports <tt>(<i>export</i>&nbsp;...)</tt>,
where each <tt><i>export</i></tt> is either an identifier <tt><i>identifier</i></tt>
or of the form <tt>(<i>identifier</i>&nbsp;<i>export</i>&nbsp;...)</tt>.

<p>
The first syntax for <tt>module</tt> establishes a named scope that
encapsulates a set of identifier bindings.
The exported bindings may be made visible via <tt>import</tt> or
<tt>import-only</tt> (Section&nbsp;<a href="./libraries.html#g94">10.4</a>)
anywhere the module name is visible.
The second syntax for <tt>module</tt> introduces an anonymous module
whose bindings are implicitly imported (as if by <tt>import</tt> of a
hidden module name) where the module form appears.

<p>
A module consists of a (possibly empty) set of
definitions and a (possibly empty) sequence of initialization expressions.
The identifiers defined within a module are visible within the body
of the module and, if exported, within the scope of an import for the
module.
Each identifier listed in a module's interface must be defined within
or imported into that module.
A <tt>module</tt> form is a definition and can appear anywhere other
definitions can appear, including
at the top level of a program, nested within the bodies of
<tt>lambda</tt> expressions, nested within <tt>library</tt> and
top-level program forms, and nested within other modules.
Also, because module names are scoped like other identifiers,
modules and libraries may export module names as well as variables and keywords.

<p>
When an interface contains an export of the form
<tt>(<i>identifier</i>&nbsp;<i>export</i>&nbsp;...)</tt>, only <tt><i>identifier</i></tt> is
visible in the importing context.
The identifiers within <tt><i>export</i>&nbsp;...</tt> are
<i>indirect imports</i>, as if declared via an
<tt>indirect-export</tt> form (Section&nbsp;<a href="./libraries.html#g94">10.4</a>).

<p>
Module names occupy the same namespace as other identifiers and follow
the same scoping rules.
Unless exported, identifiers defined within a module are visible only
within that module.

<p>
Expressions within a module can reference identifiers bound outside of
the module.

<p>

<p><tt>(let&nbsp;([x&nbsp;3])<br>

&nbsp;&nbsp;(module&nbsp;m&nbsp;(plusx)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;plusx&nbsp;(lambda&nbsp;(y)&nbsp;(+&nbsp;x&nbsp;y))))<br>

&nbsp;&nbsp;(import&nbsp;m)<br>

&nbsp;&nbsp;(let&nbsp;([x&nbsp;4])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(plusx&nbsp;5)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;8</tt>
<p>Similarly, <tt>import</tt> does not prevent access to identifiers that
are visible where the import form appears, except for those variables
shadowed by the imported identifiers.

<p>

<p><tt>(module&nbsp;m&nbsp;(y)&nbsp;(define&nbsp;y&nbsp;'m-y))<br>

(let&nbsp;([x&nbsp;'local-x]&nbsp;[y&nbsp;'local-y])<br>

&nbsp;&nbsp;(import&nbsp;m)<br>

&nbsp;&nbsp;(list&nbsp;x&nbsp;y))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(local-x&nbsp;m-y)</tt>
<p>On the other hand, use of <tt>import-only</tt> within a module
establishes an isolated scope in
which the only visible identifiers are those exported by the
imported module.

<p>

<p><tt>(module&nbsp;m&nbsp;(y)&nbsp;(define&nbsp;y&nbsp;'m-y))<br>

(let&nbsp;([x&nbsp;'local-x]&nbsp;[y&nbsp;'local-y])<br>

&nbsp;&nbsp;(import-only&nbsp;m)<br>

&nbsp;&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;Error:&nbsp;x&nbsp;is&nbsp;not&nbsp;visible</tt>
<p>This is sometimes desirable for static verification that no
identifiers are used except those explicitly imported into a
module or local scope.

<p>
Unless a module imported via <tt>import-only</tt> exports
<tt>import</tt> or
<tt>import-only</tt> and the name of at least one module, subsequent
imports within the scope of the <tt>import-only</tt> form are not
possible.
To create an isolated scope containing the exports of more than one
module without making <tt>import</tt> or <tt>import-only</tt>
visible, all of the modules to be imported must be listed in the
same <tt>import-only</tt> form.

<p>
Another solution is to create a single module that contains
the exports of each of the other modules.

<p>

<p><tt>(module&nbsp;m2&nbsp;(y)&nbsp;(define&nbsp;y&nbsp;'y))<br>

(module&nbsp;m1&nbsp;(x)&nbsp;(define&nbsp;x&nbsp;'x))<br>

(module&nbsp;mega-module&nbsp;(cons&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;(import&nbsp;m1)<br>

&nbsp;&nbsp;(import&nbsp;m2)<br>

&nbsp;&nbsp;(import&nbsp;scheme))<br>

(let&nbsp;([y&nbsp;3])<br>

&nbsp;&nbsp;(import-only&nbsp;mega-module)<br>

&nbsp;&nbsp;(cons&nbsp;x&nbsp;y))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(x&nbsp;.&nbsp;y)</tt>
<p><p>Before it is compiled, a source program is translated into
a core language program containing no syntactic abstractions, syntactic
definitions, library definitions, module definitions, or import forms.
Translation is performed by a <i>syntax expander</i> that
processes the forms in the source program via recursive descent.

<p>
A <tt>define-syntax</tt> form associates a keyword
with a transformer in a translation-time environment.
When the expander encounters a keyword, it invokes the
associated transformer and reprocesses the resulting form.
A <tt>module</tt> form associates a module name with an interface.
When the expander encounters an <tt>import</tt> form, it extracts the
corresponding module interface from the translation-time environment and makes
the exported bindings visible in the scope where the <tt>import</tt> form
appears.

<p>
Internal definitions and definitions within a <tt>module</tt>
body are processed from left to right so that a module's definition
and import may appear within the same sequence of definitions.
Expressions appearing within a body and the right-hand sides of variable
definitions, however, are translated
only after the entire set of definitions has been processed, allowing
full mutual recursion among variable and syntactic definitions.

<p>
Module and import forms affect only the visibility of identifiers in
the source program, not their meanings.
In particular, variables are bound to locations whether defined within or
outside of a module, and <tt>import</tt> does not introduce new locations.
Local variables are renamed as necessary to preserve the scoping
relationships established by both modules and syntactic abstractions.
Thus, the expression:

<p>

<p><tt>(let&nbsp;([x&nbsp;1])<br>

&nbsp;&nbsp;(module&nbsp;m&nbsp;(x&nbsp;setter)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define-syntax&nbsp;x&nbsp;(identifier-syntax&nbsp;z))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;setter&nbsp;(lambda&nbsp;(x)&nbsp;(set!&nbsp;z&nbsp;x)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;z&nbsp;5))<br>

&nbsp;&nbsp;(let&nbsp;([y&nbsp;x]&nbsp;[z&nbsp;0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(import&nbsp;m)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(setter&nbsp;3)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;x&nbsp;y&nbsp;z)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4</tt>
<p>is equivalent to the following program
in which identifiers have been consistently renamed as indicated by
subscripts.

<p>

<p><tt>(let&nbsp;([x<i><sub>0</sub></i>&nbsp;1])<br>

&nbsp;&nbsp;(define-syntax&nbsp;x<i><sub>1</sub></i>&nbsp;(identifier-syntax&nbsp;z<i><sub>1</sub></i>))<br>

&nbsp;&nbsp;(define&nbsp;setter<i><sub>1</sub></i>&nbsp;(lambda&nbsp;(x<i><sub>2</sub></i>)&nbsp;(set!&nbsp;z<i><sub>1</sub></i>&nbsp;x<i><sub>2</sub></i>)))<br>

&nbsp;&nbsp;(define&nbsp;z<i><sub>1</sub></i>&nbsp;5)<br>

&nbsp;&nbsp;(let&nbsp;([y<i><sub>3</sub></i>&nbsp;x<i><sub>0</sub></i>]&nbsp;[z<i><sub>3</sub></i>&nbsp;0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(setter<i><sub>1</sub></i>&nbsp;3)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;x<i><sub>1</sub></i>&nbsp;y<i><sub>3</sub></i>&nbsp;z<i><sub>3</sub></i>)))</tt>
<p>Definitions within a top-level <tt>begin</tt>, <tt>lambda</tt>, top-level program,
<tt>library</tt>, or <tt>module</tt> body
are processed from left to right by the expander at expand time, and the
variable definitions are evaluated from left-to-right at run time.
Initialization expressions appearing within a <tt>module</tt> body
are evaluated in sequence after the evaluation of the variable
definitions.

<p>
Mutually recursive modules can be defined in several ways.
In the following program, <tt>a</tt> and <tt>b</tt> are mutually recursive
modules exported by an anonymous module whose local scope is used to
statically link the two.
For example,
the free variable <tt>y</tt> within module <tt>a</tt> refers to
the binding for <tt>y</tt>, provided by importing <tt>b</tt>,
in the enclosing module.

<p>

<p><tt>(module&nbsp;(a&nbsp;b)<br>

&nbsp;&nbsp;(module&nbsp;a&nbsp;(x)&nbsp;(define&nbsp;x&nbsp;(lambda&nbsp;()&nbsp;y)))<br>

&nbsp;&nbsp;(module&nbsp;b&nbsp;(y)&nbsp;(define&nbsp;y&nbsp;(lambda&nbsp;()&nbsp;x)))<br>

&nbsp;&nbsp;(import&nbsp;a)<br>

&nbsp;&nbsp;(import&nbsp;b))</tt>
<p>The following syntactic abstraction generalizes this pattern to
permit the definition of multiple mutually recursive modules.

<p>

<p><tt>(define-syntax&nbsp;rec-modules<br>

&nbsp;&nbsp;(syntax-rules&nbsp;(module)<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(module&nbsp;m&nbsp;(id&nbsp;...)&nbsp;form&nbsp;...)&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(module&nbsp;(m&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(module&nbsp;m&nbsp;(id&nbsp;...)&nbsp;form&nbsp;...)&nbsp;...<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(import&nbsp;m)&nbsp;...)]))</tt>
<p>Because a module can re-export imported bindings,
it is quite easy to provide multiple views on a single
module, as <tt>s</tt> and <tt>t</tt> provide for <tt>r</tt>
below, or to combine several modules into a compound,
as <tt>r</tt> does.

<p>

<p><tt>(module&nbsp;p&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;(define&nbsp;x&nbsp;1)&nbsp;(define&nbsp;y&nbsp;2))<br>

(module&nbsp;q&nbsp;(y&nbsp;z)<br>

&nbsp;&nbsp;(define&nbsp;y&nbsp;3)&nbsp;(define&nbsp;z&nbsp;4))<br>

(module&nbsp;r&nbsp;(a&nbsp;b&nbsp;c&nbsp;d)<br>

&nbsp;&nbsp;(import*&nbsp;p&nbsp;(a&nbsp;x)&nbsp;(b&nbsp;y))<br>

&nbsp;&nbsp;(import*&nbsp;q&nbsp;(c&nbsp;y)&nbsp;(d&nbsp;z)))<br>

(module&nbsp;s&nbsp;(a&nbsp;c)&nbsp;(import&nbsp;r))<br>

(module&nbsp;t&nbsp;(b&nbsp;d)&nbsp;(import&nbsp;r))</tt>
<p>To allow interfaces to be separated from implementations,
the following syntactic abstractions support the definition and use of
named interfaces.

<p>

<p><tt>(define-syntax&nbsp;define-interface<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;name&nbsp;(export&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-syntax&nbsp;name<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;n&nbsp;defs)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-implicit&nbsp;(n&nbsp;export&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(module&nbsp;n&nbsp;(export&nbsp;...)&nbsp;.<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defs))])))]))
<br>
<br>
(define-syntax&nbsp;define-module<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;name&nbsp;interface&nbsp;defn&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(interface&nbsp;name&nbsp;(defn&nbsp;...))]))</tt>
<p><tt>define-interface</tt> creates an interface macro that, given a module
name and a list of definitions, expands into a module definition with
a concrete interface.

<p>
<tt>with-implicit</tt> is used to ensure that the introduced
<tt>export</tt> identifiers are visible in the same scope as the name of
the module in the <tt>define-module</tt> form.

<p>
<tt>define-interface</tt> and <tt>define-module</tt> can be used as
follows.

<p>

<p><tt>(define-interface&nbsp;simple&nbsp;(a&nbsp;b))<br>

(define-module&nbsp;m&nbsp;simple<br>

&nbsp;&nbsp;(define-syntax&nbsp;a&nbsp;(identifier-syntax&nbsp;1))<br>

&nbsp;&nbsp;(define&nbsp;b&nbsp;(lambda&nbsp;()&nbsp;c))<br>

&nbsp;&nbsp;(define&nbsp;c&nbsp;2))<br>

(let&nbsp;()&nbsp;(import&nbsp;m)&nbsp;(+&nbsp;a&nbsp;(b)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3</tt>
<p>The abstract module facility defined below allows a module interface to
be satisfied incrementally when module forms are evaluated.
This permits flexibility in the separation between the interface and
implementation, supports separate compilation of mutually recursive
modules, and permits redefinition of module implementations.

<p>

<p><tt>(define-syntax&nbsp;abstract-module<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;name&nbsp;(ex&nbsp;...)&nbsp;(kwd&nbsp;...)&nbsp;defn&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(module&nbsp;name&nbsp;(ex&nbsp;...&nbsp;kwd&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(declare&nbsp;ex)&nbsp;...<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defn&nbsp;...)]))
<br>
<br>
(define-syntax&nbsp;implement<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;name&nbsp;form&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(module&nbsp;()&nbsp;(import&nbsp;name)&nbsp;form&nbsp;...)]))</tt>
<p>Within an <tt>abstract-module</tt> form,
each of the exports in the list <tt><i>ex</i>&nbsp;...</tt> must be
variables.
The values of these variables are supplied by one or more separate
<tt>implement</tt> forms.
Since keyword bindings must be present at compile time,
they cannot be satisfied incrementally and are instead listed as
separate exports and defined within the abstract module.

<p>
Within an <tt>implement</tt> form,
the sequence of forms <tt><i>form</i>&nbsp;...</tt> is a sequence of
zero or more definitions followed by a sequence of zero or more
expressions.
Since the module used in the expansion of <tt>implement</tt> does
not export anything, the definitions are all local to the
<tt>implement</tt> form.
The expressions may be arbitrary expressions, but should include
one <tt>satisfy</tt> form for each variable whose definition is
supplied by the <tt>implement</tt> form.
A <tt>satisfy</tt> form has the syntax

<p>

<p><tt>(satisfy&nbsp;<i>variable</i>&nbsp;<i>expr</i>)</tt>
<p><tt>declare</tt> and <tt>satisfy</tt> may simply be the equivalents of
<tt>define</tt> and <tt>set!</tt>.

<p>

<p><tt>(define-syntax&nbsp;declare&nbsp;(identifier-syntax&nbsp;define))<br>

(define-syntax&nbsp;satisfy&nbsp;(identifier-syntax&nbsp;set!))</tt>
<p>Alternatively, <tt>declare</tt> can initialize the declared variable to
the value of a flag known only to <tt>declare</tt> and <tt>satisfy</tt>,
and <tt>satisfy</tt> can verify that this flag is still present to insure
that only one attempt to satisfy the value of a given identifier is
made.

<p>

<p><tt>(module&nbsp;((declare&nbsp;cookie)&nbsp;(satisfy&nbsp;cookie))<br>

&nbsp;&nbsp;(define&nbsp;cookie&nbsp;"chocolate&nbsp;chip")<br>

&nbsp;&nbsp;(define-syntax&nbsp;declare<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()&nbsp;[(_&nbsp;var)&nbsp;(define&nbsp;var&nbsp;cookie)]))<br>

&nbsp;&nbsp;(define-syntax&nbsp;satisfy<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;var&nbsp;exp)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eq?&nbsp;var&nbsp;cookie)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;var&nbsp;exp)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violationf&nbsp;'satisfy<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"value&nbsp;of&nbsp;variable&nbsp;~s&nbsp;has&nbsp;already&nbsp;been&nbsp;satisfied"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'var))])))</tt>
<p>Using <tt>abstract-module</tt> and <tt>implement</tt>, we can define
mutually recursive and separately compilable modules as follows.

<p>

<p><tt>(abstract-module&nbsp;e&nbsp;(even?)&nbsp;(pred)<br>

&nbsp;&nbsp;(define-syntax&nbsp;pred<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()&nbsp;[(_&nbsp;exp)&nbsp;(-&nbsp;exp&nbsp;1)])))
<br>
<br>
(abstract-module&nbsp;o&nbsp;(odd?)&nbsp;())
<br>
<br>
(implement&nbsp;e<br>

&nbsp;&nbsp;(import&nbsp;o)<br>

&nbsp;&nbsp;(satisfy&nbsp;even?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(zero?&nbsp;x)&nbsp;(odd?&nbsp;(pred&nbsp;x))))))
<br>
<br>
(implement&nbsp;o<br>

&nbsp;&nbsp;(import&nbsp;e)<br>

&nbsp;&nbsp;(satisfy&nbsp;odd?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(not&nbsp;(even?&nbsp;x)))))
<br>
<br>
(let&nbsp;()&nbsp;(import-only&nbsp;e)&nbsp;(even?&nbsp;38))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./syntax:s22"></a><span class=formdef><b>syntax</b>: <tt>only</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>except</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>add-prefix</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>drop-prefix</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>rename</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>alias</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These identifiers are auxiliary keywords for <tt>import</tt>
and <tt>import-only</tt>.
It is a syntax violation to reference these identifiers except in
contexts where they are recognized as auxiliary keywords.

<p>

<h3><a name="g104"></a><a name="./syntax:h6"></a>Section 11.6. Standalone import and export forms<a name="SECTSYNTAXIMPORTEXPORTFORMS"></a></h3>



<p>
The local import and export forms described in
Section&nbsp;<a href="./libraries.html#g94">10.4</a> can be used
equally well for and within modules.

<p>

<h3><a name="g105"></a><a name="./syntax:h7"></a>Section 11.7. Built-in Modules<a name="SECTSYNTAXBUILTINMODULES"></a></h3>



<p>
Five modules are built-in to <i>Chez&nbsp;Scheme</i>: <a name="./syntax:s23"></a><tt>scheme</tt>,
<a name="./syntax:s24"></a><tt>r5rs</tt>, <a name="./syntax:s25"></a><tt>r5rs-syntax</tt>, <a name="./syntax:s26"></a><tt>ieee</tt>, and
<a name="./syntax:s27"></a><tt>$system</tt>.
Each module is immutable, i.e., the exported bindings cannot be
altered.

<p>
<a name="./syntax:s28"></a><span class=formdef><b>module</b>: <tt>scheme</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>scheme</tt> contains all user-visible top-level bindings
(variables, keywords, and module names) built into <i>Chez&nbsp;Scheme</i>.

<p>
<a name="./syntax:s29"></a><span class=formdef><b>module</b>: <tt>r5rs</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>r5rs</tt> contains all top-level bindings
(variables and keywords) defined in the
Revised<sup>5</sup> Report on Scheme.
The bindings exported from <tt>r5rs</tt> are precisely those that are
available within an expression evaluated via <tt>eval</tt> with the
environment specifier returned by
<a name="./syntax:s30"></a><tt>scheme-report-environment</tt>.

<p>
<a name="./syntax:s31"></a><span class=formdef><b>module</b>: <tt>r5rs-syntax</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>r5rs-syntax</tt> contains all top-level keyword bindings
defined in the Revised<sup>5</sup> Report on Scheme.
The bindings exported from <tt>r5rs-syntax</tt> are precisely those that are
available within an expression evaluated via <tt>eval</tt> with the
environment specifier returned by
<a name="./syntax:s32"></a><tt>null-environment</tt>.

<p>
<a name="./syntax:s33"></a><span class=formdef><b>module</b>: <tt>ieee</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>ieee</tt> contains all top-level bindings
(variables and keywords) defined in the
ANSI/IEEE standard for Scheme.
The bindings exported from <tt>ieee</tt> are precisely those that are
available within an expression evaluated via <tt>eval</tt> with the
environment specifier returned by
<a name="./syntax:s34"></a><tt>ieee-environment</tt>.


<p>
<a name="./syntax:s35"></a><span class=formdef><b>module</b>: <tt>$system</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>$system</tt> contains all user-visible top-level bindings built
into <i>Chez&nbsp;Scheme</i> along with various undocumented system bindings.


<p>

<h3><a name="g106"></a><a name="./syntax:h8"></a>Section 11.8. Meta Definitions<a name="SECTSYNTAXMETA"></a></h3>



<p>
<a name="./syntax:s36"></a><span class=formdef><b>syntax</b>: <tt>(meta&nbsp;.&nbsp;<i>definition</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The <tt>meta</tt> keyword is actually a prefix that can be placed in
front of any definition keyword, e.g.,

<p>

<p><tt>(meta&nbsp;define&nbsp;x&nbsp;3)</tt>
<p>It tells the expander that any variable definition resulting
from the definition is to be an expand-time definition available only
to the right-hand sides of other meta definitions and, most importantly,
transformer expressions.
It is used to define expand-time helpers and other information for use
by one or more <tt>syntax-case</tt> transformers.


<p>

<p><tt>(module&nbsp;M&nbsp;(helper1&nbsp;a&nbsp;b)<br>

&nbsp;&nbsp;(meta&nbsp;define&nbsp;helper1<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(---)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---))<br>

&nbsp;&nbsp;(meta&nbsp;define&nbsp;helper2<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(---)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---&nbsp;(helper2&nbsp;---)&nbsp;---))<br>

&nbsp;&nbsp;(define-syntax&nbsp;a<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---&nbsp;(helper1&nbsp;---)&nbsp;---))<br>

&nbsp;&nbsp;(define-syntax&nbsp;b<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---&nbsp;(helper1&nbsp;---)&nbsp;---<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---&nbsp;(helper2&nbsp;---)&nbsp;---)))</tt>
<p>The right-hand-side expressions of a syntax definition or meta definition
can refer only to identifiers whose values are already available in the
compile-time environment.
Because of the left-to-right expansion order for <tt>library</tt>,
<tt>module</tt>, <tt>lambda</tt>, and similar bodies, this implies a
semantics similar to <tt>let*</tt> for a sequence of meta definitions,
in which each right-hand side can refer only to the variables defined
earlier in the sequence.
An exception is that the right-hand side of a meta definition can refer
to its own name as long as the reference is not evaluated until after
the value of the expression has been computed.
This permits meta definitions to be self-recursive but not mutually
recursive.
The right-hand side of a meta definition can, however, build syntax
objects containing occurrences of any identifiers defined in the body
in which the meta definition appears.

<p>
Meta definitions propagate through macro expansion, so one can write,
for example:

<p>

<p><tt>(module&nbsp;(a)<br>

&nbsp;&nbsp;(meta&nbsp;define-record&nbsp;foo&nbsp;(x))<br>

&nbsp;&nbsp;(define-syntax&nbsp;a<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([q&nbsp;(make-foo&nbsp;#''q)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(foo-x&nbsp;q)))))<br>

a&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;q</tt>
<p>where define-record is a macro that expands into a set of defines.

<p>
It is also sometimes convenient to write

<p>

<p><tt>(meta&nbsp;begin&nbsp;defn&nbsp;...)</tt>
<p>or

<p>

<p><tt>(meta&nbsp;module&nbsp;&#123;exports&#125;&nbsp;defn&nbsp;...)</tt>
<p>or

<p>

<p><tt>(meta&nbsp;include&nbsp;"<i>path</i>")</tt>
<p>to create groups of meta bindings.

<p>

<h3><a name="g107"></a><a name="./syntax:h9"></a>Section 11.9. Conditional expansion<a name="SECTSYNTAXMETACOND"></a></h3>



<p>
Expansion-time decisions can be made via <tt>meta-cond</tt>, which is
similar to <tt>cond</tt> but evaluates the test expressions at
expansion time and can be used in contexts where definitions are
expected as well as in expression contexts.

<p>
<a name="./syntax:s37"></a><span class=formdef><b>syntax</b>: <tt>(meta-cond&nbsp;<i>clause<sub>1</sub></i>&nbsp;<i>clause<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Each <tt><i>clause</i></tt> but the last must take the form:

<p>

<p><tt>(<i>test</i>&nbsp;<i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...)</tt>
<p>The last may take the same form or be an <tt>else</tt> clause of the form:

<p>

<p><tt>(<i>else</i>&nbsp;<i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...)</tt>
<p>During expansion, the <tt><i>test</i></tt> expressions are evaluated in order until
one evaluates to a true value or until all of the tests have been
evaluated.
If a <tt><i>test</i></tt> evaluates to a true value, the <tt>meta-cond</tt> form
expands to a <tt>begin</tt> form containing the corresponding
expressions <tt><i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...</tt>.
If no <tt><i>test</i></tt> evaluates to a true value and an <tt>else</tt> clause
is present, the <tt>meta-cond</tt> form expands to a <tt>begin</tt> form
containing the expressions <tt><i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...</tt> from
the <tt>else</tt> clause.
Otherwise the <tt>meta-cond</tt> expression expands into a call to
the <tt>void</tt> procedure.

<p>
<tt>meta-cond</tt> might be defined as follows.

<p>

<p><tt>(define-syntax&nbsp;meta-cond<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;[a0&nbsp;a1&nbsp;a2&nbsp;...]&nbsp;[b0&nbsp;b1&nbsp;b2&nbsp;...]&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let-syntax&nbsp;([expr&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[a0&nbsp;(identifier-syntax&nbsp;(begin&nbsp;a1&nbsp;a2&nbsp;...))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[b0&nbsp;(identifier-syntax&nbsp;(begin&nbsp;b1&nbsp;b2&nbsp;...))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expr)]))</tt>
<p><tt>meta-cond</tt> is used to choose, at expansion time, from among a
set of possible forms.
For example, one might have safe (error-checking) and unsafe
(non-error-checking) versions of a procedure and decide which to
call based on the compile-time optimization level, as shown
below.

<p>

<p><tt>(meta-cond<br>

&nbsp;&nbsp;[(=&nbsp;(optimize-level)&nbsp;3)&nbsp;(unsafe-frob&nbsp;x)]<br>

&nbsp;&nbsp;[else&nbsp;(safe-frob&nbsp;x)])</tt>
<p>
<h3><a name="g108"></a><a name="./syntax:h10"></a>Section 11.10. Aliases<a name="SECTSYNTAXALIAS"></a></h3>



<p>
<a name="./syntax:s38"></a><span class=formdef><b>syntax</b>: <tt>(alias&nbsp;<i>id<sub>1</sub></i>&nbsp;<i>id<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>alias</tt> is a definition and can appear anywhere
other definitions can appear.
It is used to transfer the binding from one identifier to
another.

<p>

<p><tt>(let&nbsp;([x&nbsp;3])&nbsp;(alias&nbsp;y&nbsp;x)&nbsp;(set!&nbsp;y&nbsp;4)&nbsp;(list&nbsp;x&nbsp;y))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(4&nbsp;4)
<br>
<br>
(module&nbsp;lisp&nbsp;(if)<br>

&nbsp;&nbsp;(module&nbsp;(scheme:if)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(import&nbsp;scheme)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(alias&nbsp;scheme:if&nbsp;if))<br>

&nbsp;&nbsp;(define-syntax&nbsp;if<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e_1&nbsp;e_2&nbsp;e_3)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(scheme:if&nbsp;(not&nbsp;(memq&nbsp;e_1&nbsp;'(#f&nbsp;())))&nbsp;e_2&nbsp;e_3)])))<br>

(define&nbsp;(length&nbsp;ls)<br>

&nbsp;&nbsp;(import&nbsp;lisp)<br>

&nbsp;&nbsp;(if&nbsp;ls&nbsp;(+&nbsp;(length&nbsp;(cdr&nbsp;ls))&nbsp;1)&nbsp;0))<br>

(length&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3</tt>
<p>Because of left-to-right expansion order, aliases should appear after
the definition of the right-hand-side identifier, e.g.:

<p>

<p><tt>(let&nbsp;()<br>

&nbsp;&nbsp;(import-only&nbsp;(chezscheme))<br>

&nbsp;&nbsp;(define&nbsp;y&nbsp;3)<br>

&nbsp;&nbsp;(alias&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3</tt>
<p>rather than:

<p>

<p><tt>(let&nbsp;()<br>

&nbsp;&nbsp;(import-only&nbsp;(chezscheme))<br>

&nbsp;&nbsp;(alias&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;(define&nbsp;y&nbsp;3)<br>

&nbsp;&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;unbound&nbsp;identifier</i></tt>
<p>
<h3><a name="g109"></a><a name="./syntax:h11"></a>Section 11.11. Annotations<a name="SECTSYNTAXANNOTATIONS"></a></h3>



<p>
<a name="./syntax:s39"></a>When source code is read from a file by <tt>load</tt>,
<tt>compile-file</tt>, or variants of these, such as
<tt>load-library</tt>, the reader attaches <i>annotations</i> to each
object read from the file.
These annotations identify the file and the position of the object within
the file.
Annotations are tracked through the compilation process and associated
with compiled code at run time.
The expander and compiler use the annotations to produce syntax errors
and compiler warnings that identify the location of the offending form,
and the inspector uses them to identify the locations of calls and
procedure definitions.
The compiler and run time also use annotations to associate source
positions with profile counts.

<p>
While these annotations are usually maintained "behind the scenes,"
the programmer can manipulate them directly via a set
of routines for creating and accessing annotations.

<p>
Annotations are values of a type distinct from other types and have
four components: an expression, possibly with annotated subexpressions,
a <i>source object</i>, a stripped version of the expression, and
usage options.
Annotations can be created via
<a name="./syntax:s40"></a><tt>make-annotation</tt>, which has
three required arguments corresponding to the first three components
and an optional fourth argument corresponding to the fourth component.
The second argument must be a source object, and the third argument should be a
stripped version of the first argument, i.e., equivalent to the first
argument with each annotation replaced by its expression component.
An annotation is essentially equivalent to its stripped component as a
representation of source code, with the source information attached and
available to the expander or evaluator.
The optional fourth argument, if present, must be an enumeration set over
the symbols <tt>debug</tt> and <tt>profile</tt> and defaults to an
enumeration set containing both <tt>debug</tt> and <tt>profile</tt>.

<p>
Annotations marked <tt>debug</tt> are used for compile-time error
reporting and run-time error reporting and inspection; annotations
marked <tt>profile</tt> are used for profiling.
Annotations created by the Scheme reader are always marked both
<tt>debug</tt> and <tt>profile</tt>, but other readers and parsers
might choose to mark some annotations only <tt>debug</tt> or only
<tt>profile</tt>.
In particular, it might be useful to annotate multiple
expressions in the output of a parser with the same source object
for debugging purposes and mark only one of them <tt>profile</tt>
to avoid duplicate counts.
It might also be useful to mark no expressions <tt>profile</tt> and
instead introduce explicit <tt>profile</tt> forms
(Section&nbsp;<a href="./system.html#g118">12.7</a>) to identify the set of source
locations to be profiled.

<p>
<a name="./syntax:s41"></a>Source objects are also values of a type distinct from other types and
also have three or five components: a <i>source-file descriptor</i> (sfd),
a beginning file position (bfp), an ending file position (efp),
an optional beginning line, and an optional beginning
column. The sfd identifies the file from which an expression is read and the
bfp and efp identify the range of character positions occupied by the object
in the file, with the bfp being inclusive and the efp being exclusive.
The line and column are either both numbers or both not present.
A source object can be created via
<a name="./syntax:s42"></a><tt>make-source-object</tt>, which
takes either three or five arguments corresponding to these components.
The first argument must be a source-file descriptor, the second and
third must be nonnegative exact integers, the second must not be
greater than the third, and the fourth and fifth (if provided) must
be positive exact integers.

<p>
<a name="./syntax:s43"></a>Source-file descriptors are also values of a type distinct
from all other types and have two components: the file's path,
represented by a string, and a checksum, represented by a number.
The path might or might not be an absolute path depending on how
the file's path was specified when the source-file descriptor was
created.
The checksum is computed based on the file's length and contents
when the file is created and checked by tools that look for the
source file to make sure that the proper file has been found and
has not been modified.
Source-file descriptors can be created with
<a name="./syntax:s44"></a><tt>make-source-file-descriptor</tt>,
which accepts two arguments: a string naming the path and a binary
input port, along with an optional third boolean argument, <tt><i>reset?</i></tt>,
which defaults to false.
<tt>make-source-file-descriptor</tt> computes a checksum based on
the contents of the port, starting at its current position.
It resets the port, using <tt>set-port-position!</tt>, after computing
the checksum if <tt><i>reset?</i></tt> is true; otherwise, it leaves the
port at end-of-file.

<p>
The procedures that create, check for, and access annotations,
source objects, and source-file descriptors are summarized below
and described in more detail later in this section.

<p>

<p><tt>(make-annotation&nbsp;<i>obj</i>&nbsp;<i>source-object</i>&nbsp;<i>obj</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>annotation</i><br>

(annotation?&nbsp;<i>obj</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>boolean</i><br>

(annotation-expression&nbsp;<i>annotation</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>obj</i><br>

(annotation-source&nbsp;<i>annotation</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>source-object</i><br>

(annotation-stripped&nbsp;<i>annotation</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>obj</i>
<br>
<br>
(make-source-object&nbsp;<i>sfd</i>&nbsp;<i>uint</i>&nbsp;<i>uint</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>source-object</i><br>

(make-source-object&nbsp;<i>sfd</i>&nbsp;<i>uint</i>&nbsp;<i>uint</i>&nbsp;<i>uint</i>&nbsp;<i>uint</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>source-object</i><br>

(source-object?&nbsp;<i>obj</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>boolean</i><br>

(source-object-sfd&nbsp;<i>source-object</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>sfd</i><br>

(source-object-bfp&nbsp;<i>source-object</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>uint</i><br>

(source-object-efp&nbsp;<i>source-object</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>uint</i><br>

(source-object-line&nbsp;<i>source-object</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>uint</i>&nbsp;or&nbsp;#f<br>

(source-object-column&nbsp;<i>source-object</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>uint</i>&nbsp;or&nbsp;#f
<br>
<br>
(make-source-file-descriptor&nbsp;<i>string</i>&nbsp;<i>binary-input-port</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>sfd</i><br>

(make-source-file-descriptor&nbsp;<i>string</i>&nbsp;<i>binary-input-port</i>&nbsp;<i>reset?</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>sfd</i><br>

(source-file-descriptor?&nbsp;<i>obj</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>boolean</i><br>

(source-file-descriptor-checksum&nbsp;<i>sfd</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>obj</i><br>

(source-file-descriptor-path&nbsp;<i>sfd</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>obj</i></tt>
<p>A program might open a source file with
<tt>open-file-input-port</tt>, create an sfd using
<a name="./syntax:s45"></a><tt>make-source-file-descriptor</tt>,
create a textual port from the binary port using transcoded-port, and
create source objects and annotations for each of the objects it reads
from the file.
If a custom reader is not required, the Scheme
reader can be used to read annotations via the
<a name="./syntax:s46"></a><tt>get-datum/annotations</tt>
procedure:

<p>

<p><tt>(get-datum/annotations&nbsp;<i>textual-input-port</i>&nbsp;<i>sfd</i>&nbsp;<i>uint</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;<i>obj</i>,&nbsp;<i>uint</i></tt>
<p><tt>get-datum/annotations</tt> is like <tt>get-datum</tt> but instead of returning
a plain datum, it returns an annotation encapsulating a datum (possibly with nested
annotations), a source object, and the plain (stripped) datum.  
It also returns a second value, the position of the first character beyond the
object in the file.
Character positions are accepted and returned by
<tt>get-datum/annotations</tt> so that the textual port need not support
<tt>port-position</tt> and need not report positions in characters
if it does support <tt>port-position</tt>.
(Positions are usually reported in bytes.)
The bfp and efp positions recorded in the annotations returned by
<tt>get-datum/annotations</tt> are correct only if the positions supplied
to it are correct.

<p>
Once read, an annotation can be passed to the expander, interpreter, or
compiler.
The procedures <tt>eval</tt>, <tt>expand</tt>, <tt>interpret</tt>,
and <tt>compile</tt> all accept annotated or unannotated input.

<p>
Two additional procedures complete the set of annotation-related primitives:

<p>

<p><tt>(open-source-file&nbsp;<i>sfd</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;#f&nbsp;or&nbsp;<i>port</i><br>

(syntax-&gt;annotation&nbsp;<i>obj</i>)&nbsp;<img src="math/csug/4.gif" alt="<graphic>">&nbsp;#f&nbsp;or&nbsp;<i>annotation</i></tt>
<p><a name="./syntax:s47"></a><tt>open-source-file</tt> attempts to
locate and open the source file identified by <tt><i>sfd</i></tt>.
It returns a textual input port, positioned at the beginning of the file,
if successful, and <tt>#f</tt> otherwise.

<p>
<a name="./syntax:s48"></a><tt>syntax-&gt;annotation</tt> accepts
a syntax object.
If the syntax object's expression is annotated, it returns the
annotation; otherwise, it returns <tt>#f</tt>.
It can be used by a macro to extract source information, when
available, from an input form.

<p>
The procedure <tt>datum-&gt;syntax</tt> accepts either an
annotated or unannotated input datum.

<p>
<a name="./syntax:s49"></a><span class=formdef><b>procedure</b>: <tt>(make-annotation&nbsp;<i>obj</i>&nbsp;<i>source-object</i>&nbsp;<i>stripped-obj</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-annotation&nbsp;<i>obj</i>&nbsp;<i>source-object</i>&nbsp;<i>stripped-obj</i>&nbsp;<i>options</i>)</tt></span>
<br>
<b>returns: </b>an annotation
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The annotation is formed with <tt><i>obj</i></tt> as its expression component,
<tt><i>source-object</i></tt> as its source-object component, and <tt><i>stripped-obj</i></tt>
as its stripped component.
<tt><i>obj</i></tt> should represent an expression, possibly with embedded
annotations.
<tt><i>stripped-obj</i></tt> should be a stripped version of <tt><i>obj</i></tt>, i.e.,
equivalent to <tt><i>obj</i></tt> with each annotation replaced by its
expression component.
<tt><i>options</i></tt>, if present must be an enumeration set over
the symbols <tt>debug</tt> and <tt>profile</tt>, and defaults to an
enumeration set containing both <tt>debug</tt> and <tt>profile</tt>.
Annotations marked <tt>debug</tt> are used for compile-time error
reporting and run-time error reporting and inspection; annotations
marked <tt>profile</tt> are used for profiling.

<p>
<a name="./syntax:s50"></a><span class=formdef><b>procedure</b>: <tt>(annotation?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an annotation, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./syntax:s51"></a><span class=formdef><b>procedure</b>: <tt>(annotation-expression&nbsp;<i>annotation</i>)</tt></span>
<br>
<b>returns: </b>the expression component of <tt><i>annotation</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./syntax:s52"></a><span class=formdef><b>procedure</b>: <tt>(annotation-source&nbsp;<i>annotation</i>)</tt></span>
<br>
<b>returns: </b>the source-object component of <tt><i>annotation</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./syntax:s53"></a><span class=formdef><b>procedure</b>: <tt>(annotation-stripped&nbsp;<i>annotation</i>)</tt></span>
<br>
<b>returns: </b>the stripped component of <tt><i>annotation</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./syntax:s54"></a><span class=formdef><b>procedure</b>: <tt>(annotation-options&nbsp;<i>annotation</i>)</tt></span>
<br>
<b>returns: </b>the options enumeration set of <tt><i>annotation</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./syntax:s55"></a><span class=formdef><b>procedure</b>: <tt>(make-source-object&nbsp;<i>sfd</i>&nbsp;<i>bfp</i>&nbsp;<i>efp</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-source-object&nbsp;<i>sfd</i>&nbsp;<i>bfp</i>&nbsp;<i>efp</i>&nbsp;<i>line</i>&nbsp;<i>column</i>)</tt></span>
<br>
<b>returns: </b>a source object
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>sfd</i></tt> must be a source-file descriptor.
<tt><i>bfp</i></tt> and <tt><i>efp</i></tt> must be exact nonnegative integers, and <tt><i>bfp</i></tt>
should not be greater than <tt><i>efp</i></tt>.
<tt><i>line</i></tt> and <tt><i>column</i></tt> must be exact positive integers.

<p>
<a name="./syntax:s56"></a><span class=formdef><b>procedure</b>: <tt>(source-object?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a source object, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./syntax:s57"></a><span class=formdef><b>procedure</b>: <tt>(source-object-sfd&nbsp;<i>source-object</i>)</tt></span>
<br>
<b>returns: </b>the sfd component of <tt><i>source-object</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./syntax:s58"></a><span class=formdef><b>procedure</b>: <tt>(source-object-bfp&nbsp;<i>source-object</i>)</tt></span>
<br>
<b>returns: </b>the bfp component of <tt><i>source-object</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./syntax:s59"></a><span class=formdef><b>procedure</b>: <tt>(source-object-efp&nbsp;<i>source-object</i>)</tt></span>
<br>
<b>returns: </b>the efp component of <tt><i>source-object</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./syntax:s60"></a><span class=formdef><b>procedure</b>: <tt>(source-object-line&nbsp;<i>source-object</i>)</tt></span>
<br>
<b>returns: </b>the line component of <tt><i>source-object</i></tt> if present, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./syntax:s61"></a><span class=formdef><b>procedure</b>: <tt>(source-object-column&nbsp;<i>source-object</i>)</tt></span>
<br>
<b>returns: </b>the column component of <tt><i>source-object</i></tt> if present, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./syntax:s62"></a><span class=formdef><b>thread parameter</b>: <tt>current-make-source-object</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>current-make-source-object</tt> is used by the reader to construct
a source object for an annotation. <tt>current-make-source-object</tt>
is initially bound to <tt>make-source-object</tt>, and the reader always
calls the function bound to the paramater with three arguments.

<p>
Adjust this parameter to, for example, eagerly convert a position integer
to a file-position object, instead of delaying the conversion to
<tt>locate-source</tt>.

<p>
<a name="./syntax:s63"></a><span class=formdef><b>procedure</b>: <tt>(make-source-file-descriptor&nbsp;<i>string</i>&nbsp;<i>binary-input-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-source-file-descriptor&nbsp;<i>string</i>&nbsp;<i>binary-input-port</i>&nbsp;<i>reset?</i>)</tt></span>
<br>
<b>returns: </b>a source-file descriptor
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>To compute the checksum encapsulated in the source-file descriptor,
this procedure must read all of the data from
<tt><i>binary-input-port</i></tt>.
If <tt><i>reset?</i></tt> is present and <tt>#t</tt>, the port is reset to its
original position, as if via <tt>port-position</tt>.
Otherwise, it is left pointing at end-of-file.

<p>
<a name="./syntax:s64"></a><span class=formdef><b>procedure</b>: <tt>(source-file-descriptor?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a source-file descriptor, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./syntax:s65"></a><span class=formdef><b>procedure</b>: <tt>(source-file-descriptor-checksum&nbsp;<i>sfd</i>)</tt></span>
<br>
<b>returns: </b>the checksum component of <tt><i>sfd</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./syntax:s66"></a><span class=formdef><b>procedure</b>: <tt>(source-file-descriptor-path&nbsp;<i>sfd</i>)</tt></span>
<br>
<b>returns: </b>the path component of <tt><i>sfd</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>sfd</i></tt> must be a source-file descriptor.

<p>
<a name="./syntax:s67"></a><span class=formdef><b>procedure</b>: <tt>(source-file-descriptor&nbsp;<i>path</i>&nbsp;<i>checksum</i>)</tt></span>
<br>
<b>returns: </b>a new source-file-descriptor
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string, and <tt><i>checksum</i></tt> must be an exact nonnegative integer.
This procedure can be used to construct custom source-file descriptors or to reconstitute
source-file descriptors from the <tt><i>path</i></tt> and <tt><i>checksum</i></tt> components.

<p>
<a name="./syntax:s68"></a><span class=formdef><b>syntax</b>: <tt>(annotation-option-set&nbsp;<i>symbol</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>an annotation-options enumeration set
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Annotation-options enumeration sets may be passed to <tt>make-annotation</tt> to
control whether the annotation is used for debugging, profiling, both, or neither.
Accordingly, each <tt><i>symbol</i></tt> must be either <tt><i>debug</i></tt> or <tt>profile</tt>.

<p>
<a name="./syntax:s69"></a><span class=formdef><b>procedure</b>: <tt>(syntax-&gt;annotation&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>an annotation or <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>obj</i></tt> is an annotation or syntax-object encapsulating an annotation,
the annotation is returned.

<p>
<a name="./syntax:s70"></a><span class=formdef><b>procedure</b>: <tt>(get-datum/annotations&nbsp;<i>textual-input-port</i>&nbsp;<i>sfd</i>&nbsp;<i>bfp</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>sfd</i></tt> must be a source-file descriptor.
<tt><i>bfp</i></tt> must be an exact nonnegative integer and should be the
character position of the next character to be read from
<tt><i>textual-input-port</i></tt>.

<p>
This procedure returns two values: an annotated object and an ending
file position.
In most cases, <tt><i>bfp</i></tt> should be 0 for the first call
to <tt>get-datum/annotation</tt> at the start of a file,
and it should be the second return value of the preceding
call to <tt>get-datum/annotation</tt> for each subsequent
call.
This protocol is necessary to handle files containing multiple-byte
characters, since file positions do not necessarily correspond
to character positions.

<p>
<a name="./syntax:s71"></a><span class=formdef><b>procedure</b>: <tt>(open-source-file&nbsp;<i>sfd</i>)</tt></span>
<br>
<b>returns: </b>a port or <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>sfd</i></tt> must be a source-file descriptor.
This procedure attempts to locate and open the source file identified
by <tt><i>sfd</i></tt>.
It returns a textual input port, positioned at the beginning of the file,
if successful, and <tt>#f</tt> otherwise.
It can fail even if a file with the correct name exists in one of
the source directories when the file's checksum does not match the
checksum recorded in <tt><i>sfd</i></tt>.

<p>
<a name="./syntax:s72"></a><span class=formdef><b>procedure</b>: <tt>(locate-source&nbsp;<i>sfd</i>&nbsp;<i>pos</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(locate-source&nbsp;<i>sfd</i>&nbsp;<i>pos</i>&nbsp;<i>use-cache?</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>sfd</i></tt> must be a source-file descriptor, and <tt><i>pos</i></tt> must be an
exact nonnegative integer.

<p>
This procedure either uses cached information from a previous
request for <tt><i>sfd</i></tt> (only when <tt><i>use-cache?</i></tt> is provided as true)
or attempts to locate and open the source file identified
by <tt><i>sfd</i></tt>.
If successful, it returns three values: a string <tt><i>path</i></tt>, an exact
nonnegative integer <tt><i>line</i></tt>, and an exact nonnegative integer <tt><i>char</i></tt>
representing the absolute pathname, line, and character position within
the line represented by the specified source-file descriptor and file
position.
If unsuccessful, it returns zero values.
It can fail even if a file with the correct name exists in one of
the source directories when the file's checksum does not match the
checksum recorded in <tt><i>sfd</i></tt>.

<p>
<a name="./syntax:s73"></a><span class=formdef><b>procedure</b>: <tt>(locate-source-object-source&nbsp;<i>source-object</i>&nbsp;<i>get-start?</i>&nbsp;<i>use-cache?</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure is similar to <tt>locate-source</tt>, but instead of
taking an sfd and a position, it takes a source object plus a request
for either the start or end location.

<p>
If <tt><i>get-start?</i></tt> is true and <tt><i>source-object</i></tt> has a line and column,
this procedure returns the path in
<tt><i>source-objects</i></tt>'s sfd, <tt><i>source-object</i></tt>'s line, and
<tt><i>source-objects</i></tt>'s column.

<p>
If <tt><i>source-object</i></tt> has no line and column, then
this procedure calls <tt>locate-source</tt> on
<tt><i>source-object</i></tt>'s sfd, either <tt><i>source-object</i></tt>'s bfp or efp
depending on <tt><i>get-start?</i></tt>, and <tt><i>use-cache?</i></tt>.

<p>
<a name="./syntax:s74"></a><span class=formdef><b>thread parameter</b>: <tt>current-locate-source-object-source</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>current-locate-source-object-source</tt> determines the
source-location lookup function that is used by the system to report
errors based on source objects. This parameter is initially bound to
<tt>locate-source-object-object</tt>.

<p>
Adjust this parameter to control the way that source locations are
extracted from source objects, possibly using recorded information,
caches, and the filesystem in a way different from
<tt>locate-source-object-object</tt>.


<p>

<h3><a name="g110"></a><a name="./syntax:h12"></a>Section 11.12. Source Tables<a name="SECTSYNTAXSOURCETABLES"></a></h3>



<p>
Source tables provide an efficient way to associate information
with source objects both in memory and on disk, such as the coverage information
saved to <tt>.covin</tt> files when
<a name="./syntax:s75"></a><tt>generate-covin-files</tt> is
set to <tt>#t</tt>
and the profile counts associated with source objects by
<a name="./syntax:s76"></a><tt>with-profile-tracker</tt>
(Section&nbsp;<a href="./system.html#g118">12.7</a>).

<p>
Source tables are manipulated via hashtable-like accessors and setters
(Section&nbsp;<a href="./objects.html#g59">7.12</a>, <i>The Scheme Programming Language, 4th Edition</i> Section&nbsp;<a href="http://scheme.com/tspl4/./objects.html#g119">6.13</a>), e.g.,
<a name="./syntax:s77"></a><tt>source-table-ref</tt> and <a name="./syntax:s78"></a><tt>source-table-set!</tt>.
They can be saved to files via
<a name="./syntax:s79"></a><tt>put-source-table</tt>
and restored via
<a name="./syntax:s80"></a><tt>get-source-table!</tt>.

<p>
<a name="./syntax:s81"></a><span class=formdef><b>procedure</b>: <tt>(make-source-table)</tt></span>
<br>
<b>returns: </b>a source table
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A source table contains associations between source objects and arbitrary
values.  For purposes of the source-table operations described below, two
source objects are the same if they have the same source-file descriptor,
equal beginning file positions and equal ending file positions.
Two source-file descriptors are the same if they have the same path and
checksum.

<p>
<a name="./syntax:s82"></a><span class=formdef><b>procedure</b>: <tt>(source-table?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a source-table; <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./syntax:s83"></a><span class=formdef><b>procedure</b>: <tt>(source-table-set!&nbsp;<i>source-table</i>&nbsp;<i>source-object</i>&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>source-table-set!</tt> associates <tt><i>source-object</i></tt>
with <tt><i>obj</i></tt> in <tt><i>source-table</i></tt>, replacing the
existing association, if any.


<p>
<a name="./syntax:s84"></a><span class=formdef><b>procedure</b>: <tt>(source-table-ref&nbsp;<i>source-table</i>&nbsp;<i>source-object</i>&nbsp;<i>default</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>default</i></tt> may be any Scheme value.

<p>
<tt>source-table-ref</tt> returns the value
associated with <tt><i>source-object</i></tt> in <tt><i>source-table</i></tt>.
If no value is associated with <tt><i>source-object</i></tt> in <tt><i>source-table</i></tt>,
<tt>source-table-ref</tt> returns <tt><i>default</i></tt>.


<p>
<a name="./syntax:s85"></a><span class=formdef><b>procedure</b>: <tt>(source-table-contains?&nbsp;<i>source-table</i>&nbsp;<i>source-object</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if an association for <tt><i>source-object</i></tt> exists in <tt><i>source-table</i></tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./syntax:s86"></a><span class=formdef><b>procedure</b>: <tt>(source-table-cell&nbsp;<i>source-table</i>&nbsp;<i>source-object</i>&nbsp;<i>default</i>)</tt></span>
<br>
<b>returns: </b>a pair (see below)
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>default</i></tt> may be any Scheme value.

<p>
If no value is associated with <tt><i>source-object</i></tt> in <tt><i>source-table</i></tt>,
<tt>source-table-cell</tt> modifies <tt><i>source-table</i></tt> to associate <tt><i>source-object</i></tt> with
<tt><i>default</i></tt>.
Regardless, it returns a pair whose car is <tt><i>source-object</i></tt> and whose cdr is
the associated value.
Changing the cdr of this pair effectively updates the table to
associate <tt><i>source-object</i></tt> with a new value.
The car field of the pair should not be modified.


<p>
<a name="./syntax:s87"></a><span class=formdef><b>procedure</b>: <tt>(source-table-delete!&nbsp;<i>source-table</i>&nbsp;<i>source-object</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>source-table-delete!</tt> drops the association
for <tt><i>source-object</i></tt> from <tt><i>source-table</i></tt>, if
one exists.


<p>
<a name="./syntax:s88"></a><span class=formdef><b>procedure</b>: <tt>(source-table-size&nbsp;<i>source-table</i>)</tt></span>
<br>
<b>returns: </b>the number of entries in <tt><i>source-table</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./syntax:s89"></a><span class=formdef><b>procedure</b>: <tt>(put-source-table&nbsp;<i>textual-output-port</i>&nbsp;<i>source-table</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure writes a representation of the information stored in <tt><i>source-table</i></tt> to the port.


<p>
<a name="./syntax:s90"></a><span class=formdef><b>procedure</b>: <tt>(get-source-table!&nbsp;<i>textual-input-port</i>&nbsp;<i>source-table</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(get-source-table!&nbsp;<i>textual-input-port</i>&nbsp;<i>source-table</i>&nbsp;<i>combine</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The port must be positioned at a representation of source-table
information written by some previous call to <tt>put-source-table</tt>,
which reads the information and merges it into <tt>source-table</tt>.

<p>
If present and non-false, <tt><i>combine</i></tt> must be a procedure and
should accept two arguments.
It is called whenever associations for the same source object are
present both in <tt><i>source-table</i></tt> and in the information read from
the port.
In this case, <tt><i>combine</i></tt> is passed two arguments: the associated
value from <tt><i>source-table</i></tt> and the associated value from the
port (in that order) and must return one value, which is recorded
as the new associated value for the source object in <tt><i>source-table</i></tt>.

<p>
If <tt><i>combine</i></tt> is not present, <tt><i>combine</i></tt> is <tt>#f</tt>, or
no association for a source object read from the port already exists
in <tt><i>source-table</i></tt>, the value read from the port is recorded as
the associated value of the source object in <tt><i>source-table</i></tt>.

<p>

<p><tt>(define&nbsp;st&nbsp;(make-source-table))<br>

(call-with-port&nbsp;(open-input-file&nbsp;"profile.out1")<br>

&nbsp;&nbsp;(lambda&nbsp;(ip)&nbsp;(get-source-table!&nbsp;ip&nbsp;st)))<br>

(call-with-port&nbsp;(open-input-file&nbsp;"profile.out2")<br>

&nbsp;&nbsp;(lambda&nbsp;(ip)&nbsp;(get-source-table!&nbsp;ip&nbsp;st&nbsp;+)))</tt>
<p>



<hr class=copyright align=left>
<p>
<a class=plain href="index.html">Chez Scheme Version 9 User's Guide</a><br>
Copyright &copy; 2022 Cisco Systems, Inc.<br>
Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License Version 2.0</a>
(<a class=plain href="canned/copyright.html">full copyright notice.</a>).</br>
Revised April 2022 for Chez Scheme Version 9.5.8<br>
<a class=plain href="canned/about.html">about this book</a>
</tr></table>
</body>
</html>
