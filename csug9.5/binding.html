<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Binding Forms</title>
<link href="csug.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g36"></a>
<a name="./binding:h0"></a>

<h1>Chapter 5. Binding Forms<a name="CHPTBINDING"></a></h1>





<p>
This chapter describes <i>Chez&nbsp;Scheme</i> extensions to the set of Revised<sup>6</sup>
Report binding forms.
See Chapter&nbsp;<a href="http://scheme.com/tspl4/./binding.html#g88">4</a> of <i>The Scheme Programming Language, 4th Edition</i> or the Revised<sup>6</sup> Report
for a description of standard binding forms.

<p>

<h3><a name="g37"></a><a name="./binding:h1"></a>Section 5.1. Definitions<a name="SECTDEFINITIONS"></a></h3>



<p>
A <a name="./binding:s0"></a>definition in Revised<sup>6</sup> Report Scheme is a
<a name="./binding:s1"></a><a name="./binding:s2"></a>variable definition,
<a name="./binding:s3"></a><a name="./binding:s4"></a>keyword
definition, or derived definition, i.e., a syntactic extension that
expands into a definition.
In addition, the forms within a
<a name="./binding:s5"></a><tt>begin</tt>
expression appearing after a sequence
of definitions is spliced onto the end of the sequence of definitions
so that definitions at the front of the <tt>begin</tt> expression
are treated as if they were part of the outer sequence of definitions.
A <a name="./binding:s6"></a><tt>let-syntax</tt> or
<a name="./binding:s7"></a><tt>letrec-syntax</tt> form
is treated similarly, so that definitions at the front of the body
are treated as if they were part of the outer sequence of definitions,
albeit scoped where the bindings of the <tt>let-syntax</tt> or
<tt>letrec-syntax</tt> form are visible.

<p>
<i>Chez&nbsp;Scheme</i> extends the set of definitions to include
<a name="./binding:s8"></a><a name="./binding:s9"></a><tt>module</tt> forms,
<a name="./binding:s10"></a><tt>import</tt> forms,
<a name="./binding:s11"></a><tt>import-only</tt> forms,
<a name="./binding:s12"></a><tt>meta</tt> definitions, and
<a name="./binding:s13"></a><tt>alias</tt> forms, although the
<tt>module</tt>, <tt>import</tt>, <tt>import-only</tt>,
<tt>meta</tt>, and <tt>alias</tt> keywords are not available
in a library or RNRS top-level program unless the
<tt>scheme</tt> library is included in the library or
top-level programs imports.
These forms are described in Chapter&nbsp;<a href="./syntax.html#g98">11</a>.

<p>
In Revised<sup>6</sup> Report Scheme, definitions can appear at the front of
a <tt>lambda</tt> or similar body (e.g., a <tt>let</tt> or <tt>letrec</tt>
body), at the front of a library body, or intermixed with expressions
within an RNRS top-level program body.
In <i>Chez&nbsp;Scheme</i>, definitions may also be used in the
interactive top-level, i.e., they can be intermixed with expressions in
the REPL or in program text to be loaded from a file
via <a name="./binding:s14"></a><tt>load</tt> (Section&nbsp;<a href="./system.html#g115">12.4</a>).
The Revised<sup>6</sup> Report does not mandate the existence nor specify the
semantics of an interactive top-level, nor of a <tt>load</tt>
procedure.

<p>
The macro expander uses the same two-pass algorithm for expanding
top-level <tt>begin</tt> expressions as it uses for a <tt>lambda</tt>,
<tt>library</tt>, or top-level program body.
(This algorithm is described in Section&nbsp;<a href="http://scheme.com/tspl4/./syntax.html#g134">8.1</a> of 
<i>The Scheme Programming Language, 4th Edition</i>.) As a result,

<p>

<p><tt>(begin<br>

&nbsp;&nbsp;(define-syntax&nbsp;a&nbsp;(identifier-syntax&nbsp;3))<br>

&nbsp;&nbsp;(define&nbsp;x&nbsp;a))</tt>
<p>and

<p>

<p><tt>(begin<br>

&nbsp;&nbsp;(define&nbsp;x&nbsp;a)<br>

&nbsp;&nbsp;(define-syntax&nbsp;a&nbsp;(identifier-syntax&nbsp;3)))</tt>
<p>both result in the giving <tt>x</tt> the value 3,
even though an unbound variable reference to <tt>a</tt> would result if
the two forms within the latter <tt>begin</tt> expression were run
independently at top level.

<p>
Similarly, the <tt>begin</tt> form produced by a use of

<p>

<p><tt>(define-syntax&nbsp;define-constant<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x&nbsp;e)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;t&nbsp;e)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-syntax&nbsp;x&nbsp;(identifier-syntax&nbsp;t)))]))</tt>
<p>and the <tt>begin</tt> form produced by a use of

<p>

<p><tt>(define-syntax&nbsp;define-constant<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x&nbsp;e)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-syntax&nbsp;x&nbsp;(identifier-syntax&nbsp;t))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;t&nbsp;e))]))</tt>
<p>are equivalent.

<p>
The Revised<sup>6</sup> Report specifies that internal variable definitions be
treated like <tt>letrec*</tt>, while earlier reports required internal
variable definitions to be treated like <tt>letrec</tt>.
By default, <i>Chez&nbsp;Scheme</i> implements the Revised<sup>6</sup> Report semantics for
internal variable definitions, as for all other things, but this behavior
may be overridden via the <tt>internal-defines-as-letrec*</tt> parameter.

<p>
<a name="./binding:s15"></a><span class=formdef><b>thread parameter</b>: <tt>internal-defines-as-letrec*</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When this parameter is set to <tt>#t</tt> (the default), internal variable
definitions are evaluated using <tt>letrec*</tt> semantics.
It may be set to <tt>#f</tt> to revert to the <tt>letrec</tt> semantics
for internal variable definitions, for backward compatibility.


<p>

<h3><a name="g38"></a><a name="./binding:h2"></a>Section 5.2. Multiple-value Definitions</h3>



<p>
<a name="./binding:s16"></a><span class=formdef><b>syntax</b>: <tt>(define-values&nbsp;<i>formals</i>&nbsp;<i>expr</i>)</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A <tt>define-values</tt> form is a definition and can appear anywhere
other definitions can appear.
It is like a <tt>define</tt> form but permits an arbitrary formals list
(like <tt>lambda</tt>) on the left-hand side.
It evaluates <tt><i>expr</i></tt> and binds the variables appearing in <tt><i>formals</i></tt>
to the resulting values, in the same manner as the formal parameters of a
procedure are bound to its arguments.

<p>

<p><tt>(let&nbsp;()<br>

&nbsp;&nbsp;(define-values&nbsp;(x&nbsp;y)&nbsp;(values&nbsp;1&nbsp;2))<br>

&nbsp;&nbsp;(list&nbsp;x&nbsp;y))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2)<br>

(let&nbsp;()<br>

&nbsp;&nbsp;(define-values&nbsp;(x&nbsp;y&nbsp;.&nbsp;z)&nbsp;(values&nbsp;1&nbsp;2&nbsp;3&nbsp;4))<br>

&nbsp;&nbsp;(list&nbsp;x&nbsp;y&nbsp;z))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;(3&nbsp;4))</tt>
<p>A <tt>define-values</tt> form expands into a sequence of definitions, the
first for a hidden temporary bound to a data structure holding the values
returned by <tt><i>expr</i></tt> and the remainder binding each of the formals to
the corresponding value or list of values, extracted from the data
structure via a reference to the temporary.
Because the temporary must be defined before the other variables are
defined, this works for internal <tt>define-values</tt> forms only if
<tt>internal-defines-as-letrec*</tt> is set to the default value
<tt>#t</tt>.


<p>

<h3><a name="g39"></a><a name="./binding:h3"></a>Section 5.3. Recursive Bindings</h3>



<p>
<a name="./binding:s17"></a><span class=formdef><b>syntax</b>: <tt>(rec&nbsp;<i>var</i>&nbsp;<i>expr</i>)</tt></span>
<br>
<b>returns: </b>value of <tt><i>expr</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The syntactic form <tt>rec</tt> creates a <a name="./binding:s18"></a>recursive object from <tt><i>expr</i></tt> by
establishing a binding of <tt><i>var</i></tt> within <tt><i>expr</i></tt> to the value of <tt><i>expr</i></tt>.
In essence, it is a special case of <tt>letrec</tt> for self-recursive objects.

<p>
This form is useful for creating recursive objects (especially procedures)
that do not depend on external variables for the recursion, which are
sometimes undesirable because the external bindings can change.
For example, a recursive procedure defined at top level depends on the value
of the top-level variable given as its name.
If the value of this variable should change, the meaning of the procedure
itself would change.
If the procedure is defined instead with <tt>rec</tt>, its meaning is independent
of the variable to which it is bound.

<p>

<p><tt>(map&nbsp;(rec&nbsp;sum<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;x&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;x&nbsp;(sum&nbsp;(-&nbsp;x&nbsp;1))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(0&nbsp;1&nbsp;3&nbsp;6&nbsp;10&nbsp;15)
<br>
<br>
(define&nbsp;cycle<br>

&nbsp;&nbsp;(rec&nbsp;self<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(lambda&nbsp;()&nbsp;self))))
<br>
<br>
(eq?&nbsp;((car&nbsp;cycle))&nbsp;cycle)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p>The definition below expands <tt>rec</tt> in terms of <tt>letrec</tt>.

<p>

<p><tt>(define-syntax&nbsp;rec<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x&nbsp;e)&nbsp;(letrec&nbsp;((x&nbsp;e))&nbsp;x)]))</tt>
<p>
<h3><a name="g40"></a><a name="./binding:h4"></a>Section 5.4. Fluid Bindings</h3>



<p>
<a name="./binding:s19"></a><span class=formdef><b>syntax</b>: <tt>(fluid-let&nbsp;((<i>var</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the values of the body <tt><i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./binding:s20"></a><a name="./binding:s21"></a>The syntactic form <tt>fluid-let</tt>
provides a way to temporarily assign values to a set of variables.
The new values are in effect only during the evaluation of the
body of the <tt>fluid-let</tt> expression.
The scopes of the variables are not determined by <tt>fluid-let</tt>; as with
<tt>set!</tt>, the variables must be bound at top level or by an enclosing
<tt>lambda</tt> or other binding form.
It is possible, therefore, to control the scope of a variable with
<tt>lambda</tt> or <tt>let</tt> while establishing a temporary
value with <tt>fluid-let</tt>.

<p>
Although it is similar in appearance to <tt>let</tt>, its operation is more
like that of <tt>set!</tt>.
Each <tt><i>var</i></tt> is assigned, as with <tt>set!</tt>, to the value of the
corresponding <tt><i>expr</i></tt> within the body <tt><i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...</tt>.
Should the body
exit normally or by invoking a continuation made outside of the body
(see <tt>call/cc</tt>), the values in effect before the bindings were changed
are restored.
Should control return back to the body by the invocation of a continuation
created within the body, the bindings are changed once again to the values
in effect when the body last exited.

<p>
Fluid bindings are most useful for
maintaining variables that must be shared by a group of procedures.
Upon entry to the group of procedures, the shared variables are fluidly
bound to a new set of initial values so that on exit the original values
are restored automatically.
In this way, the group of procedures itself can be reentrant; it may call
itself directly or indirectly without affecting the values of its shared
variables.

<p>
<a name="./binding:s22"></a>Fluid bindings are similar to
<i>special</i> bindings in Common Lisp&nbsp;[<a class=citation href="./bibliography.html#g181">30</a>], except that
(1) there is a single namespace for both lexical and fluid bindings, and
(2) the scope of a fluidly bound variable is not necessarily global.

<p>

<p><tt>(let&nbsp;([x&nbsp;3])<br>

&nbsp;&nbsp;(+&nbsp;(fluid-let&nbsp;([x&nbsp;5])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;8
<br>
<br>
(let&nbsp;([x&nbsp;'a])<br>

&nbsp;&nbsp;(letrec&nbsp;([f&nbsp;(lambda&nbsp;(y)&nbsp;(cons&nbsp;x&nbsp;y))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(fluid-let&nbsp;([x&nbsp;'b])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;'c))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(b&nbsp;.&nbsp;c)
<br>
<br>
(let&nbsp;([x&nbsp;'a])<br>

&nbsp;&nbsp;(call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fluid-let&nbsp;([x&nbsp;'b])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(letrec&nbsp;([f&nbsp;(lambda&nbsp;(y)&nbsp;(k&nbsp;'*))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;'*)))))<br>

&nbsp;&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;a</tt>
<p><tt>fluid-let</tt> may be defined in terms of <tt>dynamic-wind</tt> as follows.

<p>

<p><tt>(define-syntax&nbsp;fluid-let<a name="defn:fluid-let"></a><br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;()&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;#'(let&nbsp;()&nbsp;b1&nbsp;b2&nbsp;...)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((x&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(andmap&nbsp;identifier?&nbsp;#'(x&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([(y&nbsp;...)&nbsp;(generate-temporaries&nbsp;#'(x&nbsp;...))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(let&nbsp;([y&nbsp;e]&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([swap&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([t&nbsp;x])&nbsp;(set!&nbsp;x&nbsp;y)&nbsp;(set!&nbsp;y&nbsp;t))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dynamic-wind&nbsp;swap&nbsp;(lambda&nbsp;()&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;swap))))])))</tt>
<p>
<h3><a name="g41"></a><a name="./binding:h5"></a>Section 5.5. Top-Level Bindings<a name="SECTBINDINGTOPLEVEL"></a></h3>



<p>
The procedures described in this section allow the direct manipulation
of <a name="./binding:s23"></a>top-level bindings for variables
and keywords.
They are intended primarily to support the definition of interpreters
or compilers for Scheme in Scheme but may be used to access or alter
top-level bindings anywhere within a program whether at top level or not.

<p>
<a name="./binding:s24"></a><span class=formdef><b>procedure</b>: <tt>(define-top-level-value&nbsp;<i>symbol</i>&nbsp;<i>obj</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(define-top-level-value&nbsp;<i>symbol</i>&nbsp;<i>obj</i>&nbsp;<i>env</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>define-top-level-value</tt> is used to establish a binding
for the variable named by <tt><i>symbol</i></tt> to the value <tt><i>obj</i></tt>
in the environment <tt><i>env</i></tt>.
If <tt><i>env</i></tt> is not provided, it defaults to the
value of <tt>interaction-environment</tt>, i.e., the
top-level evaluation environment
(Section&nbsp;<a href="./system.html#g114">12.3</a>).

<p>
An exception is raised with condition type <tt>&amp;assertion</tt> if
<tt><i>env</i></tt> is not mutable.

<p>
A call to <tt>define-top-level-value</tt> is similar to a top-level
<a name="./binding:s25"></a><tt>define</tt> form, except that a call to
<tt>define-top-level-value</tt> need not occur at top-level and
the variable for which the binding is to be established can be
determined at run time, as can the environment.

<p>

<p><tt>(begin<br>

&nbsp;&nbsp;(define-top-level-value&nbsp;'xyz&nbsp;"hi")<br>

&nbsp;&nbsp;xyz)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"hi"
<br>
<br>
(let&nbsp;([var&nbsp;'xyz])<br>

&nbsp;&nbsp;(define-top-level-value&nbsp;var&nbsp;"mom")<br>

&nbsp;&nbsp;(list&nbsp;var&nbsp;xyz))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(xyz&nbsp;"mom")</tt>
<p><a name="./binding:s26"></a><span class=formdef><b>procedure</b>: <tt>(set-top-level-value!&nbsp;<i>symbol</i>&nbsp;<i>obj</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-top-level-value!&nbsp;<i>symbol</i>&nbsp;<i>obj</i>&nbsp;<i>env</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./binding:s27"></a><tt>set-top-level-value!</tt> assigns 
the variable named by <tt><i>symbol</i></tt> to the value <tt><i>obj</i></tt>
in the environment <tt><i>env</i></tt>.
If <tt><i>env</i></tt> is not provided, it defaults to the
value of <tt>interaction-environment</tt>, i.e., the
top-level evaluation environment
(Section&nbsp;<a href="./system.html#g114">12.3</a>).

<p>
An exception is raised with condition type <tt>&amp;assertion</tt> if the
identifier named by <tt><i>symbol</i></tt> is not defined as a variable in <tt><i>env</i></tt>
or if the variable or environment is not mutable.

<p>
<tt>set-top-level-value!</tt> is similar to
<a name="./binding:s28"></a><tt>set!</tt> when <tt>set!</tt>
is used on top-level variables except that the variable to be assigned
can be determined at run time, as can the environment.

<p>

<p><tt>(let&nbsp;([v&nbsp;(let&nbsp;([cons&nbsp;list])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-top-level-value!&nbsp;'cons&nbsp;+)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;3&nbsp;4))])<br>

&nbsp;&nbsp;(list&nbsp;v&nbsp;(cons&nbsp;3&nbsp;4)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;((3&nbsp;4)&nbsp;7)</tt>
<p><a name="./binding:s29"></a><span class=formdef><b>procedure</b>: <tt>(top-level-value&nbsp;<i>symbol</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(top-level-value&nbsp;<i>symbol</i>&nbsp;<i>env</i>)</tt></span>
<br>
<b>returns: </b>the top-level value of the variable named by <tt><i>symbol</i></tt> in <tt><i>env</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>env</i></tt> is not provided, it defaults to the
value of <tt>interaction-environment</tt>, i.e., the
top-level evaluation environment
(Section&nbsp;<a href="./system.html#g114">12.3</a>).

<p>
An exception is raised with condition type <tt>&amp;assertion</tt> if the
identifier named by <tt><i>symbol</i></tt> is not defined as a variable in <tt><i>env</i></tt>.

<p>
<tt>top-level-value</tt> is similar to a top-level variable reference
except that the variable to be referenced can be determined at run time,
as can the environment.

<p>

<p><tt>(let&nbsp;([cons&nbsp;+])<br>

&nbsp;&nbsp;(list&nbsp;(cons&nbsp;3&nbsp;4)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((top-level-value&nbsp;'cons)&nbsp;3&nbsp;4)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(7&nbsp;(3&nbsp;.&nbsp;4))
<br>
<br>
(define&nbsp;e&nbsp;(copy-environment&nbsp;(scheme-environment)))<br>

(define-top-level-value&nbsp;'pi&nbsp;3.14&nbsp;e)<br>

(top-level-value&nbsp;'pi&nbsp;e)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3.14<br>

(set-top-level-value!&nbsp;'pi&nbsp;3.1416&nbsp;e)<br>

(top-level-value&nbsp;'pi&nbsp;e)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3.1416</tt>
<p><a name="./binding:s30"></a><span class=formdef><b>procedure</b>: <tt>(top-level-bound?&nbsp;<i>symbol</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(top-level-bound?&nbsp;<i>symbol</i>&nbsp;<i>env</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>symbol</i></tt> is defined as a variable in <tt><i>env</i></tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>env</i></tt> is not provided, it defaults to the
value of <tt>interaction-environment</tt>, i.e., the
top-level evaluation environment
(Section&nbsp;<a href="./system.html#g114">12.3</a>).

<p>
This predicate is useful in an interpreter to check for the existence of
a top-level binding before requesting the value with
<tt>top-level-value</tt>.

<p>

<p><tt>(top-level-bound?&nbsp;'xyz)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(begin<br>

&nbsp;&nbsp;(define-top-level-value&nbsp;'xyz&nbsp;3)<br>

&nbsp;&nbsp;(top-level-bound?&nbsp;'xyz))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(define&nbsp;e&nbsp;(copy-environment&nbsp;(interaction-environment)))<br>

(define-top-level-value&nbsp;'pi&nbsp;3.14&nbsp;e)<br>

(top-level-bound?&nbsp;'pi)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(top-level-bound?&nbsp;'pi&nbsp;e)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./binding:s31"></a><span class=formdef><b>procedure</b>: <tt>(top-level-mutable?&nbsp;<i>symbol</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(top-level-mutable?&nbsp;<i>symbol</i>&nbsp;<i>env</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>symbol</i></tt> is mutable in <tt><i>env</i></tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>env</i></tt> is not provided, it defaults to the
value of <tt>interaction-environment</tt>, i.e., the
top-level evaluation environment
(Section&nbsp;<a href="./system.html#g114">12.3</a>).

<p>
This predicate is useful in an interpreter to check whether a variable
can be assigned before assigning it with
<tt>set-top-level-value!</tt>.

<p>

<p><tt>(define&nbsp;xyz&nbsp;3)<br>

(top-level-mutable?&nbsp;'xyz)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(set-top-level-value!&nbsp;'xyz&nbsp;4)<br>

(top-level-value&nbsp;'xyz)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4
<br>
<br>
(define&nbsp;e&nbsp;(copy-environment&nbsp;(interaction-environment)&nbsp;#f))<br>

(top-level-mutable?&nbsp;'xyz&nbsp;e)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(set-top-level-value!&nbsp;'xyz&nbsp;e)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;xyz&nbsp;is&nbsp;immutable</i></tt>
<p><a name="./binding:s32"></a><span class=formdef><b>procedure</b>: <tt>(define-top-level-syntax&nbsp;<i>symbol</i>&nbsp;<i>obj</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(define-top-level-syntax&nbsp;<i>symbol</i>&nbsp;<i>obj</i>&nbsp;<i>env</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>define-top-level-syntax</tt> is used to establish a top-level binding
for the identifier named by <tt><i>symbol</i></tt> to the value of <tt><i>obj</i></tt>
in the environment <tt><i>env</i></tt>.
The value must be a procedure, the result of a call to
<tt>make-variable-transformer</tt>, or the result of a call to
<tt>top-level-syntax</tt>.
If <tt><i>env</i></tt> is not provided, it defaults to the
value of <tt>interaction-environment</tt>, i.e., the
top-level evaluation environment
(Section&nbsp;<a href="./system.html#g114">12.3</a>).

<p>
An exception is raised with condition type <tt>&amp;assertion</tt> if
<tt><i>env</i></tt> is not mutable.

<p>
A call to <tt>define-top-level-syntax</tt> is similar to a top-level
<a name="./binding:s33"></a><tt>define-syntax</tt> form, except that a call to
<tt>define-top-level-syntax</tt> need not occur at top-level and
the identifier for which the binding is to be established can be
determined at run time, as can the environment.

<p>

<p><tt>(define-top-level-syntax&nbsp;'let1<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x&nbsp;e&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;(let&nbsp;([x&nbsp;e])&nbsp;b1&nbsp;b2&nbsp;...)]))<br>

(let1&nbsp;a&nbsp;3&nbsp;(+&nbsp;a&nbsp;1))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4</tt>
<p><tt>define-top-level-syntax</tt> can also be used to attach
to an identifier arbitrary compile-time bindings obtained 
via <tt>top-level-syntax</tt>.

<p>
<a name="./binding:s34"></a><span class=formdef><b>procedure</b>: <tt>(top-level-syntax&nbsp;<i>symbol</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(top-level-syntax&nbsp;<i>symbol</i>&nbsp;<i>env</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>top-level-syntax</tt> is used to retrieve the transformer, compile-time
value, or other compile-time binding to which
the identifier named by <tt><i>symbol</i></tt> is bound in the environment <tt><i>env</i></tt>.
If <tt><i>env</i></tt> is not provided, it defaults to the
value of <tt>interaction-environment</tt>, i.e., the
top-level evaluation environment
(Section&nbsp;<a href="./system.html#g114">12.3</a>).
All identifiers bound in an environment have compile-time bindings, including
variables.

<p>
An exception is raised with condition type <tt>&amp;assertion</tt> if the
identifier named by <tt><i>symbol</i></tt> is not defined as a keyword in <tt><i>env</i></tt>.

<p>

<p><tt>(define-top-level-syntax&nbsp;'also-let&nbsp;(top-level-syntax&nbsp;'let))<br>

(also-let&nbsp;([x&nbsp;3]&nbsp;[y&nbsp;4])&nbsp;(+&nbsp;x&nbsp;y))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;7
<br>
<br>
(define&nbsp;foo&nbsp;17)<br>

(define-top-level-syntax&nbsp;'also-foo&nbsp;(top-level-syntax&nbsp;'foo))<br>

also-foo&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;17<br>

(set!&nbsp;also-foo&nbsp;23)<br>

also-foo&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;23<br>

foo&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;23</tt>
<p>The effect of the last example can be had more clearly with <tt>alias</tt>:

<p>

<p><tt>(define&nbsp;foo&nbsp;17)<br>

(alias&nbsp;also-foo&nbsp;foo)<br>

also-foo&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;17<br>

(set!&nbsp;also-foo&nbsp;23)<br>

also-foo&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;23<br>

foo&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;23</tt>
<p><a name="./binding:s35"></a><span class=formdef><b>procedure</b>: <tt>(top-level-syntax?&nbsp;<i>symbol</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(top-level-syntax?&nbsp;<i>symbol</i>&nbsp;<i>env</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>symbol</i></tt> is bound as a keyword in <tt><i>env</i></tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>env</i></tt> is not provided, it defaults to the
value of <tt>interaction-environment</tt>, i.e., the
top-level evaluation environment
(Section&nbsp;<a href="./system.html#g114">12.3</a>).

<p>
All identifiers bound in an environment have compile-time bindings, including
variables, so this predicate amounts to a bound check, but is more general
than <tt>top-level-bound?</tt>, which returns true only for bound variables.

<p>

<p><tt>(define&nbsp;xyz&nbsp;'hello)<br>

(top-level-syntax?&nbsp;'cons)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(top-level-syntax?&nbsp;'lambda)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(top-level-syntax?&nbsp;'hello)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(top-level-syntax?&nbsp;'cons&nbsp;(scheme-environment))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(top-level-syntax?&nbsp;'lambda&nbsp;(scheme-environment))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(top-level-syntax?&nbsp;'hello&nbsp;(scheme-environment))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>



<hr class=copyright align=left>
<p>
<a class=plain href="index.html">Chez Scheme Version 9 User's Guide</a><br>
Copyright &copy; 2022 Cisco Systems, Inc.<br>
Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License Version 2.0</a>
(<a class=plain href="canned/copyright.html">full copyright notice.</a>).</br>
Revised April 2022 for Chez Scheme Version 9.5.8<br>
<a class=plain href="canned/about.html">about this book</a>
</tr></table>
</body>
</html>
