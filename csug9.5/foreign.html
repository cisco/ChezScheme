<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Foreign Interface</title>
<link href="csug.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g22"></a>
<a name="./foreign:h0"></a>

<h1>Chapter 4. Foreign Interface<a name="CHPTFOREIGN"></a></h1>






<p>
<i>Chez&nbsp;Scheme</i> provides two ways to interact with "foreign" code,
i.e., code written in other languages.
The first is via subprocess creation and communication, which is
discussed in the Section&nbsp;<a href="./foreign.html#g23">4.1</a>.
The second is via static or dynamic loading and invocation from Scheme
of procedures written in <a name="./foreign:s0"></a>C and
invocation from C of procedures written in Scheme.
These mechanisms are discussed in Sections&nbsp;<a href="./foreign.html#g28">4.2</a>
through&nbsp;<a href="./foreign.html#g30">4.4</a>.

<p>
The method for static loading of C object code is dependent upon which
machine you are running; see the installation instructions distributed
with <i>Chez&nbsp;Scheme</i>.


<p>

<h3><a name="g23"></a><a name="./foreign:h1"></a>Section 4.1. Subprocess Communication<a name="SECTFOREIGNSUBPROCESS"></a></h3>



<p>
Two procedures, <a name="./foreign:s1"></a><tt>system</tt> and <a name="./foreign:s2"></a><tt>process</tt>, are used to create
<a name="./foreign:s3"></a>subprocesses.
Both procedures accept a single string argument and create a
subprocess to execute the shell command contained in the string.
The <tt>system</tt> procedure waits for the process to exit before
returning, however,
while the <tt>process</tt> procedure returns immediately without
waiting for the process to exit.
The standard input and output files of a subprocess created by <tt>system</tt> 
may be used to communicate with the user's console.
The standard
input and output files of a subprocess created by <tt>process</tt> may be used
to communicate with the Scheme process.

<p>
<a name="./foreign:s4"></a><span class=formdef><b>procedure</b>: <tt>(system&nbsp;<i>command</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>command</i></tt> must be a string.

<p>
The <tt>system</tt> procedure creates a subprocess to perform the operation
specified by <tt><i>command</i></tt>.
The subprocess may communicate with the user through the same console
input and console output files used by the Scheme process.
After creating the subprocess, <tt>system</tt> waits for the process to exit
before returning.

<p>
When the subprocess exits, <tt>system</tt> returns the exit code for the
subprocess, unless (on Unix-based systems) a signal caused the subprocess
to terminate, in which case <tt>system</tt> returns the negation of the
signal that caused the termination, e.g., -1 for <tt>SIGHUP</tt>.


<p>
<a name="./foreign:s5"></a><span class=formdef><b>procedure</b>: <tt>(open-process-ports&nbsp;<i>command</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(open-process-ports&nbsp;<i>command</i>&nbsp;<i>b-mode</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(open-process-ports&nbsp;<i>command</i>&nbsp;<i>b-mode</i>&nbsp;<i>?transcoder</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>command</i></tt> must be a string.
If <tt><i>?transcoder</i></tt> is present and not <tt>#f</tt>, it must be a
transcoder, and this procedure creates textual ports, each of whose
transcoder is <tt><i>?transcoder</i></tt>.
Otherwise, this procedure returns binary ports.
<tt><i>b-mode</i></tt> specifies the buffer mode used by each of the ports
returned by this procedure and defaults to <tt>block</tt>.
Buffer modes are described in Section&nbsp;<a href="http://scheme.com/tspl4/./io.html#g123">7.2</a> of
<i>The Scheme Programming Language, 4th Edition</i>.

<p>
<tt>open-process-ports</tt> creates a subprocess to perform the operation
specified by <tt><i>command</i></tt>.
Unlike <tt>system</tt>, <tt>process</tt> returns immediately after creating the
subprocess, i.e., without waiting for the subprocess to terminate.
It returns four values:

<p>
<ol>
<a name="g24"></a><li><tt><i>to-stdin</i></tt> is an output port to which Scheme can send output to the
subprocess through the subprocess's standard input file.

<p>
<a name="g25"></a><li><tt><i>from-stdout</i></tt> is an input port from which Scheme can read input from
the subprocess through the subprocess's standard output file.

<p>
<a name="g26"></a><li><tt><i>from-stderr</i></tt> is an input port from which Scheme can read input from
the subprocess through the subprocess's standard error file.

<p>
<a name="g27"></a><li><tt><i>process-id</i></tt> is an integer identifying the created subprocess
provided by the host operating system.
</ol>
<p>

<p>
If the process exits or closes its standard output file descriptor, any
procedure that reads input from <tt><i>from-stdout</i></tt> will return an
end-of-file object.
Similarly, if the process exits or closes its standard error file
descriptor, any procedure that reads input from <tt><i>from-stderr</i></tt> will
return an end-of-file object.

<p>
The predicate <a name="./foreign:s6"></a><tt>input-port-ready?</tt>
may be used to detect whether input has been sent by the subprocess to
Scheme.

<p>
It is sometimes necessary to force output to be sent immediately
to the subprocess by invoking <tt>flush-output-port</tt> on
<tt><i>to-stdin</i></tt>, since <i>Chez&nbsp;Scheme</i> buffers the output for efficiency.

<p>
On UNIX systems, the <tt><i>process-id</i></tt> is the process identifier
for the shell created to execute <tt><i>command</i></tt>.
If <tt><i>command</i></tt> is used to invoke an executable file rather than
a shell command, it may be useful to prepend <tt><i>command</i></tt> with
the string <tt>"exec&nbsp;"</tt>, which causes the shell to load and execute
the named executable directly, without forking a new
process---the shell equivalent of a tail call.
This will reduce by one the number of subprocesses created and
cause <tt><i>process-id</i></tt> to reflect the process identifier for the 
executable once the shell has transferred control.


<p>
<a name="./foreign:s7"></a><span class=formdef><b>procedure</b>: <tt>(process&nbsp;<i>command</i>)</tt></span>
<br>
<b>returns: </b>see explanation
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>command</i></tt> must be a string.

<p>
<tt>process</tt> is similar to <tt>open-process-ports</tt>, but less
general.
It does not return a port from which the subproces's standard error output
can be read, and it always creates textual ports.
It returns a list of three values rather than the four separate values
of <tt>open-process-ports</tt>.
The returned list contains, in order: <tt><i>from-stdout</i></tt>,
<tt><i>to-stdin</i></tt>, and <tt><i>process-id</i></tt>, which correspond to the second,
first, and fourth return values of <tt>open-process-ports</tt>.


<p>


<p>

<h3><a name="g28"></a><a name="./foreign:h2"></a>Section 4.2. Calling out of Scheme<a name="SECTFOREIGNPROCEDURES"></a></h3>



<p>
<i>Chez&nbsp;Scheme</i>'s <a name="./foreign:s8"></a>foreign-procedure interface allows a Scheme program
to invoke
procedures written in <a name="./foreign:s9"></a>C or in languages that obey the same
calling conventions as C.
Two steps are necessary before foreign procedures can be invoked from Scheme.
First, the foreign procedure must be compiled and loaded,
either statically or dynamically,
as described in Section&nbsp;<a href="./foreign.html#g32">4.6</a>.
Then, access to the foreign procedure must be established in Scheme,
as described in this section.
Once access to a foreign procedure has been established it may be called as an
ordinary Scheme procedure.

<p>
Since foreign procedures operate independently of the Scheme memory management
and exception handling system, great care must be taken when using them.
Although the foreign-procedure interface provides
type checking (at optimize levels less than 3) and
type conversion, the programmer must ensure that
the sharing of data between Scheme and foreign procedures is done safely by
specifying proper argument and result types.

<p>
Scheme-callable wrappers for foreign procedures can also be created via
<tt>ftype-ref</tt> and function ftypes (Section&nbsp;<a href="./foreign.html#g31">4.5</a>).


<p>
<a name="./foreign:s10"></a><span class=formdef><b>syntax</b>: <tt>(foreign-procedure&nbsp;<i>conv</i>&nbsp;...&nbsp;<i>entry-exp</i>&nbsp;(<i>param-type</i>&nbsp;...)&nbsp;<i>res-type</i>)</tt></span>
<br>
<b>returns: </b>a procedure
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>entry-exp</i></tt> must evaluate to a string representing a valid foreign
procedure entry point or an integer representing the address of the
foreign procedure.
The <tt><i>param-types</i></tt> and <tt><i>res-type</i></tt> must be symbols or
structured forms as described below.
When a <tt>foreign-procedure</tt> expression is evaluated, a Scheme procedure is
created that will invoke the foreign procedure specified by <tt><i>entry-exp</i></tt>.
When the procedure is called each argument is checked and converted according to
the specified <tt><i>param-type</i></tt> before it is passed to the foreign procedure.
The result of the foreign procedure call is converted as specified
by the <tt><i>res-type</i></tt>.
Multiple procedures may be created for the same <a name="./foreign:s11"></a>foreign entry.

<p>
<a name="page:conv-description"></a>Each <tt><i>conv</i></tt> adjusts specifies the calling convention to be used.
A <tt>#f</tt> is allowed as <tt><i>conv</i></tt> to indicate the default calling convention
on the target machine (so the <tt>#f</tt> has no effect).
Three other conventions are currently supported under
Windows: <tt>__stdcall</tt>, <tt>__cdecl</tt>, and <tt>__com</tt> (32-bit only).
Since <tt>__cdecl</tt> is the default, specifying <tt>__cdecl</tt> is
equivalent to specifying <tt>#f</tt> or no convention.
Finally, <tt><i>conv</i></tt> can be <tt>__collect_safe</tt> to indicate that garbage
collection is allowed concurrent to a call of the foreign procedure.

<p>
Use <tt>__stdcall</tt> to access most Windows API procedures.
Use <tt>__cdecl</tt> for Windows API varargs procedures,
for C library procedures, and for most other procedures.
Use <tt>__com</tt> to invoke COM interface methods; COM uses the
<tt>__stdcall</tt> convention but additionally performs the indirections
necessary to obtain the correct method from a COM instance.
The address of the COM instance must be passed as the first argument,
which should normally be declared as <tt>iptr</tt>.
For the <tt>__com</tt> interface only, <tt><i>entry-exp</i></tt> must evaluate
to the byte offset of the method in the COM vtable.
For example,

<p>

<p><tt>(foreign-procedure&nbsp;__com&nbsp;12&nbsp;(iptr&nbsp;double-float)&nbsp;integer-32)</tt>
<p>creates an interface to a COM method at offset 12 in the vtable
encapsulated within the COM instance passed as the first argument,
with the second argument being a double float and the return
value being an integer.

<p>
Use <tt>__collect_safe</tt> to declare that garbage collection is
allowed concurrent to the foreign procedure. The
<tt>__collect_safe</tt> declaration allows concurrent collection by
deactivating the current thread (see <tt>fork-thread</tt>) when the
foreign procedure is called, and the thread is activated again when
the foreign procedure returns. The <tt>__collect_safe</tt> declaration
is useful, for example, when calling a blocking I/O call to allow
other Scheme threads to run normally. Refrain from passing collectable memory to a
<tt>__collect_safe</tt> foreign procedure, or use <tt>lock-object</tt>
to lock the memory in place; see also <tt>Sdeactivate_thread</tt>. The
<tt>__collect_safe</tt> declaration has no effect on a non-threaded
version of the system.

<p>
For example, calling the C <tt>sleep</tt> function with the default
convention will block other Scheme threads from performing a garbage
collection, but adding the <tt>__collect_safe</tt> declaration avoids that
problem:

<p>

<p><tt>(define&nbsp;c-sleep<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;__collect_safe&nbsp;"sleep"&nbsp;(unsigned)&nbsp;unsigned))<br>

(c-sleep&nbsp;10)&nbsp;<i>;&nbsp;sleeps&nbsp;for&nbsp;10&nbsp;seconds&nbsp;without&nbsp;blocking&nbsp;other&nbsp;threads</i></tt>
<p>If a foreign procedure that is called with <tt>__collect_safe</tt> can
invoke callables, then each callable should also be declared with
<tt>__collect_safe</tt> so that the callable reactivates the thread.


<p>
Complete type checking and conversion is performed on the parameters
to a foreign procedure.
The types
<a name="./foreign:s12"></a><tt>scheme-object</tt>,
<a name="./foreign:s13"></a><tt>string</tt>,
<a name="./foreign:s14"></a><tt>wstring</tt>,
<a name="./foreign:s15"></a><tt>u8*</tt>,
<a name="./foreign:s16"></a><tt>u16*</tt>,
<a name="./foreign:s17"></a><tt>u32*</tt>,
<a name="./foreign:s18"></a><tt>utf-8</tt>,
<a name="./foreign:s19"></a><tt>utf-16le</tt>,
<a name="./foreign:s20"></a><tt>utf-16be</tt>,
<a name="./foreign:s21"></a><tt>utf-32le</tt>,
and
<a name="./foreign:s22"></a><tt>utf-32be</tt>,
must be used with caution, however, since they allow allocated
Scheme objects to be used in places the Scheme memory management system
cannot control. No problems will arise as long as such objects are not
retained in foreign variables or data structures while Scheme code is running,
and as long as they are not passed as arguments to a <tt>__collect_safe</tt> procedure,
since garbage collection can occur only while Scheme code is running
or when concurrent garbage collection is enabled.
Other parameter types are converted to equivalent foreign
representations and consequently they can be retained indefinitely in
foreign variables and data structures.

<p>
For argument types <tt>string</tt>, <tt>wstring</tt>,
<a name="./foreign:s23"></a><tt>utf-8</tt>,
<a name="./foreign:s24"></a><tt>utf-16le</tt>,
<a name="./foreign:s25"></a><tt>utf-16be</tt>,
<a name="./foreign:s26"></a><tt>utf-32le</tt>, and
<a name="./foreign:s27"></a><tt>utf-32be</tt>, an argument is converted
to a fresh object that is passed to the foreign procedure. Since the
fresh object is not accessible for locking before the call, it can
never be treated correctly for a <tt>__collect_safe</tt> foreign
procedure, so those types are disallowed as argument types for
a <tt>__collect_safe</tt> foreign procedure. For analogous reasons,
those types are disallowed as the result of a <tt>__collect_safe</tt>
foreign callable.

<p>
Following are the valid parameter types:

<p>
<p><tt>integer-8</tt>: <a name="./foreign:s28"></a>Exact integers from -2<sup>7</sup> through
2<sup>8</sup> - 1 are valid.
Integers in the range 2<sup>7</sup> through 2<sup>8</sup> - 1 are treated as
two's complement representations of negative numbers, e.g.,
<tt>#xff</tt> is treated as -1.
The argument is passed to C as an integer of the appropriate size
(usually <tt>signed&nbsp;char</tt>).

<p>
<p><tt>unsigned-8</tt>: <a name="./foreign:s29"></a>Exact integers from -2<sup>7</sup> to
2<sup>8</sup> - 1 are valid.
Integers in the range -2<sup>7</sup> through -1 are treated as the
positive equivalents of their two's complement representation,
e.g., -1 is treated as <tt>#xff</tt>.
The argument is passed to C as an unsigned integer of the
appropriate size (usually <tt>unsigned&nbsp;char</tt>).

<p>
<p><tt>integer-16</tt>: <a name="./foreign:s30"></a>Exact integers from -2<sup>15</sup> through
2<sup>16</sup> - 1 are valid.
Integers in the range 2<sup>15</sup> through 2<sup>16</sup> - 1 are treated as
two's complement representations of negative numbers, e.g.,
<tt>#xffff</tt> is treated as -1.
The argument is passed to C as an integer of the appropriate size
(usually <tt>short</tt>).

<p>
<p><tt>unsigned-16</tt>: <a name="./foreign:s31"></a>Exact integers from -2<sup>15</sup> to
2<sup>16</sup> - 1 are valid.
Integers in the range -2<sup>15</sup> through -1 are treated as the
positive equivalents of their two's complement representation,
e.g., -1 is treated as <tt>#xffff</tt>.
The argument is passed to C as an unsigned integer of the
appropriate size (usually <tt>unsigned&nbsp;short</tt>).

<p>
<p><tt>integer-32</tt>: <a name="./foreign:s32"></a>Exact integers from -2<sup>31</sup> through
2<sup>32</sup> - 1 are valid.
Integers in the range 2<sup>31</sup> through 2<sup>32</sup> - 1 are treated as
two's complement representations of negative numbers, e.g.,
<tt>#xffffffff</tt> is treated as -1.
The argument is passed to C as an integer of the appropriate size
(usually <tt>int</tt>).

<p>
<p><tt>unsigned-32</tt>: <a name="./foreign:s33"></a>Exact integers from -2<sup>31</sup> to
2<sup>32</sup> - 1 are valid.
Integers in the range -2<sup>31</sup> through -1 are treated as the
positive equivalents of their two's complement representation,
e.g., -1 is treated as <tt>#xffffffff</tt>.
The argument is passed to C as an unsigned integer of the
appropriate size (usually <tt>unsigned&nbsp;int</tt>).

<p>
<p><tt>integer-64</tt>: <a name="./foreign:s34"></a>Exact integers from -2<sup>63</sup> through
2<sup>64</sup> - 1 are valid.
Integers in the range 2<sup>63</sup> through 2<sup>64</sup> - 1 are treated as
two's complement representations of negative numbers.
The argument is passed to C as an integer of the appropriate
size (usually <tt>long&nbsp;long</tt> or, on many 64-bit platforms,
<tt>long</tt>).

<p>
<p><tt>unsigned-64</tt>: <a name="./foreign:s35"></a>Exact integers from -2<sup>63</sup> through
2<sup>64</sup> - 1 are valid.
Integers in the range -2<sup>63</sup> through -1 are treated as the
positive equivalents of their two's complement representation,
The argument is passed to C as an integer of the appropriate
size (usually <tt>unsigned&nbsp;long&nbsp;long</tt> or, on many 64-bit
platforms, <tt>long</tt>).

<p>
<p><tt>double-float</tt>: <a name="./foreign:s36"></a>Only Scheme flonums are valid---other
Scheme numeric types are not automatically converted.
The argument is passed to C as a double float.

<p>
<p><tt>single-float</tt>: <a name="./foreign:s37"></a>Only Scheme flonums are valid---other
Scheme numeric types are not automatically converted.
The argument is passed to C as a single float.
Since <i>Chez&nbsp;Scheme</i> represents flonums in double-float format, the
parameter is first converted into single-float format.

<p>
<p><tt>short</tt>: <a name="./foreign:s38"></a>This type is an alias for the appropriate
fixed-size type above, depending on the size of a C <tt>short</tt>.

<p>
<p><tt>unsigned-short</tt>: <a name="./foreign:s39"></a>This type is an alias for the appropriate
fixed-size type above, depending on the size of a C <tt>unsigned&nbsp;short</tt>.

<p>
<p><tt>int</tt>: <a name="./foreign:s40"></a>This type is an alias for the appropriate
fixed-size type above, depending on the size of a C <tt>int</tt>.

<p>
<p><tt>unsigned</tt>: <a name="./foreign:s41"></a>This type is an alias for the appropriate
fixed-size type above, depending on the size of a C <tt>unsigned</tt>.

<p>
<p><tt>unsigned-int</tt>: <a name="./foreign:s42"></a>This type is an alias <tt>unsigned</tt>.
fixed-size type above, depending on the size of a C <tt>unsigned</tt>.

<p>
<p><tt>long</tt>: <a name="./foreign:s43"></a>This type is an alias for the appropriate
fixed-size type above, depending on the size of a C <tt>long</tt>.

<p>
<p><tt>unsigned-long</tt>: <a name="./foreign:s44"></a>This type is an alias for the appropriate
fixed-size type above, depending on the size of a C <tt>unsigned&nbsp;long</tt>.

<p>
<p><tt>long-long</tt>: <a name="./foreign:s45"></a>This type is an alias for the appropriate
fixed-size type above, depending on the size of the nonstandard C type
<tt>long&nbsp;long</tt>.

<p>
<p><tt>unsigned-long-long</tt>: <a name="./foreign:s46"></a>This type is an alias for the appropriate
fixed-size type above, depending on the size of the nonstandard C type
<tt>unsigned&nbsp;long&nbsp;long</tt>.

<p>
<p><tt>ptrdiff_t</tt>: <a name="./foreign:s47"></a>This type is an alias for the appropriate
fixed-size type above, depending on its definition in the host machine's
<tt>stddef.h</tt> include file.

<p>
<p><tt>size_t</tt>: <a name="./foreign:s48"></a>This type is an alias for the appropriate unsigned
fixed-size type above, depending on its definition in the host machine's
<tt>stddef.h</tt> include file.

<p>
<p><tt>ssize_t</tt>: <a name="./foreign:s49"></a>This type is an alias for the appropriate signed
fixed-size type above, depending on its definition in the host machine's
<tt>stddef.h</tt> include file.

<p>
<p><tt>iptr</tt>: <a name="./foreign:s50"></a>This type is an alias for the appropriate
fixed-size type above, depending on the size of a C pointer.

<p>
<p><tt>uptr</tt>: <a name="./foreign:s51"></a>This type is an alias for the appropriate
(unsigned) fixed-size type above, depending on the size of a C pointer.

<p>
<p><tt>void*</tt>: <a name="./foreign:s52"></a>This type is an alias for <tt>uptr</tt>.

<p>
<p><tt>fixnum</tt>: <a name="./foreign:s53"></a>This type is equivalent to <tt>iptr</tt>,
except only values in the fixnum range are valid.
Transmission of fixnums is slightly faster than transmission of
<tt>iptr</tt> values, but the fixnum range is smaller, so some
<tt>iptr</tt> values do not have a fixnum representation.

<p>
<p><tt>boolean</tt>: <a name="./foreign:s54"></a>Any Scheme object may be passed as a boolean.
<tt>#f</tt> is converted to 0; all other objects are converted to 1.
The argument is passed to C as an <tt>int</tt>.

<p>
<p><tt>char</tt>: <a name="./foreign:s55"></a>Only Scheme characters with Unicode scalar values
in the range 0 through 255 are valid <tt>char</tt> parameters.
The character is converted to its Unicode scalar value, as with
<tt>char-&gt;integer</tt>, and passed to C as an <tt>unsigned&nbsp;char</tt>.

<p>
<p><tt>wchar_t</tt>: <a name="./foreign:s56"></a>Only Scheme characters are valid <tt>wchar_t</tt> parameters.
Under Windows and any other system where <tt>wchar_t</tt> holds only
16-bit values rather than full Unicode scalar values, only characters with
16-bit Unicode scalar values are valid.
On systems where <tt>wchar_t</tt> is a full 32-bit value, any Scheme
character is valid.
The character is converted to its Unicode scalar value, as with
<tt>char-&gt;integer</tt>, and passed to C as a <tt>wchar_t</tt>.

<p>
<p><tt>wchar</tt>: <a name="./foreign:s57"></a>This type is an alias for <tt>wchar_t</tt>.

<p>
<p><tt>double</tt>: <a name="./foreign:s58"></a>This type is an alias for <tt>double-float</tt>.

<p>
<p><tt>float</tt>: <a name="./foreign:s59"></a>This type is an alias for <tt>single-float</tt>.

<p>
<p><tt>scheme-object</tt>: <a name="./foreign:s60"></a>The argument is passed directly to the
foreign procedure; no conversion or type checking is performed.
This form of parameter passing should be used with discretion.
Scheme objects should not be preserved in foreign variables or data structures
since the memory management system may relocate them between foreign procedure
calls.

<p>
<p><tt>ptr</tt>: <a name="./foreign:s61"></a>This type is an alias for <tt>scheme-object</tt>.

<p>
<p><tt>u8*</tt>: <a name="./foreign:s62"></a>The argument must be a Scheme bytevector or
<tt>#f</tt>.
For <tt>#f</tt>, the null pointer (0) is passed to the foreign procedure.
For a bytevector, a pointer to the first byte of the bytevector's data
is passed.
If the C routine to which the data is passed requires the input to be
null-terminated, a null (0) byte must be included explicitly in the
bytevector.
The bytevector should not be retained in foreign variables or data
structures, since the memory management system may relocate or discard
them between foreign procedure calls, and use their storage for some
other purpose.

<p>
<p><tt>u16*</tt>: <a name="./foreign:s63"></a>Arguments of this type are treated just like
arguments of type <tt>u8*</tt>.
If the C routine to which the data is passed requires the input to be
null-terminated, two null (0) bytes must be included explicitly in the
bytevector, aligned on a 16-bit boundary.

<p>
<p><tt>u32*</tt>: <a name="./foreign:s64"></a>Arguments of this type are treated just like
arguments of type <tt>u8*</tt>.
If the C routine to which the data is passed requires the input to be
null-terminated, four null (0) bytes must be included explicitly in the
bytevector, aligned on a 32-bit boundary.

<p>
<p><tt>utf-8</tt>: <a name="./foreign:s65"></a>The argument must be a Scheme string or
<tt>#f</tt>.
For <tt>#f</tt>, the null pointer (0) is passed to the foreign procedure.
A string is converted into a bytevector, as if via <tt>string-&gt;utf8</tt>,
with an added null byte, and the address of the first byte of the
bytevector is passed to C.
The bytevector should not be retained in foreign variables or data
structures, since the memory management system may relocate or discard
them between foreign procedure calls and use their storage for some
other purpose. The <tt>utf-8</tt> argument type is not allowed for a
<tt>__collect_safe</tt> foreign procedure.

<p>
<p><tt>utf-16le</tt>: <a name="./foreign:s66"></a>Arguments of this type are treated like arguments
of type <tt>utf-8</tt>, except they are converted as if via
<tt>string-&gt;utf16</tt> with endianness <tt>little</tt>, and they are
extended by two null bytes rather than one.

<p>
<p><tt>utf-16be</tt>: <a name="./foreign:s67"></a>Arguments of this type are treated like arguments
of type <tt>utf-8</tt>, except they are converted as if via
<tt>string-&gt;utf16</tt> with endianness <tt>big</tt>, and they are
extended by two null bytes rather than one.

<p>
<p><tt>utf-32le</tt>: <a name="./foreign:s68"></a>Arguments of this type are treated like arguments
of type <tt>utf-8</tt>, except they are converted as if via
<tt>string-&gt;utf32</tt> with endianness <tt>little</tt>, and they are
extended by four null bytes rather than one.

<p>
<p><tt>utf-32be</tt>: <a name="./foreign:s69"></a>Arguments of this type are treated like arguments
of type <tt>utf-8</tt>, except they are converted as if via
<tt>string-&gt;utf32</tt> with endianness <tt>big</tt>, and they are
extended by four null bytes rather than one.

<p>
<p><tt>string</tt>: <a name="./foreign:s70"></a>This type is an alias for <tt>utf-8</tt>.

<p>
<p><tt>wstring</tt>: <a name="./foreign:s71"></a>This type is an alias for <tt>utf-16le</tt>,
<tt>utf-16be</tt>, <tt>utf-32le</tt>, or <tt>utf-32be</tt> as
appropriate depending on the size of a C <tt>wchar_t</tt> and
the endianness of the target machine.
For example, <tt>wstring</tt> is equivalent to <tt>utf-16le</tt>
under Windows running on Intel hardware.

<p>
<p><tt>(*&nbsp;<i>ftype</i>)</tt>: <a name="./foreign:s72"></a>This type allows a pointer to a foreign
type (ftype) to be passed.
The argument must be an ftype pointer of type <tt><i>ftype</i></tt>,
and the actual argument is the address encapsulated in the
ftype pointer.
See Section&nbsp;<a href="./foreign.html#g31">4.5</a> for a description of
foreign types.

<p>
<p><tt>(&amp;&nbsp;<i>ftype</i>)</tt>: <a name="./foreign:s73"></a>This type allows a foreign
type (ftype) to be passed as a value, but represented
on the Scheme side as a pointer to the foreign-type data.
That is, a <tt>(&amp;&nbsp;<i>ftype</i>)</tt> argument is represented on
the Scheme side the same as a <tt>(*&nbsp;<i>ftype</i>)</tt> argument,
but a <tt>(&amp;&nbsp;<i>ftype</i>)</tt> argument is passed to the foreign procedure as the
content at the foreign pointer's address instead of as the
address. For example, if <tt><i>ftype</i></tt> is a <tt>struct</tt> type,
then <tt>(&amp;&nbsp;<i>ftype</i>)</tt> passes a struct argument instead of
a struct-pointer argument. The <tt><i>ftype</i></tt> cannot refer to an array type.

<p>
<p>The result types are similar to the parameter types with the addition of a
<a name="./foreign:s74"></a><tt>void</tt> type.
In general, the type conversions are the inverse of the parameter type
conversions.
No error checking is performed on return, since the system cannot determine
whether a foreign result is actually of the indicated type.
Particular caution should be exercised with the result types
<a name="./foreign:s75"></a><tt>scheme-object</tt>,
<a name="./foreign:s76"></a><tt>double-float</tt>,
<a name="./foreign:s77"></a><tt>double</tt>,
<a name="./foreign:s78"></a><tt>single-float</tt>,
<a name="./foreign:s79"></a><tt>float</tt>,
and the types that result in the construction of bytevectors or strings,
since invalid
return values may lead to invalid memory references as well as incorrect
computations.
Following are the valid result types:

<p>
<p><tt>void</tt>: <a name="./foreign:s80"></a>The result of the foreign procedure call is
ignored and an unspecified Scheme object is returned.
<tt>void</tt> should be used when foreign procedures are called for effect only.

<p>
<p><tt>integer-8</tt>: <a name="./foreign:s81"></a>The result is interpreted as a signed
8-bit integer and is converted to a Scheme exact integer.

<p>
<p><tt>unsigned-8</tt>: <a name="./foreign:s82"></a>The result is interpreted as an unsigned
8-bit integer and is converted to a Scheme nonnegative exact integer.

<p>
<p><tt>integer-16</tt>: <a name="./foreign:s83"></a>The result is interpreted as a signed
16-bit integer and is converted to a Scheme exact integer.

<p>
<p><tt>unsigned-16</tt>: <a name="./foreign:s84"></a>The result is interpreted as an unsigned
16-bit integer and is converted to a Scheme nonnegative exact integer.

<p>
<p><tt>integer-32</tt>: <a name="./foreign:s85"></a>The result is interpreted as a signed
32-bit integer and is converted to a Scheme exact integer.

<p>
<p><tt>unsigned-32</tt>: <a name="./foreign:s86"></a>The result is interpreted as an unsigned
32-bit integer and is converted to a Scheme nonnegative exact integer.

<p>
<p><tt>integer-64</tt>: <a name="./foreign:s87"></a>The result is interpreted as a signed
64-bit integer and is converted to a Scheme exact integer.

<p>
<p><tt>unsigned-64</tt>: <a name="./foreign:s88"></a>The result is interpreted as an unsigned
64-bit integer and is converted to a Scheme nonnegative exact integer.

<p>
<p><tt>double-float</tt>: <a name="./foreign:s89"></a>The result is interpreted as a double float
and is translated into a <i>Chez&nbsp;Scheme</i> flonum.

<p>
<p><tt>single-float</tt>: <a name="./foreign:s90"></a>The result is interpreted as a single float
and is translated into a <i>Chez&nbsp;Scheme</i> flonum.
Since <i>Chez&nbsp;Scheme</i> represents flonums in double-float format, the
result is first converted into double-float format.

<p>
<p><tt>short</tt>: <a name="./foreign:s91"></a>This type is an alias for the appropriate
fixed-size type above, depending on the size of a C <tt>short</tt>.

<p>
<p><tt>unsigned-short</tt>: <a name="./foreign:s92"></a>This type is an alias for the appropriate
fixed-size type above, depending on the size of a C <tt>unsigned&nbsp;short</tt>.

<p>
<p><tt>int</tt>: <a name="./foreign:s93"></a>This type is an alias for the appropriate
fixed-size type above, depending on the size of a C <tt>int</tt>.

<p>
<p><tt>unsigned</tt>: <a name="./foreign:s94"></a>This type is an alias for the appropriate
fixed-size type above, depending on the size of a C <tt>unsigned</tt>.

<p>
<p><tt>unsigned-int</tt>: <a name="./foreign:s95"></a>This type is an alias <tt>unsigned</tt>.
fixed-size type above, depending on the size of a C <tt>unsigned</tt>.

<p>
<p><tt>long</tt>: <a name="./foreign:s96"></a>This type is an alias for the appropriate
fixed-size type above, depending on the size of a C <tt>long</tt>.

<p>
<p><tt>unsigned-long</tt>: <a name="./foreign:s97"></a>This type is an alias for the appropriate
fixed-size type above, depending on the size of a C <tt>unsigned&nbsp;long</tt>.

<p>
<p><tt>long-long</tt>: <a name="./foreign:s98"></a>This type is an alias for the appropriate
fixed-size type above, depending on the size of the nonstandard C type
<tt>long&nbsp;long</tt>.

<p>
<p><tt>unsigned-long-long</tt>: <a name="./foreign:s99"></a>This type is an alias for the appropriate
fixed-size type above, depending on the size of the nonstandard C type
<tt>unsigned&nbsp;long&nbsp;long</tt>.

<p>
<p><tt>ptrdiff_t</tt>: <a name="./foreign:s100"></a>This type is an alias for the appropriate
fixed-size type above, depending on its definition in the host machine's
<tt>stddef.h</tt> include file.

<p>
<p><tt>size_t</tt>: <a name="./foreign:s101"></a>This type is an alias for the appropriate unsigned
fixed-size type above, depending on its definition in the host machine's
<tt>stddef.h</tt> include file.

<p>
<p><tt>ssize_t</tt>: <a name="./foreign:s102"></a>This type is an alias for the appropriate signed
fixed-size type above, depending on its definition in the host machine's
<tt>stddef.h</tt> include file.

<p>
<p><tt>iptr</tt>: <a name="./foreign:s103"></a>This type is an alias for the appropriate
fixed-size type above, depending on the size of a C pointer.

<p>
<p><tt>uptr</tt>: <a name="./foreign:s104"></a>This type is an alias for the appropriate
(unsigned) fixed-size type above, depending on the size of a C pointer.

<p>
<p><tt>void*</tt>: <a name="./foreign:s105"></a>This type is an alias for <tt>uptr</tt>.

<p>
<p><tt>boolean</tt>: <a name="./foreign:s106"></a>This type converts a C <tt>int</tt> return value
into a Scheme boolean.
0 is converted to <tt>#f</tt>; all other values are converted to <tt>#t</tt>.

<p>
<p><tt>char</tt>: <a name="./foreign:s107"></a>This type converts a C <tt>unsigned&nbsp;char</tt> return value
into a Scheme character, as if via <tt>integer-&gt;char</tt>.

<p>
<p><tt>wchar_t</tt>: <a name="./foreign:s108"></a>This type converts a C <tt>wchar_t</tt> return value
into a Scheme character, as if via <tt>integer-&gt;char</tt>.
The <tt>wchar_t</tt> value must be a valid Unicode scalar value.

<p>
<p><tt>wchar</tt>: <a name="./foreign:s109"></a>This type is an alias for <tt>wchar_t</tt>.

<p>
<p><tt>double</tt>: <a name="./foreign:s110"></a>This type is an alias for <tt>double-float</tt>.

<p>
<p><tt>float</tt>: <a name="./foreign:s111"></a>This type is an alias for <tt>single-float</tt>.

<p>
<p><tt>scheme-object</tt>: <a name="./foreign:s112"></a>The result is assumed to be a valid Scheme
object, and no conversion is performed.
This type is inherently dangerous, since an invalid Scheme object can corrupt
the memory management system with unpredictable (but always unpleasant) results.
Since Scheme objects are actually typed pointers, even integers cannot
safely be returned as type <tt>scheme-object</tt> unless they were created by
the Scheme system.

<p>
<p><tt>ptr</tt>: <a name="./foreign:s113"></a>This type is an alias for <tt>scheme-object</tt>.

<p>
<p><tt>u8*</tt>: <a name="./foreign:s114"></a>The result is interpreted as a pointer to a
null-terminated sequence of 8-bit unsigned integers (bytes).
If the result is a null pointer, <tt>#f</tt> is returned.
Otherwise, the sequence of bytes is stored in a freshly allocated
bytevector of the appropriate length, and the bytevector is returned to
Scheme.

<p>
<p><tt>u16*</tt>: <a name="./foreign:s115"></a>The result is interpreted as a pointer to a
null-terminated sequence of 16-bit unsigned integers.
If the result is a null pointer, <tt>#f</tt> is returned.
Otherwise, the sequence of 16-bit integers is stored in a freshly allocated
bytevector of the appropriate length, and the bytevector is returned to
Scheme.
The null terminator must be a properly aligned 16-bit word,
i.e., two bytes of zero aligned on a 16-bit boundary.

<p>
<p><tt>u32*</tt>: <a name="./foreign:s116"></a>The result is interpreted as a pointer to a
null-terminated sequence of 32-bit unsigned integers.
If the result is a null pointer, <tt>#f</tt> is returned.
Otherwise, the sequence of 16-bit integers is stored in a freshly allocated
bytevector of the appropriate length, and the bytevector is returned to
Scheme.
The null terminator must be a properly aligned 32-bit word,
i.e., four bytes of zero aligned on a 32-bit boundary.

<p>
<p><tt>utf-8</tt>: <a name="./foreign:s117"></a>The result is interpreted as a pointer to a
null-terminated sequence of 8-bit unsigned character values.
If the result is a null pointer, <tt>#f</tt> is returned.
Otherwise, the sequence of bytes is converted into a Scheme string, as if
via <tt>utf8-&gt;string</tt>, and the string is returned to Scheme.

<p>
<p><tt>utf-16le</tt>: <a name="./foreign:s118"></a>The result is interpreted as a pointer to a
null-terminated sequence of 16-bit unsigned integers.
If the result is a null pointer, <tt>#f</tt> is returned.
Otherwise, the sequence of integers is converted into a Scheme string, as if
via <tt>utf16-&gt;string</tt> with endianness <tt>little</tt>,
and the string is returned to Scheme.
A byte-order mark in the sequence of integers as treated as an ordinary
character value and does not affect the byte ordering.

<p>
<p><tt>utf-16be</tt>: <a name="./foreign:s119"></a>The result is interpreted as a pointer to a
null-terminated sequence of 16-bit unsigned integers.
If the result is a null pointer, <tt>#f</tt> is returned.
Otherwise, the sequence of integers is converted into a Scheme string, as if
via <tt>utf16-&gt;string</tt> with endianness <tt>big</tt>,
and the string is returned to Scheme.
A byte-order mark in the sequence of integers as treated as an ordinary
character value and does not affect the byte ordering.

<p>
<p><tt>utf-32le</tt>: <a name="./foreign:s120"></a>The result is interpreted as a pointer to a
null-terminated sequence of 32-bit unsigned integers.
If the result is a null pointer, <tt>#f</tt> is returned.
Otherwise, the sequence of integers is converted into a Scheme string, as if
via <tt>utf32-&gt;string</tt> with endianness <tt>little</tt>,
and the string is returned to Scheme.
A byte-order mark in the sequence of integers as treated as an ordinary
character value and does not affect the byte ordering.

<p>
<p><tt>utf-32be</tt>: <a name="./foreign:s121"></a>The result is interpreted as a pointer to a
null-terminated sequence of 32-bit unsigned integers.
If the result is a null pointer, <tt>#f</tt> is returned.
Otherwise, the sequence of integers is converted into a Scheme string, as if
via <tt>utf32-&gt;string</tt> with endianness <tt>big</tt>,
and the string is returned to Scheme.
A byte-order mark in the sequence of integers as treated as an ordinary
character value and does not affect the byte ordering.

<p>
<p><tt>string</tt>: <a name="./foreign:s122"></a>This type is an alias for <tt>utf-8</tt>.

<p>
<p><tt>wstring</tt>: <a name="./foreign:s123"></a>This type is an alias for <tt>utf-16le</tt>,
<tt>utf-16be</tt>, <tt>utf-32le</tt>, or <tt>utf-32be</tt> as
appropriate depending on the size of a C <tt>wchar_t</tt> and
the endianness of the target machine.
For example, <tt>wstring</tt> is equivalent to <tt>utf-16le</tt>
under Windows running on Intel hardware.

<p>
<p><tt>(*&nbsp;<i>ftype</i>)</tt>: <a name="./foreign:s124"></a>The result is interpreted as the address of a foreign object
whose structure is described by <tt><i>ftype</i></tt>, and a freshly allocated
ftype pointer encapsulating the address is returned.
See Section&nbsp;<a href="./foreign.html#g31">4.5</a> for a description of
foreign types.

<p>
<p><tt>(&amp;&nbsp;<i>ftype</i>)</tt>: <a name="./foreign:s125"></a>The result is interpreted as a foreign object
whose structure is described by <tt><i>ftype</i></tt>, where the foreign
procedure returns a <tt><i>ftype</i></tt> result, but the caller
must provide an extra <tt>(*&nbsp;<i>ftype</i>)</tt> argument before
all other arguments to receive the result. An unspecified Scheme object
is returned when the foreign procedure is called, since the result
is instead written into storage referenced by the extra argument.
 The <tt><i>ftype</i></tt> cannot refer to an array type.

<p>
<p>Consider a C identity procedure:

<p><tt>int&nbsp;id(x)&nbsp;int&nbsp;x;&nbsp;&#123;&nbsp;return&nbsp;x;&nbsp;&#125;</tt>
<p>After a file containing this procedure has been compiled and loaded
(see Section&nbsp;<a href="./foreign.html#g32">4.6</a>) it can be accessed as follows:

<p>

<p><tt>(foreign-procedure&nbsp;"id"<br>

&nbsp;&nbsp;(int)&nbsp;int)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;procedure&gt;<br>

((foreign-procedure&nbsp;"id"<br>

&nbsp;&nbsp;&nbsp;(int)&nbsp;int)<br>

&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(define&nbsp;int-id<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"id"<br>

&nbsp;&nbsp;&nbsp;&nbsp;(int)&nbsp;int))<br>

(int-id&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1</tt>
<p>The <tt>"id"</tt> entry can also be interpreted as accepting and returning
a boolean:

<p>

<p><tt>(define&nbsp;bool-id<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"id"<br>

&nbsp;&nbsp;&nbsp;&nbsp;(boolean)&nbsp;boolean))<br>

(bool-id&nbsp;#f)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(bool-id&nbsp;#t)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(bool-id&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p>As the last example reveals, <tt>bool-id</tt> is actually a conversion procedure.
When a Scheme object is passed as type <tt>boolean</tt> it is converted to
0 or 1, and when it is returned it is converted to <tt>#f</tt> or <tt>#t</tt>.
As a result objects are converted to normalized boolean values.
The <tt>"id"</tt> entry can be used to create other conversion procedures by
varying the type specifications:

<p>

<p><tt>(define&nbsp;int-&gt;bool<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"id"<br>

&nbsp;&nbsp;&nbsp;&nbsp;(int)&nbsp;boolean))<br>

(int-&gt;bool&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(int-&gt;bool&nbsp;5)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(map&nbsp;(foreign-procedure&nbsp;"id"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(boolean)&nbsp;int)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(#t&nbsp;#f))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(1&nbsp;0)<br>

(define&nbsp;void<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"id"<br>

&nbsp;&nbsp;&nbsp;&nbsp;(int)&nbsp;void))<br>

(void&nbsp;10)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i></tt>
<p>There are, of course, simpler and more efficient ways of accomplishing
these conversions directly in Scheme.

<p>
A foreign entry is resolved when a
<a name="./foreign:s126"></a><tt>foreign-procedure</tt> expression
is evaluated, rather than either when the code is loaded or each time
the procedure is invoked.
Thus, the following definition is always valid since the
<tt>foreign-procedure</tt> expression is not immediately evaluated:

<p>

<p><tt>(define&nbsp;doit<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;((foreign-procedure&nbsp;"doit"&nbsp;()&nbsp;void))))</tt>
<p><tt>doit</tt> should not be invoked, however, before an entry for
<tt>"doit"</tt> has been provided.
Similarly, an entry for <tt>"doit"</tt> must exist before the following code
is evaluated:

<p>

<p><tt>(define&nbsp;doit<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"doit"&nbsp;()&nbsp;void))</tt>
<p>Although the second definition is more constraining on the load order
of foreign files, it is more efficient since the entry resolution need
be done only once.

<p>
It is often useful to define a template to be used
in the creation of several foreign procedures with similar argument
types and return values.
For example, the following code creates two foreign procedures from
a single foreign procedure expression, by abstracting out the foreign
procedure name:

<p>

<p><tt>(define&nbsp;double-&gt;double<br>

&nbsp;&nbsp;(lambda&nbsp;(proc-name)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(foreign-procedure&nbsp;proc-name<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(double)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double)))
<br>
<br>
(define&nbsp;log10&nbsp;(double-&gt;double&nbsp;"log10"))<br>

(define&nbsp;gamma&nbsp;(double-&gt;double&nbsp;"gamma"))</tt>
<p>Both <tt>"log10"</tt> and <tt>"gamma"</tt> must be available as foreign
entries (see Section&nbsp;<a href="./foreign.html#g32">4.6</a>)
before the corresponding definitions.
The use of foreign procedure templates can simplify the coding process
and reduce the amount of code generated when a large number of
foreign procedures are involved, e.g., when an entire library of
foreign procedures is imported into Scheme.


<p>

<h3><a name="g29"></a><a name="./foreign:h3"></a>Section 4.3. Calling into Scheme<a name="SECTFOREIGNCALLABLE"></a></h3>



<p>
Section&nbsp;<a href="./foreign.html#g28">4.2</a> describes the <tt>foreign-procedure</tt>
form, which permits Scheme code to invoke C&nbsp;or C-compatible foreign
procedures.  
This section describes the <tt>foreign-callable</tt> form, which permits
C&nbsp;or C-compatible code to call Scheme procedures.  
A more primitive mechanism for calling Scheme procedures from C is
described in Section&nbsp;<a href="./foreign.html#g34">4.8</a>.

<p>
As when calling foreign procedures from Scheme,
great care must be taken when sharing data between Scheme and
foreign code that calls Scheme to avoid corrupting Scheme's memory
management system.

<p>
A foreign-callable wrapper for a Scheme procedure can also be created by
passing the procedure to <tt>make-ftype-pointer</tt> with an appropriate
function ftype (Section&nbsp;<a href="./foreign.html#g31">4.5</a>).


<p>
<a name="./foreign:s127"></a><span class=formdef><b>syntax</b>: <tt>(foreign-callable&nbsp;<i>conv</i>&nbsp;...&nbsp;<i>proc-exp</i>&nbsp;(<i>param-type</i>&nbsp;...)&nbsp;<i>res-type</i>)</tt></span>
<br>
<b>returns: </b>a code object
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>proc-exp</i></tt> must evaluate to a procedure, the Scheme procedure that
is to be invoked by foreign code.
The parameter and result types are as described for
<tt>foreign-procedure</tt> in Section&nbsp;<a href="./foreign.html#g28">4.2</a>,
except that the requirements and conversions are effectively reversed,
e.g., the conversions described for <tt>foreign-procedure</tt>
arguments are performed for <tt>foreign-callable</tt> return
values.
A <tt>(&amp;&nbsp;<i>ftype</i>)</tt> argument to the callable refers to an address
that is valid only during the dynamic extent of the callback invocation.
A <tt>(&amp;&nbsp;<i>ftype</i>)</tt> result type for a callable causes the Scheme
procedure to receive an extra <tt>(&amp;&nbsp;<i>ftype</i>)</tt> argument before
all others; the Scheme procedure should write a result into the extra
argument, and the direct result of the Scheme procedure is ignored.
Type checking is performed for result values but not argument values,
since the parameter
values are provided by the foreign code and must be assumed to be
correct.

<p>
Each <tt><i>conv</i></tt> adjusts the calling convention to be used.
<tt>foreign-callable</tt> supports the same conventions as
<tt>foreign-procedure</tt> with the exception of <tt>__com</tt>.
The <tt>__collect_safe</tt> convention for a callable activates a
calling thread if the thread is not already activated, and
the thread's activation state is reverted when the callable
returns. If a calling thread is not currently registered with
the Scheme system, then reverting the thread's activation state implies
destroying the thread's registration (see <tt>Sdestroy_thread</tt>).


<p>
The value produced by <tt>foreign-callable</tt> is a Scheme code object,
which contains some header information as well as code that performs
the call to the encapsulated Scheme procedure.
The code object may be converted into a foreign-callable address via
<a name="./foreign:s128"></a><tt>foreign-callable-entry-point</tt>, which returns an integer representing
the address of the entry point within the code object.
(The C-callable library function <tt>Sforeign_callable_entry_point</tt>, described in
Section&nbsp;<a href="./foreign.html#g34">4.8</a>, may be used to obtain the entry point
as well.)  
This is an implicit pointer into a Scheme object, and
in many cases, it is necessary to lock the code object
(using <a name="./foreign:s129"></a><tt>lock-object</tt>)
before converting it into an entry point
to prevent Scheme's storage management system from
relocating or destroying the code object, e.g., when the entry point is
registered as a callback and retained in the "C" side indefinitely.

<p>
The following code creates a foreign-callable code object, locks
the code object, and returns the entry point.

<p>

<p><tt>(let&nbsp;([x&nbsp;(foreign-callable<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(pretty-print&nbsp;(cons&nbsp;x&nbsp;(*&nbsp;y&nbsp;2))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string&nbsp;integer-32)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void)])<br>

&nbsp;&nbsp;(lock-object&nbsp;x)<br>

&nbsp;&nbsp;(foreign-callable-entry-point&nbsp;x))</tt>
<p>Unless the entry point is intended to be permanent, a pointer to the
code object returned by <tt>foreign-callable</tt> should be retained
so that it can be unlocked when no longer needed.

<p>
Mixed use of <tt>foreign-callable</tt> and <tt>foreign-procedure</tt>
may result in nesting of foreign and Scheme calls, and this
results in some interesting considerations when continuations are
involved, directly or indirectly (as via the default exception handler).
See Section&nbsp;<a href="./foreign.html#g30">4.4</a> for a discussion of the
interaction between foreign calls and continuations.

<p>
The following example demonstrates how the "callback" functions
required by many windowing systems might be defined in Scheme with the
use of <tt>foreign-callable</tt>.
Assume that the following C code has been compiled and loaded
(see Section&nbsp;<a href="./foreign.html#g32">4.6</a>).

<p>

<p><tt>#include&nbsp;&lt;stdio.h&gt;
<br>
<br>
typedef&nbsp;void&nbsp;(*CB)(char);
<br>
<br>
CB&nbsp;callbacks[256];
<br>
<br>
void&nbsp;cb_init(void)&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;int&nbsp;i;
<br>
<br>
&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;256;&nbsp;i&nbsp;+=&nbsp;1)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callbacks[i]&nbsp;=&nbsp;(CB)0;<br>

&#125;
<br>
<br>
void&nbsp;register_callback(char&nbsp;c,&nbsp;CB&nbsp;cb)&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;&nbsp;callbacks[c]&nbsp;=&nbsp;cb;<br>

&#125;
<br>
<br>
void&nbsp;event_loop(void)&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;&nbsp;CB&nbsp;f;&nbsp;char&nbsp;c;
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;;)&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;getchar();<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(c&nbsp;==&nbsp;EOF)&nbsp;break;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;callbacks[c];<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(f&nbsp;!=&nbsp;(CB)0)&nbsp;f(c);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&#125;<br>

&#125;</tt>
<p>Interfaces to these functions may be defined in Scheme as follows.

<p>

<p><tt>(define&nbsp;cb-init<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"cb_init"&nbsp;()&nbsp;void))<br>

(define&nbsp;register-callback<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"register_callback"&nbsp;(char&nbsp;void*)&nbsp;void))<br>

(define&nbsp;event-loop<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;__collect_safe&nbsp;"event_loop"&nbsp;()&nbsp;void))</tt>
<p>A callback for selected characters can then be defined.

<p>

<p><tt>(define&nbsp;callback<br>

&nbsp;&nbsp;(lambda&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([code&nbsp;(foreign-callable&nbsp;__collect_safe&nbsp;p&nbsp;(char)&nbsp;void)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lock-object&nbsp;code)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(foreign-callable-entry-point&nbsp;code))))<br>

(define&nbsp;ouch<br>

&nbsp;&nbsp;(callback<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(printf&nbsp;"Ouch!&nbsp;Hit&nbsp;by&nbsp;'~c'~%"&nbsp;c))))<br>

(define&nbsp;rats<br>

&nbsp;&nbsp;(callback<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(printf&nbsp;"Rats!&nbsp;Received&nbsp;'~c'~%"&nbsp;c))))
<br>
<br>
(cb-init)<br>

(register-callback&nbsp;#\a&nbsp;ouch)<br>

(register-callback&nbsp;#\c&nbsp;rats)<br>

(register-callback&nbsp;#\e&nbsp;ouch)</tt>
<p>This sets up the following interaction.

<p>

<p><tt>&gt;&nbsp;(event-loop)<br>

a<br>

Ouch!&nbsp;Hit&nbsp;by&nbsp;'a'<br>

b<br>

c<br>

Rats!&nbsp;Received&nbsp;'c'<br>

d<br>

e<br>

Ouch!&nbsp;Hit&nbsp;by&nbsp;'e'</tt>
<p>The <tt>__collect_safe</tt> declarations in this example ensure that
other threads can continue working while <tt>event-loop</tt>
blocks waiting for input.
A more well-behaved version of the example would save each code object
returned by <tt>foreign-callable</tt> and unlock it when it is no longer
registered as a callback.


<p>
<a name="./foreign:s130"></a><span class=formdef><b>procedure</b>: <tt>(foreign-callable-entry-point&nbsp;<i>code</i>)</tt></span>
<br>
<b>returns: </b>the address of the foreign-callable entry point in <tt><i>code</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>code</i></tt> should be a code object produced by <tt>foreign-callable</tt>.


<p>
<a name="./foreign:s131"></a><span class=formdef><b>procedure</b>: <tt>(foreign-callable-code-object&nbsp;<i>address</i>)</tt></span>
<br>
<b>returns: </b>the code object corresponding to the foreign-callable entry point <tt><i>address</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>address</i></tt> must be an exact integer and should be the address of the
entry point of a code object produced by <tt>foreign-callable</tt>.


<p>

<h3><a name="g30"></a><a name="./foreign:h4"></a>Section 4.4. Continuations and Foreign Calls<a name="SECTFOREIGNCONTINUATIONS"></a></h3>



<p>
<tt>foreign-callable</tt> and <tt>foreign-procedure</tt> allow arbitrary
nesting of foreign and Scheme calls.
Because other languages do not support the fully general first-class
continuations of Scheme, the interaction between continuations and
nested calls among Scheme and foreign procedures is problematic.
<i>Chez&nbsp;Scheme</i> handles this interaction in a general manner by trapping
attempts to return to <i>stale</i> foreign contexts rather than by restricting
the use of continuations directly.
A foreign context is a foreign frame and return point corresponding to
a particular call from a foreign language, e.g., C, into Scheme.
A foreign context becomes stale after a normal return to the context or
after a return to some other foreign context beneath it on the control
stack.

<p>
As a result of this treatment, Scheme continuations may be used to
throw control either upwards or downwards logically through any mix
of Scheme and foreign frames.
Furthermore, until some return to a foreign context is actually performed,
all return points remain valid.
In particular, this means that programs that use continuations
exclusively for nonlocal exits never attempt to return to a
stale foreign context.
(Nonlocal exits themselves are no problem and are implemented
by the C library function <tt>longjmp</tt> or the equivalent.)
Programs that use continuations more generally also function
properly as long as they never actually return to a stale foreign context,
even if control logically moves past stale foreign contexts via invocation
of continuations.

<p>
One implication of this mechanism is that the C stack pointer is not
automatically restored to its base value when a continuation is used on
the Scheme side to perform a nonlocal exit.
If the program continues to run after the nonlocal exit, any further
build-up of the C stack will add to the existing build up, which might
result in a C stack overflow.
To avoid this situation, a program can arrange to set up a single C
call frame before obtaining the continuation and return to the C frame
after the nonlocal exit.
The procedure <tt>with-exit-proc</tt> below arranges to do this without
involving any C code.

<p>

<p><tt>(define&nbsp;with-exit-proc<br>

&nbsp;&nbsp;(lambda&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;th&nbsp;(lambda&nbsp;()&nbsp;(call/cc&nbsp;p)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define-ftype&nbsp;-&gt;ptr&nbsp;(function&nbsp;()&nbsp;ptr))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([fptr&nbsp;(make-ftype-pointer&nbsp;-&gt;ptr&nbsp;th)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([v&nbsp;((ftype-ref&nbsp;-&gt;ptr&nbsp;()&nbsp;fptr))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unlock-object<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(foreign-callable-code-object<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ftype-pointer-address&nbsp;fptr)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v))))</tt>
<p><tt>with-exit-proc</tt> behaves like <tt>call/cc</tt> except it resets
the C stack when the continuation is invoked.
To do this, it creates an ftype-pointer representing a foreign-callable
entry point for <tt>th</tt> and creates a Scheme-callable procedure for
that entry point.
This creates a wrapper for <tt>th</tt> that involves a C call.
When a call to the wrapper returns, either by explicit invocation of the
continuation passed to <tt>p</tt> or by a normal return from <tt>p</tt>,
the C stack is reset to its original value.

<p>

<h3><a name="g31"></a><a name="./foreign:h5"></a>Section 4.5. Foreign Data<a name="SECTFOREIGNDATA"></a></h3>



<p>
The procedures described in this section directly create and manipulate
foreign data, i.e., data that resides outside of the Scheme heap.
With the exception of <tt>foreign-alloc</tt> and <tt>foreign-sizeof</tt>,
these procedures are inherently unsafe in the sense that they do not (and
cannot) check the validity of the addresses they are passed.
Improper use of these procedures can result in invalid memory references,
corrupted data, or system crashes.

<p>
This section also describes a higher-level syntactic mechanism for
manipulating foreign data, including foreign structures, unions,
arrays, and bit fields.
The syntactic interface is safer than the procedural interface but
must still assume that the addresses it's given are appropriate for
the types of object being manipulated.

<p>
<a name="./foreign:s132"></a><span class=formdef><b>procedure</b>: <tt>(foreign-alloc&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the address of a freshly allocated block of foreign data <tt><i>n</i></tt> bytes long
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>n</i></tt> must be a positive fixnum.
The returned value is an exact integer and is guaranteed to be properly
aligned for any type of value according to the requirements of the
underlying hardware.
An exception is raised with condition type <tt>&amp;assertion</tt>
if the block of foreign data cannot be allocated.


<p>
<a name="./foreign:s133"></a><span class=formdef><b>procedure</b>: <tt>(foreign-free&nbsp;<i>address</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure frees the block of storage to which <tt><i>address</i></tt> points.
<tt><i>address</i></tt> must be an exact integer in the range -2<sup><i>w</i>-1</sup> through
2<sup>w</sup> - 1, where <i>w</i> is the width in bits of a pointer, e.g., 64 for a
64-bit machine.
It should be an address returned by an earlier call to
<tt>foreign-alloc</tt> and not subsequently passed to
<tt>foreign-free</tt>.

<p>
<a name="./foreign:s134"></a><span class=formdef><b>procedure</b>: <tt>(foreign-ref&nbsp;<i>type</i>&nbsp;<i>address</i>&nbsp;<i>offset</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>foreign-ref</tt> extracts the value of type <tt><i>type</i></tt>
<tt><i>offset</i></tt> bytes into the block of foreign data addressed by
<tt><i>address</i></tt>.

<p>
<tt><i>type</i></tt> must be a symbol identifying the type of value
to be extracted.
The following types have machine-dependent sizes and correspond to the
like-named C types:

<p>
<ul>
<li><tt>short</tt>,
<li><tt>unsigned-short</tt>,
<li><tt>int</tt>,
<li><tt>unsigned</tt>,
<li><tt>unsigned-int</tt>,
<li><tt>long</tt>,
<li><tt>unsigned-long</tt>,
<li><tt>long-long</tt>,
<li><tt>unsigned-long-long</tt>,
<li><tt>ptrdiff_t</tt>,
<li><tt>size_t</tt>,
<li><tt>ssize_t</tt>,
<li><tt>char</tt>,
<li><tt>wchar_t</tt>,
<li><tt>float</tt>,
<li><tt>double</tt>, and
<li><tt>void*</tt>.
</ul>
<p>

<p>
The types <tt>long-long</tt> and <tt>unsigned-long-long</tt>
correspond to the C types <tt>long&nbsp;long</tt> 
and <tt>unsigned&nbsp;long&nbsp;long</tt>.
A value of type <tt>char</tt> is referenced as a single
byte and converted (as if via <tt>integer-&gt;char</tt>)
into a Scheme character.
A value of type <tt>wchar_t</tt> is converted (as if via
<tt>integer-&gt;char</tt>) into a Scheme character.
The value must be a valid Unicode scalar value.

<p>
<tt>wchar</tt> is an alias for <tt>wchar_t</tt>.

<p>
Several additional machine-dependent types are recognized:

<p>
<ul>
<li><tt>iptr</tt>,
<li><tt>uptr</tt>,
<li><tt>fixnum</tt>, and
<li><tt>boolean</tt>.
</ul>
<p>

<p>
<tt>uptr</tt> is equivalent to <tt>void*</tt>; both are treated as
unsigned integers the size of a pointer.
<tt>iptr</tt> is treated as a signed integer the size of a pointer.
<tt>fixnum</tt> is treated as an <tt>iptr</tt>, but with a range limited
to the fixnum range.
<tt>boolean</tt> is treated as an <tt>int</tt>, with zero
converted to the Scheme value <tt>#f</tt> and all
other values converted to <tt>#t</tt>.

<p>
Finally, several fixed-sized types are also supported:

<p>
<ul>
<li><tt>integer-8</tt>,
<li><tt>unsigned-8</tt>,
<li><tt>integer-16</tt>,
<li><tt>unsigned-16</tt>,
<li><tt>integer-32</tt>,
<li><tt>unsigned-32</tt>,
<li><tt>integer-64</tt>,
<li><tt>unsigned-64</tt>,
<li><tt>single-float</tt>, and
<li><tt>double-float</tt>.
</ul>
<p>

<p>
<tt><i>address</i></tt> must be an exact integer in the range -2<sup><i>w</i>-1</sup> through
2<sup>w</sup> - 1, where <i>w</i> is the width in bits of a pointer, e.g., 64 for a
64-bit machine.
<tt><i>offset</i></tt> must be an exact fixnum.
The sum of <tt><i>address</i></tt> and <tt><i>offset</i></tt> should address a readable block
of memory large enough to hold a value of type <tt><i>type</i></tt>, within a block
of storage previously returned by <tt>foreign-alloc</tt> and not
subsequently freed by <tt>foreign-free</tt> or within a block of storage
obtained via some other mechanism, e.g., a foreign call.
For multiple-byte values, the native endianness of the machine is assumed.

<p>
<a name="./foreign:s135"></a><span class=formdef><b>procedure</b>: <tt>(foreign-set!&nbsp;<i>type</i>&nbsp;<i>address</i>&nbsp;<i>offset</i>&nbsp;<i>value</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>foreign-set!</tt> stores a representation of <tt><i>value</i></tt> as type
<tt><i>type</i></tt> <tt><i>offset</i></tt> bytes into the block of foreign data addressed by
<tt><i>address</i></tt>.

<p>
<tt><i>type</i></tt> must be a symbol identifying the type of value
to be stored, one of those listed in the description of
<tt>foreign-ref</tt> above.
Scheme characters are converted to type <tt>char</tt> or <tt>wchar_t</tt>
as if via <tt>char-&gt;integer</tt>.
For type <tt>boolean</tt>, Scheme <tt>#f</tt> is converted to the
<tt>int</tt> 0, and any other Scheme object is converted to 1.

<p>
<tt><i>address</i></tt> must be an exact integer in the range -2<sup><i>w</i>-1</sup> through
2<sup>w</sup> - 1, where <i>w</i> is the width in bits of a pointer, e.g., 64 for a
64-bit machine.
<tt><i>offset</i></tt> must be an exact fixnum.
The sum of <tt><i>address</i></tt> and <tt><i>offset</i></tt> should address a writable block
of memory large enough to hold a value of type <tt><i>type</i></tt>, within a block
of storage previously returned by <tt>foreign-alloc</tt> and not
subsequently freed by <tt>foreign-free</tt> or within a block of storage
obtained via some other mechanism, e.g., a foreign call.
<tt><i>value</i></tt> must be an appropriate value for <tt><i>type</i></tt>, e.g.,
a floating-point number for the float types or an exact integer within
the appropriate range for the integer types.
For multiple-byte values, the native endianness of the machine is assumed.

<p>
<a name="./foreign:s136"></a><span class=formdef><b>procedure</b>: <tt>(foreign-sizeof&nbsp;<i>type</i>)</tt></span>
<br>
<b>returns: </b>the size in bytes of <tt><i>type</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>type</i></tt> must be one of the symbols listed in the description
of <tt>foreign-ref</tt> above.


<p>
<a name="./foreign:s137"></a><a name="defn:define-ftype"></a>
<span class=formdef><b>syntax</b>: <tt>(define-ftype&nbsp;<i>ftype-name</i>&nbsp;<i>ftype</i>)</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>(define-ftype&nbsp;(<i>ftype-name</i>&nbsp;<i>ftype</i>)&nbsp;...)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./foreign:s138"></a><a name="./foreign:s139"></a>A <tt>define-ftype</tt> form is a definition and can appear anywhere
other definitions can appear.
It establishes one or more foreign-type (ftype) bindings for the identifier
<tt><i>ftype-name</i></tt> or identifiers <tt><i>ftype-name</i>&nbsp;...</tt>
to the foreign type represented <tt><i>ftype</i></tt> or the foreign types
represented by <tt><i>ftype</i>&nbsp;...</tt>.
Each <tt><i>ftype-name</i></tt> can be used to access foreign objects with the
declared shape, and each can be used in the formation of other ftypes.

<p>
An <tt><i>ftype</i></tt> must take one of the following forms:

<p>

<p><tt><i>ftype-name</i><br>

(struct&nbsp;(<i>field-name</i>&nbsp;<i>ftype</i>)&nbsp;...)<br>

(union&nbsp;(<i>field-name</i>&nbsp;<i>ftype</i>)&nbsp;...)<br>

(array&nbsp;<i>length</i>&nbsp;<i>ftype</i>)<br>

(*&nbsp;<i>ftype</i>)<br>

(bits&nbsp;(<i>field-name</i>&nbsp;<i>signedness</i>&nbsp;<i>bits</i>)&nbsp;...)<br>

(function&nbsp;<i>conv</i>&nbsp;...&nbsp;(<i>ftype</i>&nbsp;...)&nbsp;<i>ftype</i>)<br>

(packed&nbsp;<i>ftype</i>)<br>

(unpacked&nbsp;<i>ftype</i>)<br>

(endian&nbsp;<i>endianness</i>&nbsp;<i>ftype</i>)</tt>
<p>where <tt><i>length</i></tt> is an exact nonnegative integer,
<tt><i>bits</i></tt> is an exact positive integer,
<tt><i>field-name</i></tt> is an identifier,
<tt><i>conv</i></tt> is <tt>#f</tt> or a string naming a valid convention
as described on page&nbsp;<a href="./foreign.html#g28">4.2</a>,
signedness is either <tt>signed</tt> or <tt>unsigned</tt>, and
endianness is one of <tt>native</tt>, <tt>big</tt>, or <tt>little</tt>.

<p>
A restriction not reflected above is that 
<tt>function</tt> ftypes cannot be used as the types of
field names or array elements.
That is, <a name="./foreign:s140"></a>function ftypes are valid only at the
top level of an ftype, e.g,:

<p>

<p><tt>(define-ftype&nbsp;bvcopy_t&nbsp;(function&nbsp;(u8*&nbsp;u8*&nbsp;size_t)&nbsp;void))</tt>
<p>or as the immediate sub-type of a pointer (<tt>*</tt>) ftype, as in the
following definitions, which are equivalent assuming the definition of
<tt>bvcopy_t</tt> above.

<p>

<p><tt>(define-ftype&nbsp;A<br>

&nbsp;&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;[x&nbsp;int]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[f&nbsp;(*&nbsp;(function&nbsp;(u8*&nbsp;u8*&nbsp;size_t)&nbsp;void))]))
<br>
<br>
(define-ftype&nbsp;A<br>

&nbsp;&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;[x&nbsp;int]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[f&nbsp;(*&nbsp;bvcopy_t)]))</tt>
<p>That is, a function cannot be embedded within a struct, union,
or array, but a pointer to a function can be so embedded.

<p>
The following definitions establish ftype bindings for <tt>F</tt>,
<tt>A</tt>, and <tt>E</tt>.

<p>

<p><tt>(define-ftype&nbsp;F&nbsp;(function&nbsp;(wchar_t&nbsp;int)&nbsp;int))
<br>
<br>
(define-ftype&nbsp;A&nbsp;(array&nbsp;10&nbsp;wchar_t))
<br>
<br>
(define-ftype&nbsp;E<br>

&nbsp;&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;[a&nbsp;int]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[b&nbsp;double]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[c&nbsp;(array&nbsp;25<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[a&nbsp;short]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[_&nbsp;long]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[b&nbsp;A]))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[d&nbsp;(endian&nbsp;big<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(union<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[v1&nbsp;unsigned-32]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[v2&nbsp;(bits<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[hi&nbsp;unsigned&nbsp;12]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[lo&nbsp;unsigned&nbsp;20])]))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[e&nbsp;(*&nbsp;A)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[f&nbsp;(*&nbsp;F)]))</tt>
<p>The ftype <tt>F</tt> describes the type of a foreign function that
takes two arguments, a wide character and an integer, and returns an
integer.
The ftype <tt>A</tt> is simply an array of 10 <tt>wchar_t</tt> values,
and its size will be 10 times the size of a single <tt>wchar_t</tt>.
The ftype <tt>E</tt> is a structure with five fields: an integer
<tt>a</tt>, a double-float <tt>b</tt>, an array <tt>c</tt>, a
union <tt>d</tt>, and a pointer <tt>e</tt>.
The array <tt>c</tt> is an array of 25 structs, each of which
contains a short integer, a long integer, and a <tt>A</tt> array.
The size of the <tt>c</tt> array will be 25 times the size of a
single <tt>A</tt> array, plus 25 times the space needed to store
each of the short and long integers.
The union <tt>d</tt> is either a 32-bit unsigned integer or
a 32-bit unsigned integer split into high (12 bits) and low (20 bits)
components.
The fields of a union overlap so that writing to one effectively
overlaps the other.
Thus, one can use the <tt>d</tt> union type to split apart an
unsigned integer by writing the integer into <tt>v1</tt> and reading
the pieces from <tt>hi</tt> and <tt>lo</tt>.
The pointer <tt>e</tt> points to an <tt>A</tt> array; it is not
itself an array, and its size is just the size of a single pointer.
Similarly, <tt>f</tt> points to a function, and its size is also
that of a single pointer.

<p>
An underscore (&nbsp;<tt>_</tt>&nbsp;) can be used as the field name for one or
more fields of a <tt>struct</tt>, <tt>union</tt>, or <tt>bits</tt> ftype.
Such fields are included in the layout but are considered unnamed and
cannot be accessed via the ftype operators described below.
Thus, in the example above, the <tt>long</tt> field within the
<tt>c</tt> array is inaccessible.

<p>
Non-underscore field names are handled symbolically, i.e.,
they are treated as symbols rather than identifiers.
Each symbol must be unique (as a symbol) with respect to the other
field names within a single <tt>struct</tt>, <tt>union</tt>,
or <tt>bits</tt> ftype but need not be
unique with respect to field names in other <tt>struct</tt>,
<tt>union</tt>, or <tt>bits</tt> ftypes within the same
ftype.

<p>
Each <tt><i>ftype-name</i></tt> in an <tt><i>ftype</i></tt> must either
(a) have been defined previously by <tt>define-ftype</tt>,
(b) be defined by the current <tt>define-ftype</tt>,
or
(c) be a base-type name, i.e., one of the type names supported by
<tt>foreign-ref</tt> and <tt>foreign-set!</tt>.
In case (b), any reference within one <tt><i>ftype</i></tt> to the
<tt><i>ftype-name</i></tt> of one of the earlier bindings is permissible,
but a reference to the <tt><i>ftype-name</i></tt> of the current or a
subsequent binding can appear only within a pointer field.

<p>
For example, in:

<p>

<p><tt>(define-ftype<br>

&nbsp;&nbsp;[Qlist&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[head&nbsp;int]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[tail&nbsp;(*&nbsp;Qlist)])])</tt>
<p>the reference to <tt>Qlist</tt> is permissible since it appears
within a pointer field.
Similarly, in:

<p>

<p><tt>(define-ftype<br>

&nbsp;&nbsp;[Qfrob&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[head&nbsp;int]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[tail&nbsp;(*&nbsp;Qsnark)])]<br>

&nbsp;&nbsp;[Qsnark&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[head&nbsp;int]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[xtra&nbsp;Qfrob]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[tail&nbsp;(*&nbsp;Qfrob)])])</tt>
<p>the mutually recursive references to <tt>Qsnark</tt> and <tt>Qfrob</tt>
are permissible.
In the following, however:

<p>

<p><tt>(define-ftype<br>

&nbsp;&nbsp;[Qfrob&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[head&nbsp;int]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[xtra&nbsp;Qfrob]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[tail&nbsp;(*&nbsp;Qsnark)])]<br>

&nbsp;&nbsp;[Qsnark&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[head&nbsp;int]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[tail&nbsp;(*&nbsp;Qfrob)])])</tt>
<p>the reference to <tt>Qfrob</tt> within the <tt><i>ftype</i></tt> for <tt>Qfrob</tt>
is invalid, and in:

<p>

<p><tt>(define-ftype<br>

&nbsp;&nbsp;[Qfrob&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[head&nbsp;int]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[xtra&nbsp;Qsnark]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[tail&nbsp;(*&nbsp;Qsnark)])]<br>

&nbsp;&nbsp;[Qsnark&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[head&nbsp;int]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[tail&nbsp;(*&nbsp;Qfrob)])])</tt>
<p>the reference to <tt>Qsnark</tt> is similarly invalid.

<p>
By default, padding is inserted where appropriate to maintain
proper alignment of multiple-byte scalar values in an attempt to
mirror the target machine's C struct layout conventions, where
such layouts are adequately documented.
For packed ftypes (ftypes wrapped in a <tt>packed</tt> form with
no closer enclosing <tt>unpacked</tt> form), this padding is not
inserted.

<p>
Multiple-byte scalar values are stored in memory using the
target machine's native "endianness," e.g., <tt>little</tt>
on X86 and X86_64-based platforms and <tt>big</tt> on
Sparc-based platforms.
Big-endian or little-endian representation can be forced via
the <tt>endian</tt> ftype with a <tt>big</tt> or <tt>little</tt>
<tt><i>endianness</i></tt> specifier.
The <tt>native</tt> specifier can be used to force a return
back to <tt>native</tt> representation.
Each <tt>endian</tt> form affects only ftypes nested syntactically
within it and not nested within a closer <tt>endian</tt> form.

<p>
The total size <i>n</i> of the fields within an ftype bits form must
be 8, 16, 24, 32, 40, 48, 56, or 64.  padding must be added manually if needed.
In little-endian representation, the first field occupies
the low-order bits of the containing 8, 16, 24, 32, 40, 48, 56, or 64-bit word,
with each subsequent field just above the preceding field.
In big-endian representation, the first field occupies the
high-order bits, with each subsequent field just below the
preceding field.

<p>
Two ftypes are considered equivalent only if defined by the
same <tt>ftype</tt> binding.
If two ftype definitions look identical but appear in two
parts of the same program, the ftypes are not identical,
and attempts to access one using the name of the other via
the operators described below will fail with a run-time
exception.

<p>
Array bounds must always be constant.
If an array's length cannot be known until run time, the array
can be placed at the end of the ftype (and any containing ftype)
and declared to have size zero, as illustrated by the example below.

<p>

<p><tt>(define-ftype&nbsp;Vec<br>

&nbsp;&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;[len&nbsp;int]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[data&nbsp;(array&nbsp;0&nbsp;double)]))<br>

(define&nbsp;make-Vec<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([fptr&nbsp;(make-ftype-pointer&nbsp;Vec<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(foreign-alloc<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(ftype-sizeof&nbsp;Vec)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(ftype-sizeof&nbsp;double)&nbsp;n))))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ftype-set!&nbsp;Vec&nbsp;(len)&nbsp;fptr&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fptr)))<br>

(define&nbsp;x&nbsp;(make-Vec&nbsp;100))<br>

(/&nbsp;(-&nbsp;(ftype-pointer-address&nbsp;(ftype-&amp;ref&nbsp;Vec&nbsp;(data&nbsp;10)&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ftype-pointer-address&nbsp;x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;10<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ftype-sizeof&nbsp;int))<br>

&nbsp;&nbsp;&nbsp;(ftype-sizeof&nbsp;double))<br>

(foreign-free&nbsp;(ftype-pointer-address&nbsp;x))</tt>
<p>No array bounds checks are performed for zero-length arrays.
Only one variable-sized array can appear
in a single foreign object, but one can work around this by
treating the object as multiple individual objects.

<p>
To avoid specifying the constant length of an array in more than
one place, a macro that binds both a variable to the size as
well as an ftype name to the ftype can be used.
For example,

<p>

<p><tt>(define-syntax&nbsp;define-array<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;array-name&nbsp;type&nbsp;size-name&nbsp;size)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;size-name&nbsp;size)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-ftype&nbsp;array-name<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(array&nbsp;size&nbsp;type)))]))<br>

(define-array&nbsp;A&nbsp;int&nbsp;A-size&nbsp;100)<br>

A-size&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;100<br>

(ftype-pointer-ftype<br>

&nbsp;&nbsp;(make-ftype-pointer&nbsp;A<br>

&nbsp;&nbsp;&nbsp;&nbsp;(foreign-alloc&nbsp;(ftype-sizeof&nbsp;A))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(array&nbsp;100&nbsp;int)</tt>
<p>This technique can be used to define arbitrary ftypes with
arbitrary numbers of array fields.

<p>
<a name="page:ftype-subtyping"></a><a name="./foreign:s141"></a>A struct ftype is an implicit subtype of the type of the first field
of the struct.
Similarly, an array ftype is an implicit subtype of the type of its
elements.
Thus, the struct or array extends the type of first field or element
with additional fields or elements.
This allows an instance of the struct or array to be treated as an instance
of the type of its first field or element, without the need to use
<tt>ftype-&amp;ref</tt> to allocate a new pointer to the field or element.


<p>
<a name="./foreign:s142"></a><span class=formdef><b>syntax</b>: <tt>(ftype-sizeof&nbsp;<i>ftype-name</i>)</tt></span>
<br>
<b>returns: </b>the size in bytes of the ftype identified by <tt><i>ftype-name</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The size includes the sizes of any ftypes directly embedded within the
identified ftype but excludes those indirectly embedded via a pointer
ftype.
In the latter case, the size of the pointer is included.

<p>
<tt><i>ftype-name</i></tt> must not be defined as a function ftype, since the size
of a function cannot generally be determined.

<p>

<p><tt>(define-ftype&nbsp;B<br>

&nbsp;&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;[b1&nbsp;integer-32]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[b2&nbsp;(array&nbsp;10&nbsp;integer-32)]))<br>

(ftype-sizeof&nbsp;B)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;44
<br>
<br>
(define-ftype&nbsp;C&nbsp;(*&nbsp;B))<br>

(ftype-sizeof&nbsp;C)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4&nbsp;&nbsp;<i>;&nbsp;on&nbsp;32-bit&nbsp;machines</i><br>

(ftype-sizeof&nbsp;C)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;8&nbsp;&nbsp;<i>;&nbsp;on&nbsp;64-bit&nbsp;machines</i>
<br>
<br>
(define-ftype&nbsp;BB<br>

&nbsp;&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;[bb1&nbsp;B]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[bb2&nbsp;(*&nbsp;B)]))<br>

(-&nbsp;(ftype-sizeof&nbsp;BB)&nbsp;(ftype-sizeof&nbsp;void*))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;44</tt>
<p><a name="./foreign:s143"></a><a name="desc:make-ftype-pointer"></a>
<span class=formdef><b>syntax</b>: <tt>(make-ftype-pointer&nbsp;<i>ftype-name</i>&nbsp;<i>expr</i>)</tt></span>
<br>
<b>returns: </b>an ftype-pointer object
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>ftype-name</i></tt> does not describe a function ftype, <tt><i>expr</i></tt>
must evaluate to an <tt><i>address</i></tt> represented as an exact integer in
the appropriate range for the target machine.

<p>
The ftype-pointer object returned by this procedure encapsulates the
address and is tagged with a representation of the type identified by
<tt><i>ftype-name</i></tt> to enable various forms of checking to be done by the
access routines described below.

<p>

<p><tt>(make-ftype-pointer&nbsp;E&nbsp;#x80000000)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;ftype-pointer&nbsp;#x80000000&gt;</tt>
<p>The address will not typically be a constant, as shown.
Instead, it might instead come from a call to <tt>foreign-alloc</tt>, e.g.:

<p>

<p><tt>(make-ftype-pointer&nbsp;E&nbsp;(foreign-alloc&nbsp;(ftype-sizeof&nbsp;E)))</tt>
<p>It might also come from source outside of Scheme such as from a C
routine called from Scheme via the foreign-procedure interface.

<p>
If <tt><i>ftype-name</i></tt> describes a <a name="./foreign:s144"></a>function ftype,
<tt><i>expr</i></tt> must evaluate to an address, procedure, or string.
If it evaluates to address, the call behaves like any other call to
<tt>make-ftype-pointer</tt> with an address argument.

<p>
If it evaluates to a procedure, a foreign-callable code object is
created for the procedure, as if via
<a name="./foreign:s145"></a><tt>foreign-callable</tt>
(Section&nbsp;<a href="./foreign.html#g29">4.3</a>).
The address encapsulated in the resulting ftype-pointer object is the
address of the procedure's entry point.

<p>

<p><tt>(define&nbsp;fact<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)&nbsp;1&nbsp;(fact&nbsp;(-&nbsp;n&nbsp;1)))))<br>

(define-ftype&nbsp;fact_t&nbsp;(function&nbsp;(int)&nbsp;int))<br>

(define&nbsp;fact-fptr&nbsp;(make-ftype-pointer&nbsp;fact_t&nbsp;fact))</tt>
<p>The resulting ftype pointer can be passed to a C routine,
if the argument is declared to be a pointer to the same ftype, and
the C routine can invoke the function pointer it receives as it
would any other function pointer.
Thus, <tt>make-ftype-pointer</tt> with a function ftype is an alternative
to <tt>foreign-callable</tt> for creating C-callable wrappers for Scheme
procedures.

<p>
Since all Scheme objects, including code objects, can be relocated or
even reclaimed by the garbage collector the foreign-callable code object
is automatically locked, as if via <tt>lock-object</tt>, before it is
embedded in the ftype pointer.
The code object should be unlocked after its last use from C,
since locked objects take up space, cause fragmentation, and
increase the cost of collection.
Since the system cannot determine automatically when the last use
from C occurs, the program must explicitly unlock the code object,
which it can do by extracting the address from the ftype-pointer
converting the address (back) into a code object, and passing it
to <tt>unlock-object</tt>:

<p>

<p><tt>(unlock-object<br>

&nbsp;&nbsp;(foreign-callable-code-object<br>

&nbsp;&nbsp;&nbsp;&nbsp;(ftype-pointer-address&nbsp;fact-fptr)))</tt>
<p>Once unlocked, the ftype pointer should not be used again, unless
it is relocked, e.g., via:

<p>

<p><tt>(lock-object<br>

&nbsp;&nbsp;(foreign-callable-code-object<br>

&nbsp;&nbsp;&nbsp;&nbsp;(ftype-pointer-address&nbsp;fact-fptr)))</tt>
<p>A program can determine whether an object is already locked via
the <tt>locked-object?</tt> predicate.

<p>
A <a name="./foreign:s146"></a>function ftype can be also used with
<tt>make-ftype-pointer</tt> to create an ftype-pointer to a C function,
either by providing the address of the C function or its name, represented
as a string.
For example, with the following definition of <tt>bvcopy_t</tt>,

<p>

<p><tt>(define-ftype&nbsp;bvcopy_t&nbsp;(function&nbsp;(u8*&nbsp;u8*&nbsp;size_t)&nbsp;void))</tt>
<p>the two definitions of <tt>bvcopy-ftpr</tt> below are equivalent.

<p>

<p><tt>(define&nbsp;bvcopy-fptr&nbsp;(make-ftype-pointer&nbsp;bvcopy_t&nbsp;"memcpy"))<br>

(define&nbsp;bvcopy-fptr&nbsp;(make-ftype-pointer&nbsp;bvcopy_t&nbsp;(foreign-entry&nbsp;"memcpy")))</tt>
<p>A library that defines <tt><i>memcpy</i></tt> must be loaded first via
<tt>load-shared-object</tt>, or <tt>memcpy</tt> must be registered
via one of the methods described in Section &nbsp;<a href="./foreign.html#g32">4.6</a>.

<p>
<a name="./foreign:s147"></a><span class=formdef><b>syntax</b>: <tt>(ftype-pointer?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an ftype pointer, otherwise <tt>#f</tt>
<br><span class=formdef><b>syntax</b>: <tt>(ftype-pointer?&nbsp;<i>ftype-name</i>&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an <tt><i>ftype-name</i></tt>, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>(define-ftype&nbsp;Widget1&nbsp;(struct&nbsp;[x&nbsp;int]&nbsp;[y&nbsp;int]))<br>

(define-ftype&nbsp;Widget2&nbsp;(struct&nbsp;[w&nbsp;Widget1]&nbsp;[b&nbsp;boolean]))
<br>
<br>
(define&nbsp;x1&nbsp;(make-ftype-pointer&nbsp;Widget1&nbsp;#x80000000))<br>

(define&nbsp;x2&nbsp;(make-ftype-pointer&nbsp;Widget2&nbsp;#x80000000))
<br>
<br>
(ftype-pointer?&nbsp;x1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(ftype-pointer?&nbsp;x2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(ftype-pointer?&nbsp;Widget1&nbsp;x1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(ftype-pointer?&nbsp;Widget1&nbsp;x2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(ftype-pointer?&nbsp;Widget2&nbsp;x1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(ftype-pointer?&nbsp;Widget2&nbsp;x2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(ftype-pointer?&nbsp;#x80000000)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(ftype-pointer?&nbsp;Widget1&nbsp;#x80000000)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./foreign:s148"></a><span class=formdef><b>procedure</b>: <tt>(ftype-pointer-address&nbsp;<i>fptr</i>)</tt></span>
<br>
<b>returns: </b>the address encapsulated within <tt><i>fptr</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>fptr</i></tt> must be an ftype-pointer object.

<p>

<p><tt>(define&nbsp;x&nbsp;(make-ftype-pointer&nbsp;E&nbsp;#x80000000))<br>

(ftype-pointer-address&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#x80000000</tt>
<p><a name="./foreign:s149"></a><span class=formdef><b>syntax</b>: <tt>(ftype-pointer=?&nbsp;<i>fptr<sub>1</sub></i>&nbsp;<i>fptr<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fptr<sub>1</sub></i></tt> and <tt><i>fptr<sub>2</sub></i></tt> have the same address, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>fptr<sub>1</sub></i></tt> and <tt><i>fptr<sub>2</sub></i></tt> must be ftype-pointer objects.

<p>
<tt>ftype-pointer=?</tt> might be defined as follows:

<p>

<p><tt>(define&nbsp;ftype-pointer=?<br>

&nbsp;&nbsp;(lambda&nbsp;(fptr1&nbsp;fptr2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(=&nbsp;(ftype-pointer-address&nbsp;fptr1)&nbsp;(ftype-pointer-address&nbsp;fptr2))))</tt>
<p>It is, however, guaranteed not to allocate bignums for the addresses
even if the addresses do not fit in fixnum range.

<p>
<a name="./foreign:s150"></a><span class=formdef><b>syntax</b>: <tt>(ftype-pointer-null?&nbsp;<i>fptr</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the address of <tt><i>fptr</i></tt> is 0, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>fptr</i></tt> must be an ftype-pointer object.

<p>
<tt>ftype-pointer-null?</tt> might be defined as follows:

<p>

<p><tt>(define&nbsp;ftype-pointer-null?<br>

&nbsp;&nbsp;(lambda&nbsp;(fptr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(=&nbsp;(ftype-pointer-address&nbsp;fptr)&nbsp;0)))</tt>
<p>It is, however, guaranteed not to allocate a bignum for the address
even if the address does not fit in fixnum range.

<p>
<a name="./foreign:s151"></a><span class=formdef><b>syntax</b>: <tt>(ftype-&amp;ref&nbsp;<i>ftype-name</i>&nbsp;(<i>a</i>&nbsp;...)&nbsp;<i>fptr-expr</i>)</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>(ftype-&amp;ref&nbsp;<i>ftype-name</i>&nbsp;(<i>a</i>&nbsp;...)&nbsp;<i>fptr-expr</i>&nbsp;<i>index</i>)</tt></span>
<br>
<b>returns: </b>an ftype-pointer object
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The ftype-pointer object returned by <tt>ftype-&amp;ref</tt>
encapsulates the address of some object embedded directly or
indirectly within the foreign object pointed to by the value
of <tt><i>fptr-expr</i></tt>, offset by <tt><i>index</i></tt>, if present.
The value of <tt><i>fptr-expr</i></tt> must be
an ftype pointer (fptr) of the ftype identified by <tt><i>ftype-name</i></tt>,
and <tt><i>index</i></tt> must either be the identifier <tt>*</tt> or evaluate
to a fixnum, possibly negative.
The index is automatically scaled by the size of the ftype identified
by <tt><i>ftype-name</i></tt>, which allows the fptr to be treated as an array
of <tt><i>ftype-name</i></tt> objects and <tt><i>index</i></tt> as an index into that array.
An index of <tt>*</tt> or 0 is the same as no index.

<p>
The sequence of accessors <tt><i>a</i>&nbsp;...</tt> must specify a
valid path through the identified ftype.
For <tt>struct</tt>, <tt>union</tt>, and <tt>bits</tt> ftypes,
an accessor must be a valid field name for the ftype, while for
pointer and array ftypes, an accessor must be the identifier
<tt>*</tt> or evaluate to a fixnum index.
For array ftypes, an index must be nonnegative, and for array ftypes
with nonzero length, an index must also be less than the length.

<p>
The examples below assume the definitions of <tt>B</tt> and <tt>BB</tt>
shown above in the description of <tt>ftype-sizeof</tt>.
Fixed addresses are shown for illustrative purposes and are assumed
to be valid, although addresses are generally determined
at run time via <tt>foreign-alloc</tt> or some other mechanism.

<p>

<p><tt>(define&nbsp;x&nbsp;(make-ftype-pointer&nbsp;B&nbsp;#x80000000))<br>

(ftype-&amp;ref&nbsp;B&nbsp;()&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;ftype-pointer&nbsp;#x80000000&gt;<br>

(let&nbsp;([idx&nbsp;1])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;ftype-pointer&nbsp;#x8000002C&gt;<br>

&nbsp;&nbsp;(ftype-&amp;ref&nbsp;B&nbsp;()&nbsp;x&nbsp;idx))<br>

(let&nbsp;([idx&nbsp;-1])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;ftype-pointer&nbsp;#x7FFFFFD4&gt;<br>

&nbsp;&nbsp;(ftype-&amp;ref&nbsp;B&nbsp;()&nbsp;x&nbsp;idx))<br>

(ftype-&amp;ref&nbsp;B&nbsp;(b1)&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;ftype-pointer&nbsp;#x80000000&gt;<br>

(ftype-&amp;ref&nbsp;B&nbsp;(b2)&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;ftype-pointer&nbsp;#x80000004&gt;<br>

(ftype-&amp;ref&nbsp;B&nbsp;(b2&nbsp;5)&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;ftype-pointer&nbsp;#x80000018&gt;<br>

(let&nbsp;([n&nbsp;5])&nbsp;(ftype-&amp;ref&nbsp;B&nbsp;(b2&nbsp;n)&nbsp;x))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;ftype-pointer&nbsp;#x80000018&gt;
<br>
<br>
(ftype-&amp;ref&nbsp;B&nbsp;(b1&nbsp;b2)&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>syntax&nbsp;error</i><br>

(ftype-&amp;ref&nbsp;B&nbsp;(b2&nbsp;15)&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>run-time&nbsp;exception</i>
<br>
<br>
(define&nbsp;y&nbsp;(make-ftype-pointer&nbsp;BB&nbsp;#x90000000))<br>

(ftype-set!&nbsp;BB&nbsp;(bb2)&nbsp;y&nbsp;x)<br>

(ftype-&amp;ref&nbsp;BB&nbsp;(bb1&nbsp;b2)&nbsp;y)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;ftype-pointer&nbsp;#x90000004&gt;<br>

(ftype-&amp;ref&nbsp;BB&nbsp;(bb2&nbsp;*&nbsp;b2)&nbsp;y)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;ftype-pointer&nbsp;#x80000004&gt;<br>

(let&nbsp;([idx&nbsp;1])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;ftype-pointer&nbsp;#x80000030&gt;<br>

&nbsp;&nbsp;(ftype-&amp;ref&nbsp;BB&nbsp;(bb2&nbsp;idx&nbsp;b2)&nbsp;y))</tt>
<p>With no accessors and no index, as in the first use of <tt>ftype-&amp;ref</tt>
above, the returned <tt>ftype-pointer</tt> might be <tt>eq?</tt> to
the input.
Otherwise, the <tt>ftype-pointer</tt> is freshly allocated.

<p>
<a name="./foreign:s152"></a><a name="defn:ftype-set!"></a>
<span class=formdef><b>syntax</b>: <tt>(ftype-set!&nbsp;<i>ftype-name</i>&nbsp;(<i>a</i>&nbsp;...)&nbsp;<i>fptr-expr</i>&nbsp;<i>val-expr</i>)</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>(ftype-set!&nbsp;<i>ftype-name</i>&nbsp;(<i>a</i>&nbsp;...)&nbsp;<i>fptr-expr</i>&nbsp;<i>index</i>&nbsp;<i>val-expr</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br><span class=formdef><b>syntax</b>: <tt>(ftype-ref&nbsp;<i>ftype-name</i>&nbsp;(<i>a</i>&nbsp;...)&nbsp;<i>fptr-expr</i>)</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>(ftype-ref&nbsp;<i>ftype-name</i>&nbsp;(<i>a</i>&nbsp;...)&nbsp;<i>fptr-expr</i>&nbsp;<i>index</i>)</tt></span>
<br>
<b>returns: </b>an ftype-pointer object
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These forms are used to store values into or retrieve values from the
object pointed to by the value of <tt><i>fptr-expr</i></tt>, offset by
<tt><i>index</i></tt>, if present.
The value of <tt><i>fptr-expr</i></tt> must be
an ftype pointer (fptr) of the ftype identified by <tt><i>ftype-name</i></tt>,
and <tt><i>index</i></tt> must either be the identifier <tt>*</tt> or evaluate
to a fixnum, possibly negative.
The index is automatically scaled by the size of the ftype identified
by <tt><i>ftype-name</i></tt>, which allows the fptr to be treated as an array
of <tt><i>ftype-name</i></tt> objects and <tt><i>index</i></tt> as an index into that array.
An index of <tt>*</tt> or 0 is the same as no index.

<p>
The sequence of accessors <tt><i>a</i>&nbsp;...</tt> must specify a
valid path through the identified ftype.
For <tt>struct</tt>, <tt>union</tt>, and <tt>bits</tt> ftypes,
an accessor must be a valid field name for the ftype, while for
pointer and array ftypes, an accessor must be the identifier
<tt>*</tt> or evaluate to a fixnum index.
For array ftypes, an index must be nonnegative, and for array ftypes
with nonzero length, an index must also be less than the length.
The field or element specified by the sequence of accessors must be a scalar
field, e.g., a pointer field or a field containing a base type
such as an <tt>int</tt>, <tt>char</tt>, or <tt>double</tt>.

<p>
For <tt>ftype-set!</tt>, <tt><i>val-expr</i></tt> must evaluate to a value
of the appropriate type for the specified field, e.g., an ftype
pointer of the appropriate type or an appropriate base-type value.

<p>
For both signed and unsigned integer fields, values in the range
-2<sup><i>w</i>-1</sup> through 2<sup><i>w</i></sup> - 1 are accepted, where <i>w</i> is the width in
bits of the integer field.
For signed integer fields, values in the range 2<sup><i>w</i>-1</sup> through 2<sup><i>w</i></sup> - 1
are treated as two's complement representations of the corresponding
negative numbers.
For unsigned integer fields, values in the range -2<sup><i>w</i>-1</sup> through
-1 are similarly treated as two's complement representations of the
corresponding positive numbers.

<p>
<tt>char</tt> and <tt>wchar_t</tt> (<tt>wchar</tt>) field values
are converted from (<tt>ftype-set!</tt>) or to (<tt>ftype-ref</tt>)
Scheme characters, as if with <tt>char-&gt;integer</tt> and
<tt>integer-&gt;char</tt>.
Characters stored by <tt>ftype-set!</tt> into a <tt>char</tt>
field must have Unicode scalar values in the range 0 through 255.
Under Windows and any other system where <tt>wchar_t</tt>
(<tt>wchar</tt>) is a 16-bit value, characters stored by
<tt>ftype-set!</tt> into a <tt>whar_t</tt> (<tt>wchar</tt>)
field must have Unicode scalar values in the range 0 through 2<sup>16</sup> - 1.
On systems where <tt>wchar_t</tt> is a 32-bit value, any
character can be stored in a <tt>wchar_t</tt> (<tt>wchar</tt>)
field.

<p>
The examples below assume that <tt>B</tt> and <tt>C</tt> have been
defined as shown in the description of <tt>ftype-sizeof</tt> above.

<p>

<p><tt>(define&nbsp;b<br>

&nbsp;&nbsp;(make-ftype-pointer&nbsp;B<br>

&nbsp;&nbsp;&nbsp;&nbsp;(foreign-alloc<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(ftype-sizeof&nbsp;B)&nbsp;3))))<br>

(define&nbsp;c<br>

&nbsp;&nbsp;(make-ftype-pointer&nbsp;C<br>

&nbsp;&nbsp;&nbsp;&nbsp;(foreign-alloc&nbsp;(ftype-sizeof&nbsp;C))))
<br>
<br>
(ftype-set!&nbsp;B&nbsp;(b1)&nbsp;b&nbsp;5)<br>

(ftype-set!&nbsp;B&nbsp;(b1)&nbsp;b&nbsp;1&nbsp;6)<br>

(ftype-set!&nbsp;B&nbsp;(b1)&nbsp;c&nbsp;5)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;ftype&nbsp;mismatch</i><br>

(ftype-set!&nbsp;B&nbsp;(b2)&nbsp;b&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;not&nbsp;a&nbsp;scalar</i><br>

(ftype-set!&nbsp;B&nbsp;(b2&nbsp;-1)&nbsp;b&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;invalid&nbsp;index</i><br>

(ftype-set!&nbsp;B&nbsp;(b2&nbsp;0)&nbsp;b&nbsp;50)<br>

(ftype-set!&nbsp;B&nbsp;(b2&nbsp;4)&nbsp;b&nbsp;55)<br>

(ftype-set!&nbsp;B&nbsp;(b2&nbsp;10)&nbsp;b&nbsp;55)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;invalid&nbsp;index</i>
<br>
<br>
(ftype-set!&nbsp;C&nbsp;()&nbsp;c&nbsp;(ftype-&amp;ref&nbsp;B&nbsp;()&nbsp;b&nbsp;1))
<br>
<br>
(=&nbsp;(ftype-pointer-address&nbsp;(ftype-ref&nbsp;C&nbsp;()&nbsp;c))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

&nbsp;&nbsp;&nbsp;(+&nbsp;(ftype-pointer-address&nbsp;b)&nbsp;(ftype-sizeof&nbsp;B)))<br>

(=&nbsp;(ftype-pointer-address&nbsp;(ftype-&amp;ref&nbsp;C&nbsp;(*)&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

&nbsp;&nbsp;&nbsp;(+&nbsp;(ftype-pointer-address&nbsp;b)&nbsp;(ftype-sizeof&nbsp;B)))<br>

(=&nbsp;(ftype-pointer-address&nbsp;(ftype-&amp;ref&nbsp;C&nbsp;(-1)&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

&nbsp;&nbsp;&nbsp;(ftype-pointer-address&nbsp;b))
<br>
<br>
(ftype-ref&nbsp;C&nbsp;(-1&nbsp;b1)&nbsp;c)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;5<br>

(ftype-ref&nbsp;C&nbsp;(*&nbsp;b1)&nbsp;c)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;6<br>

(ftype-ref&nbsp;C&nbsp;(-1&nbsp;b2&nbsp;0)&nbsp;c)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;50<br>

(let&nbsp;([i&nbsp;4])&nbsp;(ftype-ref&nbsp;C&nbsp;(-1&nbsp;b2&nbsp;i)&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;55
<br>
<br>
(ftype-set!&nbsp;C&nbsp;(-1&nbsp;b2&nbsp;0)&nbsp;c&nbsp;75)<br>

(ftype-ref&nbsp;B&nbsp;(b2&nbsp;0)&nbsp;b)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;75<br>

(foreign-free&nbsp;(ftype-pointer-address&nbsp;c))<br>

(foreign-free&nbsp;(ftype-pointer-address&nbsp;b))</tt>
<p>A <a name="./foreign:s153"></a>function ftype pointer can be converted into
a Scheme-callable procedure via <tt>ftype-ref</tt>.
Assuming that a library defining <tt><i>memcpy</i></tt> has been loaded via
<tt>load-shared-object</tt> or <tt>memcpy</tt> has been registered
via one of the methods described in Section &nbsp;<a href="./foreign.html#g32">4.6</a>,
A Scheme-callable <tt>memcpy</tt> can be defined as follows.

<p>

<p><tt>(define-ftype&nbsp;bvcopy_t&nbsp;(function&nbsp;(u8*&nbsp;u8*&nbsp;size_t)&nbsp;void))<br>

(define&nbsp;bvcopy-fptr&nbsp;(make-ftype-pointer&nbsp;bvcopy_t&nbsp;"memcpy"))<br>

(define&nbsp;bvcopy&nbsp;(ftype-ref&nbsp;bvcopy_t&nbsp;()&nbsp;bvcopy-fptr))
<br>
<br>
(define&nbsp;bv1&nbsp;(make-bytevector&nbsp;8&nbsp;0))<br>

(define&nbsp;bv2&nbsp;(make-bytevector&nbsp;8&nbsp;57))<br>

bv1&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vu8(0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0)<br>

bv2&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vu8(57&nbsp;57&nbsp;57&nbsp;57&nbsp;57&nbsp;57&nbsp;57&nbsp;57)<br>

(bvcopy&nbsp;bv1&nbsp;bv2&nbsp;5)<br>

bv1&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vu8(57&nbsp;57&nbsp;57&nbsp;57&nbsp;57&nbsp;0&nbsp;0&nbsp;0)</tt>
<p>An ftype pointer can also be obtained as a return value from a
C function declared to return a pointer to a function ftype.

<p>
Thus, <tt>ftype-ref</tt> with a function ftype is an alternative to
<a name="./foreign:s154"></a><tt>foreign-procedure</tt>
(Section&nbsp;<a href="./foreign.html#g28">4.2</a>)
for creating Scheme-callable wrappers for
C functions.

<p>
<a name="./foreign:s155"></a><span class=formdef><b>procedure</b>: <tt>(ftype-pointer-ftype&nbsp;<i>fptr</i>)</tt></span>
<br>
<b>returns: </b><tt><i>fptr</i></tt>'s ftype, represented as an s-expression
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>fptr</i></tt> must be an ftype-pointer object.

<p>

<p><tt>(define-ftype&nbsp;Q0<br>

&nbsp;&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;[x&nbsp;int]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[y&nbsp;int]))<br>

(define-ftype&nbsp;Q1<br>

&nbsp;&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;[x&nbsp;double]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[y&nbsp;char]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[z&nbsp;(endian&nbsp;big<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bits<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[_&nbsp;unsigned&nbsp;3]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[a&nbsp;unsigned&nbsp;9]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[b&nbsp;unsigned&nbsp;4]))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[w&nbsp;(*&nbsp;Q0)]))<br>

(define&nbsp;q1&nbsp;(make-ftype-pointer&nbsp;Q1&nbsp;0))<br>

(ftype-pointer-ftype&nbsp;q1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(struct&nbsp;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;[x&nbsp;double]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;[y&nbsp;char]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;[z&nbsp;(endian&nbsp;big<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bits<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[_&nbsp;unsigned&nbsp;3]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[a&nbsp;unsigned&nbsp;9]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[b&nbsp;unsigned&nbsp;4]))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;[w&nbsp;(*&nbsp;Q0)])</tt>
<p><a name="./foreign:s156"></a><span class=formdef><b>procedure</b>: <tt>(ftype-pointer-&gt;sexpr&nbsp;<i>fptr</i>)</tt></span>
<br>
<b>returns: </b>an s-expression representation of the object to which <tt><i>fptr</i></tt> points
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>fptr</i></tt> must be an ftype-pointer object.

<p>
For each unnamed field, i.e., each whose field name is an underscore, the
corresponding field value in the resulting s-expression is also an underscore.
Similarly, if a field is inaccessible, i.e., if its address is invalid, the
value is the symbol <tt>invalid</tt>.

<p>

<p><tt>(define-ftype&nbsp;Frob<br>

&nbsp;&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;[p&nbsp;boolean]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[q&nbsp;char]))<br>

(define-ftype&nbsp;Snurk<br>

&nbsp;&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;[a&nbsp;Frob]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[b&nbsp;(*&nbsp;Frob)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[c&nbsp;(*&nbsp;Frob)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[d&nbsp;(bits<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[_&nbsp;unsigned&nbsp;15]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[dx&nbsp;signed&nbsp;17])]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[e&nbsp;(array&nbsp;5&nbsp;double)]))<br>

(define&nbsp;x<br>

&nbsp;&nbsp;(make-ftype-pointer&nbsp;Snurk<br>

&nbsp;&nbsp;&nbsp;&nbsp;(foreign-alloc&nbsp;(ftype-sizeof&nbsp;Snurk))))<br>

(ftype-set!&nbsp;Snurk&nbsp;(b)&nbsp;x<br>

&nbsp;&nbsp;(make-ftype-pointer&nbsp;Frob<br>

&nbsp;&nbsp;&nbsp;&nbsp;(foreign-alloc&nbsp;(ftype-sizeof&nbsp;Frob))))<br>

(ftype-set!&nbsp;Snurk&nbsp;(c)&nbsp;x<br>

&nbsp;&nbsp;(make-ftype-pointer&nbsp;Frob&nbsp;0))<br>

(ftype-set!&nbsp;Snurk&nbsp;(a&nbsp;p)&nbsp;x&nbsp;#t)<br>

(ftype-set!&nbsp;Snurk&nbsp;(a&nbsp;q)&nbsp;x&nbsp;#\A)<br>

(ftype-set!&nbsp;Snurk&nbsp;(b&nbsp;*&nbsp;p)&nbsp;x&nbsp;#f)<br>

(ftype-set!&nbsp;Snurk&nbsp;(b&nbsp;*&nbsp;q)&nbsp;x&nbsp;#\B)<br>

(ftype-set!&nbsp;Snurk&nbsp;(d&nbsp;dx)&nbsp;x&nbsp;-2500)<br>

(do&nbsp;([i&nbsp;0&nbsp;(fx+&nbsp;i&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;((fx=&nbsp;i&nbsp;5))<br>

&nbsp;&nbsp;(ftype-set!&nbsp;Snurk&nbsp;(e&nbsp;i)&nbsp;x&nbsp;(+&nbsp;(*&nbsp;i&nbsp;5.0)&nbsp;3.0)))<br>

(ftype-pointer-&gt;sexpr&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;[a&nbsp;(struct&nbsp;[p&nbsp;#t]&nbsp;[q&nbsp;#\A])]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;[b&nbsp;(*&nbsp;(struct&nbsp;[p&nbsp;#f]&nbsp;[q&nbsp;#\B]))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;[c&nbsp;(*&nbsp;(struct&nbsp;[p&nbsp;invalid]&nbsp;[q&nbsp;invalid]))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;[d&nbsp;(bits&nbsp;[_&nbsp;_]&nbsp;[dx&nbsp;-2500])]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;[e&nbsp;(array&nbsp;5&nbsp;3.0&nbsp;8.0&nbsp;13.0&nbsp;18.0&nbsp;23.0)])</tt>
<p>
<h3><a name="g32"></a><a name="./foreign:h6"></a>Section 4.6. Providing Access to Foreign Procedures<a name="SECTFOREIGNACCESS"></a></h3>



<p>
Access to foreign procedures can be provided in several ways:

<p>
<ul>
<li>Foreign procedures may be loaded from
"shared objects" using <tt>load-shared-object</tt>.

<p>
<li>A new <i>Chez&nbsp;Scheme</i> image can be built with additional foreign code
linked in.  (Consult with the person who installed <i>Chez&nbsp;Scheme</i> at
your site for details.)
These entries are typically registered via
<tt>Sforeign_symbol</tt> or <tt>Sregister_symbol</tt>,
documented in Section&nbsp;<a href="./foreign.html#g34">4.8</a>.

<p>
<li>Additional entries may be dynamically loaded or otherwise obtained
by foreign code.
These are also typically registered using
<tt>Sforeign_symbol</tt> or <tt>Sregister_symbol</tt>.

<p>
<li>The address of an entry, i.e., a function pointer, may be passed
into Scheme and used as the value of the entry expression in a
foreign-procedure expression.  
This allows foreign entry points to be used even when they are not
registered by name.  
</ul>
<p>



<p>
<a name="./foreign:s157"></a><span class=formdef><b>procedure</b>: <tt>(foreign-entry?&nbsp;<i>entry-name</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>entry-name</i></tt> is an existing foreign procedure entry
point, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>entry-name</i></tt> must be a string.
<tt>foreign-entry?</tt> may be used to determine if an entry exists for a foreign
procedure.

<p>
The following examples assume that 
a library that defines <tt><i>strlen</i></tt> has been loaded via
<tt>load-shared-object</tt> or that <tt>strlen</tt> has been registered
via one of the other methods described in this section.

<p>

<p><tt>(foreign-entry?&nbsp;"strlen")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

((foreign-procedure&nbsp;"strlen"<br>

&nbsp;&nbsp;&nbsp;&nbsp;(string)&nbsp;size_t)<br>

&nbsp;"hey!")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4</tt>
<p><a name="./foreign:s158"></a><span class=formdef><b>procedure</b>: <tt>(foreign-entry&nbsp;<i>entry-name</i>)</tt></span>
<br>
<b>returns: </b>the address of <tt><i>entry-name</i></tt> as an exact integer
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>entry-name</i></tt> must be a string naming an existing foreign entry point.

<p>
The following examples assume that 
a library that defines <tt><i>strlen</i></tt> has been loaded via
<tt>load-shared-object</tt> or that <tt>strlen</tt> has been registered
via one of the other methods described in this section.

<p>

<p><tt>(let&nbsp;([addr&nbsp;(foreign-entry&nbsp;"strlen")])<br>

&nbsp;&nbsp;(and&nbsp;(integer?&nbsp;addr)&nbsp;(exact?&nbsp;addr)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(define-ftype&nbsp;strlen-type&nbsp;(function&nbsp;(string)&nbsp;size_t))<br>

(define&nbsp;strlen<br>

&nbsp;&nbsp;(ftype-ref&nbsp;strlen-type&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(make-ftype-pointer&nbsp;strlen-type&nbsp;"strlen")))<br>

(strlen&nbsp;"hey!")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4</tt>
<p><a name="./foreign:s159"></a><span class=formdef><b>procedure</b>: <tt>(foreign-address-name&nbsp;<i>address</i>)</tt></span>
<br>
<b>returns: </b>the entry name corresponding to <tt><i>address</i></tt>, if known, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The following examples assume that 
a library that defines <tt><i>strlen</i></tt> has been loaded via
<tt>load-shared-object</tt> or that <tt>strlen</tt> has been registered
via one of the other methods described in this section.

<p>

<p><tt>(foreign-address-name&nbsp;(foreign-entry&nbsp;"strlen"))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"strlen"</tt>
<p><a name="./foreign:s160"></a><span class=formdef><b>procedure</b>: <tt>(load-shared-object&nbsp;<i>path</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt>load-shared-object</tt> loads the shared object named by <tt><i>path</i></tt>.
Shared objects may be system libraries or files created from ordinary
C programs.
All external symbols in the shared object, along with external symbols
available in other shared objects linked with the shared object,
are made available as foreign entries. 

<p>
This procedure is supported for most platforms upon which <i>Chez&nbsp;Scheme</i>
runs.

<p>
If <tt><i>path</i></tt> does not begin with a "." or "/", the shared
object is searched for in a default set of directories determined
by the system.

<p>
On most Unix systems, <tt>load-shared-object</tt> is based on the
system routine <tt>dlopen</tt>.
Under Windows, <tt>load-shared-object</tt> is based on <tt>LoadLibrary</tt>.
Refer to the documentation for these routines and for the C compiler
and loader for precise rules for locating and building shared objects.

<p>
<tt>load-shared-object</tt> can be used to access built-in C library
functions, such as <tt>getenv</tt>.
The name of the shared object varies from one system to another.
On Linux systems:

<p>

<p><tt>(load-shared-object&nbsp;"libc.so.6")</tt>
<p>On Solaris, OpenSolaris, FreeBSD, NetBSD, and OpenBSD systems:

<p>

<p><tt>(load-shared-object&nbsp;"libc.so")</tt>
<p>On MacOS X systems:

<p>

<p><tt>(load-shared-object&nbsp;"libc.dylib")</tt>
<p>On Windows:

<p>

<p><tt>(load-shared-object&nbsp;"crtdll.dll")</tt>
<p>Once the C library has been loaded, <tt>getenv</tt> should be available
as a foreign entry.

<p>

<p><tt>(foreign-entry?&nbsp;"getenv")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p>An equivalent Scheme procedure may be defined and
invoked as follows.

<p>

<p><tt>(define&nbsp;getenv<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"getenv"<br>

&nbsp;&nbsp;&nbsp;&nbsp;(string)<br>

&nbsp;&nbsp;&nbsp;&nbsp;string))<br>

(getenv&nbsp;"HOME")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"/home/elmer/fudd"<br>

(getenv&nbsp;"home")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><tt>load-shared-object</tt> can be used to access user-created
libraries as well.
Suppose the <a name="./foreign:s161"></a>C file <tt>"even.c"</tt>
contains

<p>

<p><tt>int&nbsp;even(n)&nbsp;int&nbsp;n;&nbsp;&#123;&nbsp;return&nbsp;n&nbsp;==&nbsp;0&nbsp;||&nbsp;odd(n&nbsp;-&nbsp;1);&nbsp;&#125;</tt>
<p>and the C file <tt>"odd.c"</tt> contains

<p>

<p><tt>int&nbsp;odd(n)&nbsp;int&nbsp;n;&nbsp;&#123;&nbsp;return&nbsp;n&nbsp;!=&nbsp;0&nbsp;&amp;&amp;&nbsp;even(n&nbsp;-&nbsp;1);&nbsp;&#125;</tt>
<p>The files must be compiled and linked into a shared object before
they can be loaded.
How this is done depends upon the host system.
On Linux, FreeBSD, OpenBSD, and OpenSolaris systems:

<p>

<p><tt>(system&nbsp;"cc&nbsp;-fPIC&nbsp;-shared&nbsp;-o&nbsp;evenodd.so&nbsp;even.c&nbsp;odd.c")</tt>
<p>Depending on the host configuration, the <tt>-m32</tt> or
<tt>-m64</tt> option might be needed to specify 32-bit
or 64-bit compilation as appropriate.

<p>
On MacOS X (Intel or PowerPC) systems:

<p>

<p><tt>(system&nbsp;"cc&nbsp;-dynamiclib&nbsp;-o&nbsp;evenodd.so&nbsp;even.c&nbsp;odd.c")</tt>
<p>Depending on the host configuration, the <tt>-m32</tt> or
<tt>-m64</tt> option might be needed to specify 32-bit
or 64-bit compilation as appropriate.

<p>
On 32-bit Sparc Solaris:

<p>

<p><tt>(system&nbsp;"cc&nbsp;-KPIC&nbsp;-G&nbsp;-o&nbsp;evenodd.so&nbsp;even.c&nbsp;odd.c")</tt>
<p>On 64-bit Sparc Solaris:

<p>

<p><tt>(system&nbsp;"cc&nbsp;-xarch=v9&nbsp;-KPIC&nbsp;-G&nbsp;-o&nbsp;evenodd.so&nbsp;even.c&nbsp;odd.c")</tt>
<p>On Windows, we build a DLL (dynamic link library) file.
In order to make the compiler generate the appropriate entry
points, we alter <tt>even.c</tt> to read

<p>

<p><tt>#ifdef&nbsp;WIN32<br>

#define&nbsp;EXPORT&nbsp;extern&nbsp;__declspec&nbsp;(dllexport)<br>

#else<br>

#define&nbsp;EXPORT&nbsp;extern<br>

#endif
<br>
<br>
EXPORT&nbsp;int&nbsp;even(n)&nbsp;int&nbsp;n;&nbsp;&#123;&nbsp;return&nbsp;n&nbsp;==&nbsp;0&nbsp;||&nbsp;odd(n&nbsp;-&nbsp;1);&nbsp;&#125;</tt>
<p>and <tt>odd.c</tt> to read

<p>

<p><tt>#ifdef&nbsp;WIN32<br>

#define&nbsp;EXPORT&nbsp;extern&nbsp;__declspec&nbsp;(dllexport)<br>

#else<br>

#define&nbsp;EXPORT&nbsp;extern<br>

#endif
<br>
<br>
EXPORT&nbsp;int&nbsp;odd(n)&nbsp;int&nbsp;n;&nbsp;&#123;&nbsp;return&nbsp;n&nbsp;!=&nbsp;0&nbsp;&amp;&amp;&nbsp;even(n&nbsp;-&nbsp;1);&nbsp;&#125;</tt>
<p>We can then build the DLL as follows, giving
it the extension ".so" rather than ".dll"
for consistency with the other systems.

<p>

<p><tt>(system&nbsp;"cl&nbsp;-c&nbsp;-DWIN32&nbsp;even.c")<br>

(system&nbsp;"cl&nbsp;-c&nbsp;-DWIN32&nbsp;odd.c")<br>

(system&nbsp;"link&nbsp;-dll&nbsp;-out:evenodd.so&nbsp;even.obj&nbsp;odd.obj")</tt>
<p><p>The resulting ".so" file can be loaded into Scheme and <tt>even</tt> and
<tt>odd</tt> made available as foreign procedures:

<p>

<p><tt>(load-shared-object&nbsp;"./evenodd.so")<br>

(let&nbsp;([odd&nbsp;(foreign-procedure&nbsp;"odd"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(integer-32)&nbsp;boolean)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[even&nbsp;(foreign-procedure&nbsp;"even"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(integer-32)&nbsp;boolean)])<br>

&nbsp;&nbsp;(list&nbsp;(even&nbsp;100)&nbsp;(odd&nbsp;100)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(#t&nbsp;#f)</tt>
<p>The filename is given as <tt>"./evenodd.so"</tt> rather than simply
<tt>"evenodd.so"</tt>, because some systems look for shared libraries
in a standard set of system directories that does not include the
current directory.


<p>
<a name="./foreign:s162"></a><span class=formdef><b>procedure</b>: <tt>(remove-foreign-entry&nbsp;<i>entry-name</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>remove-foreign-entry</tt> blocks further access to the entry
specified by the string <tt><i>entry-name</i></tt>.
An exception is raised with condition type <tt>&amp;assertion</tt>
if the entry does not exist.
Since access previously established by <tt>foreign-procedure</tt> is not affected,
<tt>remove-foreign-entry</tt> may be used to clean up after the desired interface
to a group of foreign procedures has been established.

<p>
<tt>remove-foreign-entry</tt> can be used to remove entries registered using
<tt>Sforeign_symbol</tt> and <tt>Sregister_symbol</tt> but not
entries created as
a result of a call to <tt>load-shared-object</tt>.


<p>

<h3><a name="g33"></a><a name="./foreign:h7"></a>Section 4.7. Using Other Foreign Languages<a name="SECTFOREIGNOTHER"></a></h3>



<p>
Although the <i>Chez&nbsp;Scheme</i> foreign procedure interface is oriented primarily
toward procedures defined in C or available in C libraries, it
is possible to invoke procedures defined in other languages that follow C
calling conventions.
One source of difficulty may be the interpretation of names.
Since <a name="./foreign:s163"></a>Unix-based <a name="./foreign:s164"></a>C compilers often prepend an underscore to external
names,
the foreign interface attempts to interpret entry names in
a manner consistent with the host C compiler.
Occasionally, such as for assembly coded files, this entry
name interpretation may not be desired.
It can be prevented by prefixing the entry name with an "=" character.
For example, after loading an assembly file containing a procedure <tt>"foo"</tt>
one might have<a name="./foreign:s165"></a>:

<p>

<p><tt>(foreign-entry?&nbsp;"foo")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(foreign-entry?&nbsp;"=foo")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p>
<h3><a name="g34"></a><a name="./foreign:h8"></a>Section 4.8. C Library Routines<a name="SECTFOREIGNCLIB"></a></h3>



<p>
Additional foreign interface support is provided via a set of
<a name="./foreign:s166"></a><a name="./foreign:s167"></a>C
preprocessor macros and
<a name="./foreign:s168"></a>C-callable library functions.
Some of these routines allow C programs to examine,
allocate, and alter Scheme objects.
Others permit C functions to call Scheme procedures via a
more primitive interface than that defined in
Section&nbsp;<a href="./foreign.html#g29">4.3</a>.
Still others permit the development of custom executable images
and use of the Scheme system as a subordinate program within
another program, e.g., for use as an extension language.

<p>
C code that uses these routines must include the <tt>"scheme.h"</tt>
header file distributed with <i>Chez&nbsp;Scheme</i> and must be linked
(statically or dynamically) with the <i>Chez&nbsp;Scheme</i> kernel.
The header file contains definitions for the preprocessor macros and
<tt>extern</tt> declarations for the library functions.
The file is customized to the release of <i>Chez&nbsp;Scheme</i> and machine
type with which it is distributed; it
should be left unmodified to facilitate switching among <i>Chez&nbsp;Scheme</i>
releases, and the proper version of the header file should always be
used with C code compiled for use with a particular version of
<i>Chez&nbsp;Scheme</i>.
The version and machine type are defined in <tt>"scheme.h"</tt>
under the names <tt>VERSION</tt> and <tt>MACHINE_TYPE</tt>.

<p>
The name of each routine begins with a capital <tt>S</tt>, e.g.,
<tt>Sfixnump</tt>.
Many of the names are simple translations of the names of closely
related Scheme procedures, e.g., <tt>Sstring_to_symbol</tt> is the C
interface equivalent of <tt>string-&gt;symbol</tt>.
Most externally visible entries in the <i>Chez&nbsp;Scheme</i> executable that
are not documented here begin with capital <tt>S</tt> followed by an
underscore (<tt>S_</tt>); their use should be avoided.

<p>
In addition to the various macros and external declarations given
in <tt>scheme.h</tt>, the header file also defines (<tt>typedefs</tt>)
several types used in the header file:

<p>
<ul>
<li><tt>ptr</tt>: type of a Scheme value,

<p>
<li><tt>iptr</tt>: a signed integer the same size as a Scheme value, and

<p>
<li><tt>uptr</tt>: an unsigned integer the same size as a Scheme value.

<p>
<li><tt>string_char</tt>: type of a single Scheme string element.

<p>
<li><tt>octet</tt>: type of a single Scheme bytevector element (unsigned char).
</ul>
<p>

<p>
These types may vary depending upon the platform, although <tt>ptr</tt>
is typically <tt>void&nbsp;*</tt>, <tt>iptr</tt> is typically <tt>long</tt> <tt>int</tt>,
and <tt>uptr</tt> is typically <tt>unsigned</tt> <tt>long</tt> <tt>int</tt>.

<p>
Under Windows, defining <tt>SCHEME_IMPORT</tt> before including scheme.h
causes scheme.h to declare its entry points using
<tt>extern</tt> <tt>declspec</tt> <tt>(dllimport)</tt> rather than
<tt>extern</tt> <tt>declspec</tt> <tt>(dllexport)</tt> (the default).
Not defining <tt>SCHEME_IMPORT</tt> and instead defining <tt>SCHEME_STATIC</tt>
causes scheme.h to declare exports using just <tt>extern</tt>.
The static libraries distributed with Chez Scheme are built using
<tt>SCHEME_STATIC</tt>.

<p>
The remainder of this section describes each of the C interface
routines in turn.
A declaration for each routine is given in ANSI C function prototype
notation to precisely specify the argument and result types.
Scheme objects have the C type <tt>ptr</tt>, which is defined in
<tt>"scheme.h"</tt>.
Where appropriate, C values are accepted as arguments or returned as
values in place of Scheme objects.

<p>
The preprocessor macros may evaluate their arguments more than once
(or not at all), so care should be taken to ensure that this does not
cause problems.







<p>
<p><b>Customization.</b>&nbsp;&nbsp;The functions described here are used to initialize the Scheme system,
build the Scheme heap, and run the Scheme system from a separate
program.

<p>
<a name="./foreign:s169"></a>[func] <tt>char&nbsp;*</tt> <tt>Skernel_version</tt><tt>(void)</tt><br>

<a name="./foreign:s170"></a>[func] <tt>void</tt> <tt>Sscheme_init</tt><tt>(void&nbsp;(*<i>abnormal</i>_<i>exit</i>)(void))</tt><br>

<a name="./foreign:s171"></a>[func] <tt>void</tt> <tt>Sset_verbose</tt><tt>(int&nbsp;<i>v</i>)</tt><br>

<a name="./foreign:s172"></a>[func] <tt>void</tt> <tt>Sregister_boot_file</tt><tt>(const&nbsp;char&nbsp;*<i>name</i>)</tt><br>

<a name="./foreign:s173"></a>[func] <tt>void</tt> <tt>Sregister_boot_file_fd</tt><tt>(const&nbsp;char&nbsp;*<i>name</i>,&nbsp;int&nbsp;<i>fd</i>)</tt><br>

<a name="./foreign:s174"></a>[func] <tt>void</tt> <tt>Sbuild_heap</tt><tt>(const&nbsp;char&nbsp;*<i>exec</i>,&nbsp;void&nbsp;(*<i>custom</i>_<i>init</i>)(void))</tt><br>

<a name="./foreign:s175"></a>[func] <tt>void</tt> <tt>Senable_expeditor</tt><tt>(const&nbsp;char&nbsp;*<i>history</i>_<i>file</i>)</tt><br>

<a name="./foreign:s176"></a>[func] <tt>void</tt> <tt>Sretain_static_relocation</tt><tt>(void)</tt><br>

<a name="./foreign:s177"></a>[func] <tt>int</tt> <tt>Sscheme_start</tt><tt>(int&nbsp;<i>argc</i>,&nbsp;char&nbsp;*<i>argv</i>[])</tt><br>

<a name="./foreign:s178"></a>[func] <tt>int</tt> <tt>Sscheme_script</tt><tt>(char&nbsp;*<i>scriptfile</i>,&nbsp;int&nbsp;<i>argc</i>,&nbsp;char&nbsp;*<i>argv</i>[])</tt><br>

<a name="./foreign:s179"></a>[func] <tt>int</tt> <tt>Sscheme_program</tt><tt>(char&nbsp;*<i>programfile</i>,&nbsp;int&nbsp;<i>argc</i>,&nbsp;char&nbsp;*<i>argv</i>[])</tt><br>

<a name="./foreign:s180"></a>[func] <tt>void</tt> <tt>Scompact_heap</tt><tt>(void)</tt><br>

<a name="./foreign:s181"></a>[func] <tt>void</tt> <tt>Sscheme_deinit</tt><tt>(void)</tt><br>


<p>
<tt>Skernel_version</tt> returns a string representing the Scheme
version.
It should be compared against the value of the VERSION preprocessor
macro before any of the initialization functions listed above are
used to verify that the correct <tt>"scheme.h"</tt> header file has
been used.

<p>
<tt>Sscheme_init</tt> causes the Scheme system to
initialize its static memory in preparation for boot file
registration.
The <tt><i>abnormal</i>_<i>exit</i></tt> parameter should be a (possibly null)
pointer to a C function
of no arguments that takes appropriate action if the initialization or
subsequent heap-building process fails.
If null, the default action is to call <tt>exit(1)</tt>.

<p>
<tt>Sset_verbose</tt> sets verbose mode on for nonzero
values of <tt><i>v</i></tt> and off when <tt><i>v</i></tt> is zero.
In verbose mode, the system displays a trace of the search process
for subsequently registered boot files.

<p>
<tt>Sregister_boot_file</tt> searches for
the named boot file and
register it for loading, while <tt>Sregister_boot_file_fd</tt>
provides a specific boot file as a file descriptor.
When only a boot file name is provided, the file is opened but not loaded until the heap is built via
<tt>Sbuild_heap</tt>. When a file descriptor is provided, the given file name
is used only for error reporting.
For the first boot file registered only, the system also
searches for the boot files upon which the named file
depends, either directly or indirectly.

<p>
<tt>Sbuild_heap</tt> creates the Scheme heap from the registered boot
files.
<tt><i>exec</i></tt> is assumed to be the name of or path to the executable
image and is used when no boot files have been registered as
the base name for the boot-file search process.
<tt><i>exec</i></tt> may be null only if one or more boot files have
been registered.
<tt><i>custom</i>_<i>init</i></tt> must be a (possibly null) pointer to
a C function of no arguments; if non-null, it is called before any boot
files are loaded.

<p>
<tt>Sscheme_start</tt> invokes the interactive startup procedure, i.e., 
the value of the parameter <tt>scheme-start</tt>, with one Scheme
string argument for the first <tt><i>argc</i></tt> elements of <tt><i>argv</i></tt>,
not including <tt>argv[0]</tt>.
<tt>Sscheme_script</tt> similarly invokes the script startup
procedure, i.e., 
the value of the parameter <tt>scheme-script</tt>, with one Scheme
string argument for <tt><i>scriptfile</i></tt> and the first <tt><i>argc</i></tt> elements
of <tt><i>argv</i></tt>,
not including <tt>argv[0]</tt>.
<tt>Sscheme_program</tt> similarly invokes the program startup
procedure, i.e., 
the value of the parameter <tt>scheme-program</tt>, with one Scheme
string argument for <tt><i>programfile</i></tt> and the first <tt><i>argc</i></tt> elements
of <tt><i>argv</i></tt>,
not including <tt>argv[0]</tt>.

<p>
<tt>Senable_expeditor</tt> enables the expression editor
(Section&nbsp;<a href="./use.html#g7">2.2</a>, Chapter&nbsp;<a href="./expeditor.html#g132">14</a>),
which is disabled by default,
and determines the history file from which it restores and to
which it saves the history.
This procedure must be called after the heap is built, or
an error will result.
It must also be called before <tt>Sscheme_start</tt> in order
to be effective.
If the <tt><i>history</i>_<i>file</i></tt> argument is the null pointer, the
history is not restored or saved.
The preprocessor variable <tt>FEATURE_EXPEDITOR</tt> is defined
in <tt>scheme.h</tt> if support for the expression editor has
been compiled into the system.

<p>
<tt>Sretain_static_relocation</tt> causes relocation information
to be retained for static generation code objects created by
heap compaction for the benefit of <tt>compute-size</tt> and
related procedures.

<p>
<tt>Scompact_heap</tt> compacts the Scheme heap and places all objects
currently in the heap into a <i>static</i> generation.
Objects in the static generation are never collected.
That is, they are never moved during collection and the storage used
for them is never reclaimed even if they become inaccessible.
<tt>Scompact_heap</tt> is called implicitly after any boot files have been
loaded.

<p>
<tt>Sscheme_deinit</tt> closes any open files, tears down the Scheme heap,
and puts the Scheme system in an uninitialized state.


<p>
<p><b>Predicates.</b>&nbsp;&nbsp;The predicates described here correspond to the similarly named
Scheme predicates.
A trailing letter <tt>p</tt>, for "predicate," is used in place of
the question mark that customarily appears at the end of a Scheme
predicate name.
Each predicate accepts a single Scheme object and returns a boolean
(C integer) value.

<p>

<a name="./foreign:s182"></a>[macro] <tt>int</tt> <tt>Sfixnump</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s183"></a>[macro] <tt>int</tt> <tt>Scharp</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s184"></a>[macro] <tt>int</tt> <tt>Snullp</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s185"></a>[macro] <tt>int</tt> <tt>Seof_objectp</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s186"></a>[macro] <tt>int</tt> <tt>Sbwp_objectp</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s187"></a>[macro] <tt>int</tt> <tt>Sbooleanp</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s188"></a>[macro] <tt>int</tt> <tt>Spairp</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s189"></a>[macro] <tt>int</tt> <tt>Ssymbolp</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s190"></a>[macro] <tt>int</tt> <tt>Sprocedurep</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s191"></a>[macro] <tt>int</tt> <tt>Sflonump</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s192"></a>[macro] <tt>int</tt> <tt>Svectorp</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s193"></a>[macro] <tt>int</tt> <tt>Sbytevectorp</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s194"></a>[macro] <tt>int</tt> <tt>Sfxvectorp</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s195"></a>[macro] <tt>int</tt> <tt>Sstringp</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s196"></a>[macro] <tt>int</tt> <tt>Sbignump</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s197"></a>[macro] <tt>int</tt> <tt>Sboxp</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s198"></a>[macro] <tt>int</tt> <tt>Sinexactnump</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s199"></a>[macro] <tt>int</tt> <tt>Sexactnump</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s200"></a>[macro] <tt>int</tt> <tt>Sratnump</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s201"></a>[macro] <tt>int</tt> <tt>Sinputportp</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s202"></a>[macro] <tt>int</tt> <tt>Soutputportp</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s203"></a>[macro] <tt>int</tt> <tt>Srecordp</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>



<p>
<p><b>Accessors.</b>&nbsp;&nbsp;Some of the accessors described here correspond to similarly named
Scheme procedures, while others are unique to this interface.
<tt>Sfixnum_value</tt>, <tt>Schar_value</tt>, <tt>Sboolean_value</tt>,
and <tt>Sflonum_value</tt> return the C equivalents of the given
Scheme value.

<p>

<a name="./foreign:s204"></a>[macro] <tt>iptr</tt> <tt>Sfixnum_value</tt><tt>(ptr&nbsp;<i>fixnum</i>)</tt><br>

<a name="./foreign:s205"></a>[macro] <tt>uptr</tt> <tt>Schar_value</tt><tt>(ptr&nbsp;<i>character</i>)</tt><br>

<a name="./foreign:s206"></a>[macro] <tt>int</tt> <tt>Sboolean_value</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s207"></a>[macro] <tt>double</tt> <tt>Sflonum_value</tt><tt>(ptr&nbsp;<i>flonum</i>)</tt><br>



<p>
<tt>Sinteger_value</tt> and <tt>Sunsigned_value</tt> are similar to
<tt>Sfixnum_value</tt>, except they accept not only fixnum arguments
but bignum arguments in the range of C integer or unsigned values.
<tt>Sinteger_value</tt> and <tt>Sunsigned_value</tt> accept the same
range of Scheme integer values.
They differ only in the result type, and so allow differing
interpretations of negative and large unsigned values.

<p>

<a name="./foreign:s208"></a>[func] <tt>iptr</tt> <tt>Sinteger_value</tt><tt>(ptr&nbsp;<i>integer</i>)</tt><br>

<a name="./foreign:s209"></a>[macro] <tt>uptr</tt> <tt>Sunsigned_value</tt><tt>(ptr&nbsp;<i>integer</i>)</tt><br>



<p>
<tt>Sinteger32_value</tt>, <tt>Sunsigned32_value</tt>,
<tt>Sinteger64_value</tt>, and <tt>Sunsigned64_value</tt>
accept signed or unsigned Scheme integers in the 32-
or 64-bit range and return integers of the appropriate
type for the machine type.

<p>

<a name="./foreign:s210"></a>[func] <tt>&lt;32-bit&nbsp;int&nbsp;type&gt;</tt> <tt>Sinteger32_value</tt><tt>(ptr&nbsp;<i>integer</i>)</tt><br>

<a name="./foreign:s211"></a>[macro] <tt>&lt;32-bit&nbsp;unsigned&nbsp;type&gt;</tt> <tt>Sunsigned32_value</tt><tt>(ptr&nbsp;<i>integer</i>)</tt><br>

<a name="./foreign:s212"></a>[func] <tt>&lt;64-bit&nbsp;int&nbsp;type&gt;</tt> <tt>Sinteger64_value</tt><tt>(ptr&nbsp;<i>integer</i>)</tt><br>

<a name="./foreign:s213"></a>[macro] <tt>&lt;64-bit&nbsp;unsigned&nbsp;type&gt;</tt> <tt>Sunsigned64_value</tt><tt>(ptr&nbsp;<i>integer</i>)</tt><br>



<p>
<tt>Scar</tt>, <tt>Scdr</tt>, <tt>Ssymbol_to_string</tt> (corresponding
to <tt>symbol-&gt;string</tt>), and <tt>Sunbox</tt> are identical to their
Scheme counterparts.

<p>

<a name="./foreign:s214"></a>[macro] <tt>ptr</tt> <tt>Scar</tt><tt>(ptr&nbsp;<i>pair</i>)</tt><br>

<a name="./foreign:s215"></a>[macro] <tt>ptr</tt> <tt>Scdr</tt><tt>(ptr&nbsp;<i>pair</i>)</tt><br>

<a name="./foreign:s216"></a>[macro] <tt>ptr</tt> <tt>Ssymbol_to_string</tt><tt>(ptr&nbsp;<i>sym</i>)</tt><br>

<a name="./foreign:s217"></a>[macro] <tt>ptr</tt> <tt>Sunbox</tt><tt>(ptr&nbsp;<i>box</i>)</tt><br>



<p>
<tt>Sstring_length</tt>, <tt>Svector_length</tt>,
<tt>Sbytevector_length</tt>, and
<tt>Sfxvector_length</tt> each return a C integer representing the length
(in elements) of the object.

<p>

<a name="./foreign:s218"></a>[macro] <tt>iptr</tt> <tt>Sstring_length</tt><tt>(ptr&nbsp;<i>str</i>)</tt><br>

<a name="./foreign:s219"></a>[macro] <tt>iptr</tt> <tt>Svector_length</tt><tt>(ptr&nbsp;<i>vec</i>)</tt><br>

<a name="./foreign:s220"></a>[macro] <tt>iptr</tt> <tt>Sbytevector_length</tt><tt>(ptr&nbsp;<i>bytevec</i>)</tt><br>

<a name="./foreign:s221"></a>[macro] <tt>iptr</tt> <tt>Sfxvector_length</tt><tt>(ptr&nbsp;<i>fxvec</i>)</tt><br>



<p>
<tt>Sstring_ref</tt>, <tt>Svector_ref</tt>, <tt>Sbytevector_u8_ref</tt>,
and <tt>Sfxvector_ref</tt>
correspond to their Scheme counterparts, except that the index arguments
are C integers, the return value for <tt>Sstring_ref</tt> is a C
character, and the return value for <tt>Sbytevector_u8_ref</tt> is an
octet (unsigned char).

<p>

<a name="./foreign:s222"></a>[macro] <tt>char</tt> <tt>Sstring_ref</tt><tt>(ptr&nbsp;<i>str</i>,&nbsp;iptr&nbsp;<i>i</i>)</tt><br>

<a name="./foreign:s223"></a>[macro] <tt>ptr</tt> <tt>Svector_ref</tt><tt>(ptr&nbsp;<i>vec</i>,&nbsp;iptr&nbsp;<i>i</i>)</tt><br>

<a name="./foreign:s224"></a>[macro] <tt>octet</tt> <tt>Sbytevector_u8_ref</tt><tt>(ptr&nbsp;<i>fxvec</i>,&nbsp;iptr&nbsp;<i>i</i>)</tt><br>

<a name="./foreign:s225"></a>[macro] <tt>ptr</tt> <tt>Sfxvector_ref</tt><tt>(ptr&nbsp;<i>fxvec</i>,&nbsp;iptr&nbsp;<i>i</i>)</tt><br>



<p>
A Scheme bytevector is represented as a length field followed by a
sequence of octets (unsignec chars).
<tt>Sbytevector_data</tt> returns a pointer to the start of the sequence
of octets.
Extreme care should be taken to stop dereferencing the pointer returned by
<tt>Sbytevector_data</tt> or to lock the bytevector into memory (see
<tt>Slock_object</tt> below) before any Scheme code is executed,
whether by calling into Scheme or returning to a Scheme caller.
The storage manager may otherwise relocate or discard the object into which
the pointer points and may copy other data over the object.

<p>

<a name="./foreign:s226"></a>[macro] <tt>octet&nbsp;*</tt> <tt>Sbytevector_data</tt><tt>(ptr&nbsp;<i>bytevec</i>)</tt><br>



<p>
<p><b>Mutators.</b>&nbsp;&nbsp;Changes to mutable objects that contain pointers, such as pairs and
vectors, must be tracked on behalf of the storage
manager, as described in one of the references&nbsp;[<a class=citation href="./bibliography.html#g164">13</a>].
The operations described here perform this tracking automatically
where necessary.

<p>

<a name="./foreign:s227"></a>[func] <tt>void</tt> <tt>Sset_box</tt><tt>(ptr&nbsp;<i>box</i>,&nbsp;ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s228"></a>[func] <tt>void</tt> <tt>Sset_car</tt><tt>(ptr&nbsp;<i>pair</i>,&nbsp;ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s229"></a>[func] <tt>void</tt> <tt>Sset_cdr</tt><tt>(ptr&nbsp;<i>pair</i>,&nbsp;ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s230"></a>[macro] <tt>void</tt> <tt>Sstring_set</tt><tt>(ptr&nbsp;<i>str</i>,&nbsp;iptr&nbsp;<i>i</i>,&nbsp;char&nbsp;<i>c</i>)</tt><br>

<a name="./foreign:s231"></a>[func] <tt>void</tt> <tt>Svector_set</tt><tt>(ptr&nbsp;<i>vec</i>,&nbsp;iptr&nbsp;<i>i</i>,&nbsp;ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s232"></a>[macro] <tt>void</tt> <tt>Sbytevector_u8_set</tt><tt>(ptr&nbsp;<i>bytevec</i>,&nbsp;iptr&nbsp;<i>i</i>,&nbsp;octet&nbsp;<i>n</i>)</tt><br>

<a name="./foreign:s233"></a>[macro] <tt>void</tt> <tt>Sfxvector_set</tt><tt>(ptr&nbsp;<i>fxvec</i>,&nbsp;iptr&nbsp;<i>i</i>,&nbsp;ptr&nbsp;<i>fixnum</i>)</tt><br>



<p>
Some Scheme objects, such as procedures and numbers,
are not mutable, so no operators are provided for altering
the contents of those objects.

<p>
<p><b>Constructors.</b>&nbsp;&nbsp;The constructors described here create Scheme objects.
Some objects, such as fixnums and the empty list, are
represented as immediate values that do not require any heap
allocation; others, such as pairs and vectors, are represented
as pointers to heap allocated objects.

<p>
<tt>Snil</tt>, <tt>Strue</tt>, <tt>Sfalse</tt>, <tt>Sbwp_object</tt>,
<tt>Seof_object</tt>, and
<tt>Svoid</tt>
construct constant immediate values representing
the empty list (&nbsp;<tt>()</tt>&nbsp;), the boolean values (<tt>#t</tt> and
<tt>#f</tt>), the broken-weak-pointer object (<tt>#!bwp</tt>),
the eof object (<tt>#!eof</tt>), and the void object.

<p>

<a name="./foreign:s234"></a>[macro] <tt>ptr</tt> <tt>Snil</tt><br>

<a name="./foreign:s235"></a>[macro] <tt>ptr</tt> <tt>Strue</tt><br>

<a name="./foreign:s236"></a>[macro] <tt>ptr</tt> <tt>Sfalse</tt><br>

<a name="./foreign:s237"></a>[macro] <tt>ptr</tt> <tt>Sbwp_object</tt><br>

<a name="./foreign:s238"></a>[macro] <tt>ptr</tt> <tt>Seof_object</tt><br>

<a name="./foreign:s239"></a>[macro] <tt>ptr</tt> <tt>Svoid</tt><br>



<p>
Fixnums, characters, booleans, flonums, and strings may be created from
their C equivalents.

<p>

<a name="./foreign:s240"></a>[macro] <tt>ptr</tt> <tt>Sfixnum</tt><tt>(iptr&nbsp;<i>n</i>)</tt><br>

<a name="./foreign:s241"></a>[macro] <tt>ptr</tt> <tt>Schar</tt><tt>(char&nbsp;<i>c</i>)</tt><br>

<a name="./foreign:s242"></a>[macro] <tt>ptr</tt> <tt>Sboolean</tt><tt>(int&nbsp;<i>b</i>)</tt><br>

<a name="./foreign:s243"></a>[func] <tt>ptr</tt> <tt>Sflonum</tt><tt>(double&nbsp;x)</tt><br>

<a name="./foreign:s244"></a>[func] <tt>ptr</tt> <tt>Sstring</tt><tt>(const&nbsp;char&nbsp;*<i>s</i>)</tt><br>

<a name="./foreign:s245"></a>[func] <tt>ptr</tt> <tt>Sstring_of_length</tt><tt>(const&nbsp;char&nbsp;*<i>s</i>,&nbsp;iptr&nbsp;<i>n</i>)</tt><br>

<a name="./foreign:s246"></a>[func] <tt>ptr</tt> <tt>Sstring_utf8</tt><tt>(const&nbsp;char&nbsp;*<i>s</i>,&nbsp;iptr&nbsp;<i>n</i>)</tt><br>
;


<p>
<tt>Sstring</tt> creates a Scheme copy of the C string <tt><i>s</i></tt>, while
<tt>Sstring_of_length</tt> creates a Scheme string of length <tt><i>n</i></tt>
and copies the first <tt><i>n</i></tt> bytes from <tt><i>s</i></tt>
into the new Scheme string.

<p>
If the C string is encoded in UTF-8, use <tt>Sstring_utf8</tt>
instead. Specify the number of bytes to convert as <tt><i>n</i></tt> or use -1
to convert until the null terminator.

<p>
It is possible to determine whether a C integer is within fixnum range
by comparing the fixnum value of a fixnum created from a C integer with
the C integer:

<p>

<p><tt>#define&nbsp;fixnum_rangep(x)&nbsp;(Sfixnum_value(Sfixnum(x))&nbsp;==&nbsp;x)</tt>
<p><tt>Sinteger</tt> and <tt>Sunsigned</tt> may be used to create Scheme
integers whether they are in fixnum range or not.

<p>

<a name="./foreign:s247"></a>[func] <tt>ptr</tt> <tt>Sinteger</tt><tt>(iptr&nbsp;<i>n</i>)</tt><br>

<a name="./foreign:s248"></a>[func] <tt>ptr</tt> <tt>Sunsigned</tt><tt>(uptr&nbsp;<i>n</i>)</tt><br>



<p>
<tt>Sinteger</tt> and <tt>Sunsigned</tt> differ in their treatment of
negative C integer values as well as C unsigned integer values that would
appear negative if cast to integers.
<tt>Sinteger</tt> converts such values into negative Scheme values,
whereas <tt>Sunsigned</tt> converts such values into the appropriate
positive Scheme values.
For example, assuming a 32-bit, two's complement representation for
<tt>iptrs</tt>, <tt>Sinteger(-1)</tt> and <tt>Sunsigned((iptr)0xffffffff)</tt>
both evaluate to the Scheme integer <tt>-1</tt>, whereas
<tt>Sunsigned(0xffffffff)</tt> and <tt>Sunsigned((uptr)-1)</tt>
both evaluate to the Scheme integer
<tt>#xffffffff</tt> (<tt>4294967295</tt>).

<p>
Whichever routine is used, <tt>Sinteger_value</tt> and
<tt>Sunsigned_value</tt> always reproduce the corresponding C
input value, thus the following are all equivalent to <tt><i>x</i></tt>
if <tt><i>x</i></tt> is an iptr.

<p>

<p><tt>Sinteger_value(Sinteger(<i>x</i>))<br>

(iptr)Sunsigned_value(Sinteger(<i>x</i>))<br>

Sinteger_value(Sunsigned((uptr)<i>x</i>))<br>

(iptr)Sunsigned_value(Sunsigned((uptr)<i>x</i>))</tt>
<p>Similarly, the following are all equivalent to <tt><i>x</i></tt>
if <tt><i>x</i></tt> is a uptr.

<p>

<p><tt>(uptr)Sinteger_value(Sinteger((iptr)<i>x</i>))<br>

Sunsigned_value(Sinteger((iptr)<i>x</i>))<br>

(uptr)Sinteger_value(Sunsigned(<i>x</i>))<br>

Sunsigned_value(Sunsigned(<i>x</i>))</tt>
<p><tt>Sinteger32</tt>, <tt>Sunsigned32</tt>, <tt>Sinteger64</tt>,
and <tt>Sunsigned64</tt> are like the generic equivalents but
restrict their arguments to the 32- or 64-bit range.

<p>

<a name="./foreign:s249"></a>[func] <tt>ptr</tt> <tt>Sinteger32</tt><tt>(&lt;32-bit&nbsp;int&nbsp;type&gt;&nbsp;<i>n</i>)</tt><br>

<a name="./foreign:s250"></a>[func] <tt>ptr</tt> <tt>Sunsigned32</tt><tt>(&lt;32-bit&nbsp;unsigned&nbsp;type&gt;&nbsp;<i>n</i>)</tt><br>

<a name="./foreign:s251"></a>[func] <tt>ptr</tt> <tt>Sinteger64</tt><tt>(&lt;64-bit&nbsp;int&nbsp;type&gt;&nbsp;<i>n</i>)</tt><br>

<a name="./foreign:s252"></a>[func] <tt>ptr</tt> <tt>Sunsigned64</tt><tt>(&lt;64-bit&nbsp;unsigned&nbsp;type&gt;&nbsp;<i>n</i>)</tt><br>



<p>
<tt>Scons</tt> and <tt>Sbox</tt> are identical to their Scheme
counterparts.

<p>

<a name="./foreign:s253"></a>[func] <tt>ptr</tt> <tt>Scons</tt><tt>(ptr&nbsp;<i>obj<sub>1</sub></i>,&nbsp;ptr&nbsp;<i>obj<sub>2</sub></i>)</tt><br>

<a name="./foreign:s254"></a>[func] <tt>ptr</tt> <tt>Sbox</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>



<p>
<tt>Sstring_to_symbol</tt> is similar to its Scheme counterpart,
<tt>string-&gt;symbol</tt>, except
that it takes a C string (character pointer) as input.

<p>

<a name="./foreign:s255"></a>[func] <tt>ptr</tt> <tt>Sstring_to_symbol</tt><tt>(const&nbsp;char&nbsp;*<i>s</i>)</tt><br>



<p>
<tt>Smake_string</tt>, <tt>Smake_vector</tt>, <tt>Smake_bytevector</tt>,
and <tt>Smake_fxvector</tt> are similar to their Scheme counterparts.

<p>

<a name="./foreign:s256"></a>[func] <tt>ptr</tt> <tt>Smake_string</tt><tt>(iptr&nbsp;<i>n</i>,&nbsp;int&nbsp;<i>c</i>)</tt><br>

<a name="./foreign:s257"></a>[func] <tt>ptr</tt> <tt>Smake_vector</tt><tt>(iptr&nbsp;<i>n</i>,&nbsp;ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s258"></a>[func] <tt>ptr</tt> <tt>Smake_bytevector</tt><tt>(iptr&nbsp;<i>n</i>,&nbsp;int&nbsp;<i>fill</i>)</tt><br>

<a name="./foreign:s259"></a>[func] <tt>ptr</tt> <tt>Smake_fxvector</tt><tt>(iptr&nbsp;<i>n</i>,&nbsp;ptr&nbsp;<i>fixnum</i>)</tt><br>



<p>
<tt>Smake_uninitialized_string</tt> is similar to the one-argument
<tt>make-string</tt>.

<p>

<a name="./foreign:s260"></a>[func] <tt>ptr</tt> <tt>Smake_uninitialized_string</tt><tt>(iptr&nbsp;<i>n</i>)</tt><br>



<p>
<p><b>Windows-specific helper functions.</b>&nbsp;&nbsp;The following helper functions are provided on Windows only.

<p>

<a name="./foreign:s261"></a>[func] <tt>char&nbsp;*</tt> <tt>Sgetenv</tt><tt>(const&nbsp;char&nbsp;*<i>name</i>)</tt><br>



<p>
<tt>Sgetenv</tt> returns the UTF-8-encoded value of UTF-8-encoded
environment variable <tt><i>name</i></tt> if found and NULL otherwise. Call
<tt>free</tt> on the returned value when it is no longer needed.

<p>

<a name="./foreign:s262"></a>[func] <tt>wchar_t&nbsp;*</tt> <tt>Sutf8_to_wide</tt><tt>(const&nbsp;char&nbsp;*\s)</tt><br>

<a name="./foreign:s263"></a>[func] <tt>char&nbsp;*</tt> <tt>Swide_to_utf8</tt><tt>(const&nbsp;wchar_t&nbsp;*\s)</tt><br>



<p>
<tt>Sutf8_to_wide</tt> and <tt>Swide_to_utf8</tt> convert between
UTF-8-encoded and UTF-16LE-encoded null-terminated strings. Call
<tt>free</tt> on the returned value when it is no longer needed.

<p>
<p><b>Accessing top-level values.</b>&nbsp;&nbsp;Top-level variable bindings may be accessed or assigned via
<tt>Stop_level_value</tt> and <tt>Sset_top_level_value</tt>.

<p>

<a name="./foreign:s264"></a>[func] <tt>ptr</tt> <tt>Stop_level_value</tt><tt>(ptr&nbsp;<i>sym</i>)</tt><br>

<a name="./foreign:s265"></a>[func] <tt>void</tt> <tt>Sset_top_level_value</tt><tt>(ptr&nbsp;<i>sym</i>,&nbsp;ptr&nbsp;<i>obj</i>)</tt><br>



<p>
These procedures give fast access to the bindings in the original
interaction environment and do not reflect changes to the
<tt>interaction-environment</tt> parameter or top-level module imports.
To access the current interaction-environment binding for a symbol, it
is necessary to call the Scheme <tt>top-level-value</tt> and
<tt>set-top-level-value!</tt> procedures instead.

<p>
<p><b>Locking Scheme objects.</b>&nbsp;&nbsp;The storage manager periodically relocates objects in order to reclaim
storage and compact the heap.
This relocation is completely transparent to Scheme programs, since all
pointers to a relocated object are updated to refer to the new
location of the object.
The storage manager cannot, however, update Scheme pointers that reside
outside of the Scheme heap.

<p>
As a general rule, all pointers from C variables or data structures
to Scheme objects should be discarded before entry (or reentry) into
Scheme.
That is, if a C procedure receives an object from Scheme or obtains it
via the mechanisms described in this section, all pointers to the
object should be considered invalid once the C procedure calls into
Scheme or returns back to Scheme.
Dereferencing an invalid pointer or passing it back to Scheme can
have disastrous effects, including unrecoverable memory faults.
The foregoing does not apply to immediate objects, e.g., fixnums,
characters, booleans, or the empty list.
It does apply to all heap-allocated objects, including pairs, vectors,
strings, all numbers other than fixnums, ports, procedures, and records.

<p>
In practice, the best way to ensure that C code does not retain
pointers to Scheme objects is to immediately convert the Scheme objects
into C equivalents, if possible.
In certain cases, it is not possible to do so, yet retention of the
Scheme object is essential to the design of the C portions of the
program.
In these cases, the object may be <i>locked</i> via the library routine
<tt>Slock_object</tt> (or from Scheme, the equivalent procedure
<a name="./foreign:s266"></a><tt>lock-object</tt>).

<p>

<a name="./foreign:s267"></a>[func] <tt>void</tt> <tt>Slock_object</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>



<p>
Locking an object prevents the storage manager from reclaiming or
relocating the object.
Locking should be used sparingly, as it introduces memory fragmentation
and increases storage management overhead.
Locking can also lead to accidental retention of storage if objects
are not unlocked.
Locking objects that have been made static via heap compaction
(see <a name="./foreign:s268"></a><tt>Scompact_heap</tt> above)
is unnecessary but harmless.

<p>
Objects may be unlocked via <tt>Sunlock_object</tt>
(<a name="./foreign:s269"></a><tt>unlock-object</tt>).

<p>

<a name="./foreign:s270"></a>[func] <tt>void</tt> <tt>Sunlock_object</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>



<p>
An object may be locked more than once by successive calls to
<tt>Slock_object</tt> or <tt>lock-object</tt>, in which case it must
be unlocked by an equal number of calls to
<tt>Sunlock_object</tt> or <tt>unlock-object</tt> before it is
truly unlocked.

<p>
The function <tt>Sunlocked_objectp</tt> can be used to determine
if an object is locked.

<p>

<a name="./foreign:s271"></a>[func] <tt>int</tt> <tt>Sunlocked_objectp</tt><tt>(ptr&nbsp;<i>obj</i>)</tt><br>



<p>
When a foreign procedure call is made into Scheme, a return address
pointing into the Scheme code object associated with the foreign
procedure is passed implicitly to the C routine.
The system therefore locks the code object before calls are
made from C back into Scheme and unlocks it upon return from
Scheme.
This locking is performed automatically; user
code should never need to lock such code objects.

<p>
An object contained within a locked object, such as an object in the car
of a locked pair, need not also be locked unless a separate C pointer
to the object exists.

<p>
<p><b>Registering foreign entry points.</b>&nbsp;&nbsp;Foreign entry points may be made visible to Scheme via
<tt>Sforeign_symbol</tt> or <tt>Sregister_symbol</tt>.

<p>

<a name="./foreign:s272"></a>[func] <tt>void</tt> <tt>Sforeign_symbol</tt><tt>(const&nbsp;char&nbsp;*<i>name</i>,&nbsp;void&nbsp;*<i>addr</i>)</tt><br>

<a name="./foreign:s273"></a>[func] <tt>void</tt> <tt>Sregister_symbol</tt><tt>(const&nbsp;char&nbsp;*<i>name</i>,&nbsp;void&nbsp;*<i>addr</i>)</tt><br>



<p>
External entry points in object files or shared objects loaded as a
result of a call to <tt>load-shared-object</tt> are automatically
made visible by the system.
Once a foreign entry point is made visible, it may be named in a
<tt>foreign-procedure</tt> expression to create a Scheme-callable
version of the entry point.
<tt>Sforeign_symbol</tt> and <tt>Sregister_symbol</tt> allow
programs to register nonexternal
entry points, entry points in code linked statically with <i>Chez&nbsp;Scheme</i>,
and entry points into code loaded directly from C, i.e., without
<tt>load-shared-object</tt>.
<tt>Sforeign_symbol</tt> and <tt>Sregister_symbol</tt> differ only in
that <tt>Sforeign_symbol</tt> raises an exception when an attempt is made
to register an existing name, whereas <tt>Sregister_symbol</tt>
permits existing names to be redefined.

<p>
<p><b>Obtaining Scheme entry points.</b>&nbsp;&nbsp;<tt>Sforeign_callable_entry_point</tt> extracts the entry point from a code
object produced by <tt>foreign-callable</tt>, performing the same
operation as its Scheme counterpart, i.e., the Scheme procedure
<tt>foreign-callable-entry-point</tt>.

<p>

<a name="./foreign:s274"></a>[func] <tt>(void&nbsp;(*)&nbsp;(void))</tt> <tt>Sforeign_callable_entry_point</tt><tt>(ptr&nbsp;<i>code</i>)</tt><br>



<p>
This can be used to avoid converting the code object into an address
until just when it is needed, which may eliminate the need to lock
the code object in some circumstances, assuming that the code object
is not saved across any calls back into Scheme.

<p>
The inverse translation can be made via <tt>Sforeign_callable_code_object</tt>.

<p>

<a name="./foreign:s275"></a>[func] <tt>ptr</tt> <tt>Sforeign_callable_code_object</tt><tt>((void&nbsp;(*addr)(void)))</tt><br>



<p>
<p><b>Low-level support for calls into Scheme.</b>&nbsp;&nbsp;Support for calling Scheme procedures from C is provided by the set of 
routines documented below.
Calling a Scheme procedure that expects a small number of arguments
(0-3) involves the use of one of the following routines.

<p>

<a name="./foreign:s276"></a>[func] <tt>ptr</tt> <tt>Scall0</tt><tt>(ptr&nbsp;<i>procedure</i>)</tt><br>

<a name="./foreign:s277"></a>[func] <tt>ptr</tt> <tt>Scall1</tt><tt>(ptr&nbsp;<i>procedure</i>,&nbsp;ptr&nbsp;<i>obj<sub>1</sub></i>)</tt><br>

<a name="./foreign:s278"></a>[func] <tt>ptr</tt> <tt>Scall2</tt><tt>(ptr&nbsp;<i>procedure</i>,&nbsp;ptr&nbsp;<i>obj<sub>1</sub></i>,&nbsp;ptr&nbsp;<i>obj<sub>2</sub></i>)</tt><br>

<a name="./foreign:s279"></a>[func] <tt>ptr</tt> <tt>Scall3</tt><tt>(ptr&nbsp;<i>procedure</i>,&nbsp;ptr&nbsp;<i>obj<sub>1</sub></i>,&nbsp;ptr&nbsp;<i>obj<sub>2</sub></i>,&nbsp;ptr&nbsp;<i>obj<sub>3</sub></i>)</tt><br>



<p>
In each case,
the first argument, <tt><i>procedure</i></tt>, should be a Scheme procedure.
The remaining arguments, which should be Scheme objects, are
passed to the procedure.
The tools described earlier in this section may be used to convert
C datatypes into their Scheme equivalents.
A program that automatically generates conversion code from
declarations that are similar to <tt>foreign-procedure</tt> expressions
is distributed with <i>Chez&nbsp;Scheme</i>.
It can be found in the Scheme library directory on most systems in the
file <tt>"foreign.ss"</tt>.

<p>
A Scheme procedure may be obtained in a number of ways.
For example, it may be received as an argument in a call
from Scheme into C, obtained via another call to Scheme,
extracted from a Scheme data structure, or obtained from the top-level
environment via <tt>Stop_level_value</tt>.

<p>
A more general interface involving the following routines is available
for longer argument lists.

<p>

<a name="./foreign:s280"></a>[func] <tt>void</tt> <tt>Sinitframe</tt><tt>(iptr&nbsp;<i>n</i>)</tt><br>

<a name="./foreign:s281"></a>[func] <tt>void</tt> <tt>Sput_arg</tt><tt>(iptr&nbsp;<i>i</i>,&nbsp;ptr&nbsp;<i>obj</i>)</tt><br>

<a name="./foreign:s282"></a>[func] <tt>ptr</tt> <tt>Scall</tt><tt>(ptr&nbsp;<i>procedure</i>,&nbsp;iptr&nbsp;<i>n</i>)</tt><br>



<p>
A C procedure first calls <tt>Sinitframe</tt> with one argument, the
number of arguments to be passed to Scheme.
It then calls <tt>Sput_arg</tt> once for each argument (in any order), passing
<tt>Sput_arg</tt> the argument number (starting with <tt>1</tt>) and
the argument.
Finally, it calls <tt>Scall</tt> to perform the call, passing it
the Scheme procedure and the number of arguments (the same number as
in the call to <tt>Sinitframe</tt>).
Programmers should ensure a Scheme call initiated via
<tt>Sinitframe</tt> is completed via <tt>Scall</tt> before any other
calls to Scheme are made and before a return to Scheme is attempted.
If for any reason the call is not completed after <tt>Sinitframe</tt>
has been called, it may not be possible to return to Scheme.

<p>
The following examples serve to illustrate both the simpler and more
general interfaces.

<p>

<p><tt>/*&nbsp;a&nbsp;particularly&nbsp;silly&nbsp;way&nbsp;to&nbsp;multiply&nbsp;two&nbsp;floating-point&nbsp;numbers&nbsp;*/<br>

double&nbsp;mul(double&nbsp;x,&nbsp;double&nbsp;y)&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;&nbsp;ptr&nbsp;times&nbsp;=&nbsp;Stop_level_value(Sstring_to_symbol("*"));
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Sflonum_value(Scall2(times,&nbsp;Sflonum(x),&nbsp;Sflonum(y)));<br>

&#125;</tt>
<p>
<p><tt>/*&nbsp;an&nbsp;equally&nbsp;silly&nbsp;way&nbsp;to&nbsp;call&nbsp;printf&nbsp;with&nbsp;five&nbsp;arguments&nbsp;*/
<br>
<br>
/*&nbsp;it&nbsp;is&nbsp;best&nbsp;to&nbsp;define&nbsp;interfaces&nbsp;such&nbsp;as&nbsp;the&nbsp;one&nbsp;below&nbsp;to&nbsp;handle<br>

&nbsp;*&nbsp;calls&nbsp;into&nbsp;Scheme&nbsp;to&nbsp;prevent&nbsp;accidental&nbsp;attempts&nbsp;to&nbsp;nest&nbsp;frame<br>

&nbsp;*&nbsp;creation&nbsp;and&nbsp;to&nbsp;help&nbsp;ensure&nbsp;that&nbsp;initiated&nbsp;calls&nbsp;are&nbsp;completed<br>

&nbsp;*&nbsp;as&nbsp;discussed&nbsp;above.&nbsp;&nbsp;Specialized&nbsp;versions&nbsp;tailored&nbsp;to&nbsp;particular<br>

&nbsp;*&nbsp;C&nbsp;argument&nbsp;types&nbsp;may&nbsp;be&nbsp;defined&nbsp;as&nbsp;well,&nbsp;with&nbsp;embedded&nbsp;conversions<br>

&nbsp;*&nbsp;to&nbsp;Scheme&nbsp;objects.&nbsp;*/<br>

ptr&nbsp;Scall5(ptr&nbsp;p,&nbsp;ptr&nbsp;x1,&nbsp;ptr&nbsp;x2,&nbsp;ptr&nbsp;x3,&nbsp;ptr&nbsp;x4,&nbsp;ptr&nbsp;x5)&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;&nbsp;Sinitframe(5);<br>

&nbsp;&nbsp;&nbsp;&nbsp;Sput_arg(1,&nbsp;x1);<br>

&nbsp;&nbsp;&nbsp;&nbsp;Sput_arg(2,&nbsp;x2);<br>

&nbsp;&nbsp;&nbsp;&nbsp;Sput_arg(3,&nbsp;x3);<br>

&nbsp;&nbsp;&nbsp;&nbsp;Sput_arg(4,&nbsp;x4);<br>

&nbsp;&nbsp;&nbsp;&nbsp;Sput_arg(5,&nbsp;x5);<br>

&nbsp;&nbsp;&nbsp;&nbsp;Scall(p,&nbsp;5);<br>

&#125;
<br>
<br>
static&nbsp;void&nbsp;dumpem(char&nbsp;*s,&nbsp;int&nbsp;a,&nbsp;double&nbsp;b,&nbsp;ptr&nbsp;c,&nbsp;char&nbsp;*d)&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;&nbsp;printf(s,&nbsp;a,&nbsp;b,&nbsp;c,&nbsp;d);<br>

&#125;
<br>
<br>
static&nbsp;void&nbsp;foo(int&nbsp;x,&nbsp;double&nbsp;y,&nbsp;ptr&nbsp;z,&nbsp;char&nbsp;*s)&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;&nbsp;ptr&nbsp;ois,&nbsp;sip,&nbsp;read,&nbsp;expr,&nbsp;eval,&nbsp;c_dumpem;<br>

&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*sexpr&nbsp;=&nbsp;"(foreign-procedure&nbsp;\"dumpem\"&nbsp;(string&nbsp;integer-32\<br>

&nbsp;double-float&nbsp;scheme-object&nbsp;string)&nbsp;void)";
<br>
<br>
&nbsp;&nbsp;/*&nbsp;this&nbsp;series&nbsp;of&nbsp;statements&nbsp;is&nbsp;carefully&nbsp;crafted&nbsp;to&nbsp;avoid&nbsp;referencing<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variables&nbsp;holding&nbsp;Scheme&nbsp;objects&nbsp;after&nbsp;calls&nbsp;into&nbsp;Scheme&nbsp;*/<br>

&nbsp;&nbsp;&nbsp;&nbsp;ois&nbsp;=&nbsp;Stop_level_value(Sstring_to_symbol("open-input-string"));<br>

&nbsp;&nbsp;&nbsp;&nbsp;sip&nbsp;=&nbsp;Scall1(ois,&nbsp;Sstring(sexpr));<br>

&nbsp;&nbsp;&nbsp;&nbsp;read&nbsp;=&nbsp;Stop_level_value(Sstring_to_symbol("read"));<br>

&nbsp;&nbsp;&nbsp;&nbsp;expr&nbsp;=&nbsp;Scall1(read,&nbsp;sip);<br>

&nbsp;&nbsp;&nbsp;&nbsp;eval&nbsp;=&nbsp;Stop_level_value(Sstring_to_symbol("eval"));<br>

&nbsp;&nbsp;&nbsp;&nbsp;Sforeign_symbol("dumpem",&nbsp;(void&nbsp;*)dumpem);<br>

&nbsp;&nbsp;&nbsp;&nbsp;c_dumpem&nbsp;=&nbsp;Scall1(eval,&nbsp;expr);<br>

&nbsp;&nbsp;&nbsp;&nbsp;Scall5(c_dumpem,<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sstring("x&nbsp;=&nbsp;%d,&nbsp;y&nbsp;=&nbsp;%g,&nbsp;z&nbsp;=&nbsp;%x,&nbsp;s&nbsp;=&nbsp;%s\n"),<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sinteger(x),<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sflonum(y),<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z,<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sstring(s));<br>

&#125;</tt>
<p>Calls from C to Scheme should not be made from C interrupt handlers.
When Scheme calls into C, the system saves the contents of certain
dedicated machine registers in a register save area.
When C then calls into Scheme, the registers are restored from the
register save area.
Because an interrupt can occur at any point in a computation, the
contents of the register save locations would typically contain invalid
information that would cause the Scheme system to fail to operate
properly.

<p>
<p><b>Activating, deactivating, and destroying threads.</b>&nbsp;&nbsp;Three functions are provided by the threaded versions of Scheme to
allow C code to notify Scheme when a thread should be activated,
deactivated, or destroyed.

<p>
<a name="./foreign:s283"></a>[func] <tt>int</tt> <tt>Sactivate_thread</tt><tt>(void)</tt><br>

<a name="./foreign:s284"></a>[func] <tt>void</tt> <tt>Sdeactivate_thread</tt><tt>(void)</tt><br>

<a name="./foreign:s285"></a>[func] <tt>int</tt> <tt>Sdestroy_thread</tt><tt>(void)</tt><br>


<p>
A thread created via the Scheme procedure <tt>fork-thread</tt> starts
in the active state and need not be activated.
Any thread that has been deactivated, and any
thread created by some mechanism other than <tt>fork-thread</tt> must,
however, be activated before it can access Scheme data or execute
Scheme code. A foreign callable that is declared with <tt>__collect_safe</tt>
can activate a calling thread.
Otherwise, <tt>Sactivate_thread</tt> must be used to activate a thread.
It returns 1 the first time the thread is activated and 0 on each
subsequent call until the activation is destroyed with <tt>Sdestroy_thread</tt>.

<p>
Since active threads operating in C code prevent the storage management
system from garbage collecting,
a thread should be deactivated via <tt>Sdeactivate_thread</tt> or
through a <tt>foreign-procedure</tt> <tt>__collect_safe</tt> declaration whenever
the thread may spend a significant amount of time in C code.
This is especially important whenever the thread calls a C library
function, like <tt>read</tt>, that may block indefinitely.
Once deactivated, the thread must not touch any Scheme data or
execute any Scheme code until it is reactivated, with one exception.
The exception is that the thread may access or even modify a locked
Scheme object, such as a locked string, that contains no pointers to
other, unlocked Scheme objects.
(Objects that are not locked may be relocated by the garbage collector
while the thread is inactive.)

<p>
<tt>Sdestroy_thread</tt> is used to notify the Scheme system that the
thread is shut down and any thread-specific data can be released.

<p>
<p><b>Low-level synchronization primitives.</b>&nbsp;&nbsp;The header file defines several preprocessor macros that can be
used to lock memory locations in a manner identical to the corresponding
ftype lock operations (sections &nbsp;<a href="./threads.html#g141">15.4</a> and
<a href="./threads.html#g142">15.5</a>).

<p>
<a name="./foreign:s286"></a>[macro] <tt>void</tt> <tt>INITLOCK</tt><tt>(void&nbsp;*<i>addr</i>)</tt><br>

<a name="./foreign:s287"></a>[macro] <tt>void</tt> <tt>SPINLOCK</tt><tt>(void&nbsp;*<i>addr</i>)</tt><br>

<a name="./foreign:s288"></a>[macro] <tt>void</tt> <tt>UNLOCK</tt><tt>(void&nbsp;*<i>addr</i>)</tt><br>

<a name="./foreign:s289"></a>[macro] <tt>void</tt> <tt>LOCKED_INCR</tt><tt>(void&nbsp;*<i>addr</i>,&nbsp;int&nbsp;*<i>ret</i>)</tt><br>

<a name="./foreign:s290"></a>[macro] <tt>void</tt> <tt>LOCKED_DECR</tt><tt>(void&nbsp;*<i>addr</i>,&nbsp;int&nbsp;*<i>ret</i>)</tt><br>


<p>
<tt>LOCKED_INCR</tt> and <tt>LOCKED_DECR</tt> set <tt><i>ret</i></tt> to a
nonzero (true) value if the incremented or decremented value is 0.
Otherwise they set <tt><i>ret</i></tt> to 0.

<p>

<h3><a name="g35"></a><a name="./foreign:h9"></a>Section 4.9. Example: Socket Operations<a name="SECTFOREIGNSOCKETS"></a></h3>



<p>
<a name="./foreign:s291"></a>This section presents a simple socket interface that
employs a combination of Scheme and C code.
The C code defines a set of convenient low-level operating-system
interfaces that can be used in the higher-level Scheme code to open,
close, read from, and write to sockets.

<p>
The C code (csocket.c) is given below, followed by the Scheme code
(socket.ss).
The code should require little or no modification to run on most Unix
systems and can be modified to work under Windows (using the Windows
<i>WinSock</i> interface).

<p>
A sample session demonstrating the socket interface follows the code.
See Section&nbsp;<a href="./io.html#g89">9.17</a> for an example that demonstrates how
to use the same socket interface to build a process port that allows
transparent input from and output to a subprocess via a Scheme port.

<p>
<p><b>C code.</b>&nbsp;&nbsp;
<p><tt>/*&nbsp;csocket.c&nbsp;*/
<br>
<br>
#include&nbsp;&lt;sys/types.h&gt;<br>

#include&nbsp;&lt;sys/socket.h&gt;<br>

#include&nbsp;&lt;sys/un.h&gt;<br>

#include&nbsp;&lt;string.h&gt;<br>

#include&nbsp;&lt;errno.h&gt;<br>

#include&nbsp;&lt;signal.h&gt;<br>

#include&nbsp;&lt;sys/ioctl.h&gt;<br>

#include&nbsp;&lt;stdio.h&gt;<br>

#include&nbsp;&lt;unistd.h&gt;
<br>
<br>
/*&nbsp;c_write&nbsp;attempts&nbsp;to&nbsp;write&nbsp;the&nbsp;entire&nbsp;buffer,&nbsp;pushing&nbsp;through<br>

&nbsp;&nbsp;&nbsp;interrupts,&nbsp;socket&nbsp;delays,&nbsp;and&nbsp;partial-buffer&nbsp;writes&nbsp;*/<br>

int&nbsp;c_write(int&nbsp;fd,&nbsp;char&nbsp;*buf,&nbsp;ssize_t&nbsp;start,&nbsp;ssize_t&nbsp;n)&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;&nbsp;ssize_t&nbsp;i,&nbsp;m;
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;buf&nbsp;+=&nbsp;start;<br>

&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;n;<br>

&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(m&nbsp;&gt;&nbsp;0)&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((i&nbsp;=&nbsp;write(fd,&nbsp;buf,&nbsp;m))&nbsp;&lt;&nbsp;0)&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(errno&nbsp;!=&nbsp;EAGAIN&nbsp;&amp;&amp;&nbsp;errno&nbsp;!=&nbsp;EINTR)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;else&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;-=&nbsp;i;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf&nbsp;+=&nbsp;i;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&#125;<br>

&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;n;<br>

&#125;
<br>
<br>
/*&nbsp;c_read&nbsp;pushes&nbsp;through&nbsp;interrupts&nbsp;and&nbsp;socket&nbsp;delays&nbsp;*/<br>

int&nbsp;c_read(int&nbsp;fd,&nbsp;char&nbsp;*buf,&nbsp;size_t&nbsp;start,&nbsp;size_t&nbsp;n)&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;buf&nbsp;+=&nbsp;start;<br>

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;;)&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;read(fd,&nbsp;buf,&nbsp;n);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;&gt;=&nbsp;0)&nbsp;return&nbsp;i;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(errno&nbsp;!=&nbsp;EAGAIN&nbsp;&amp;&amp;&nbsp;errno&nbsp;!=&nbsp;EINTR)&nbsp;return&nbsp;-1;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&#125;<br>

&#125;
<br>
<br>
/*&nbsp;bytes_ready(fd)&nbsp;returns&nbsp;true&nbsp;if&nbsp;there&nbsp;are&nbsp;bytes&nbsp;available<br>

&nbsp;&nbsp;&nbsp;to&nbsp;be&nbsp;read&nbsp;from&nbsp;the&nbsp;socket&nbsp;identified&nbsp;by&nbsp;fd&nbsp;*/<br>

int&nbsp;bytes_ready(int&nbsp;fd)&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;n;
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;(void)&nbsp;ioctl(fd,&nbsp;FIONREAD,&nbsp;&amp;n);<br>

&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;n;<br>

&#125;
<br>
<br>
/*&nbsp;socket&nbsp;support&nbsp;*/
<br>
<br>
/*&nbsp;do_socket()&nbsp;creates&nbsp;a&nbsp;new&nbsp;AF_UNIX&nbsp;socket&nbsp;*/<br>

int&nbsp;do_socket(void)&nbsp;&#123;
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;socket(AF_UNIX,&nbsp;SOCK_STREAM,&nbsp;0);<br>

&#125;
<br>
<br>
/*&nbsp;do_bind(s,&nbsp;name)&nbsp;binds&nbsp;name&nbsp;to&nbsp;the&nbsp;socket&nbsp;s&nbsp;*/<br>

int&nbsp;do_bind(int&nbsp;s,&nbsp;char&nbsp;*name)&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;sockaddr_un&nbsp;sun;<br>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;length;
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;sun.sun_family&nbsp;=&nbsp;AF_UNIX;<br>

&nbsp;&nbsp;&nbsp;&nbsp;(void)&nbsp;strcpy(sun.sun_path,&nbsp;name);<br>

&nbsp;&nbsp;&nbsp;&nbsp;length&nbsp;=&nbsp;sizeof(sun.sun_family)&nbsp;+&nbsp;sizeof(sun.sun_path);
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;bind(s,&nbsp;(struct&nbsp;sockaddr*)(&amp;sun),&nbsp;length);<br>

&#125;
<br>
<br>
/*&nbsp;do_accept&nbsp;accepts&nbsp;a&nbsp;connection&nbsp;on&nbsp;socket&nbsp;s&nbsp;*/<br>

int&nbsp;do_accept(int&nbsp;s)&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;sockaddr_un&nbsp;sun;<br>

&nbsp;&nbsp;&nbsp;&nbsp;socklen_t&nbsp;length;
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;length&nbsp;=&nbsp;sizeof(sun.sun_family)&nbsp;+&nbsp;sizeof(sun.sun_path);
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;accept(s,&nbsp;(struct&nbsp;sockaddr*)(&amp;sun),&nbsp;&amp;length);<br>

&#125;
<br>
<br>
/*&nbsp;do_connect&nbsp;initiates&nbsp;a&nbsp;socket&nbsp;connection&nbsp;*/<br>

int&nbsp;do_connect(int&nbsp;s,&nbsp;char&nbsp;*name)&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;sockaddr_un&nbsp;sun;<br>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;length;
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;sun.sun_family&nbsp;=&nbsp;AF_UNIX;<br>

&nbsp;&nbsp;&nbsp;&nbsp;(void)&nbsp;strcpy(sun.sun_path,&nbsp;name);<br>

&nbsp;&nbsp;&nbsp;&nbsp;length&nbsp;=&nbsp;sizeof(sun.sun_family)&nbsp;+&nbsp;sizeof(sun.sun_path);
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;connect(s,&nbsp;(struct&nbsp;sockaddr*)(&amp;sun),&nbsp;length);<br>

&#125;
<br>
<br>
/*&nbsp;get_error&nbsp;returns&nbsp;the&nbsp;operating&nbsp;system's&nbsp;error&nbsp;status&nbsp;*/<br>

char*&nbsp;get_error(void)&nbsp;&#123;<br>

&nbsp;&nbsp;&nbsp;&nbsp;extern&nbsp;int&nbsp;errno;<br>

&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;strerror(errno);<br>

&#125;</tt>
<p><p><b>Scheme code.</b>&nbsp;&nbsp;
<p><tt>;;;&nbsp;socket.ss
<br>
<br>
;;;&nbsp;Requires&nbsp;csocket.so,&nbsp;built&nbsp;from&nbsp;csocket.c.<br>

(load-shared-object&nbsp;"./csocket.so")
<br>
<br>
;;;&nbsp;Requires&nbsp;from&nbsp;C&nbsp;library:<br>

;;;&nbsp;&nbsp;&nbsp;close,&nbsp;dup,&nbsp;execl,&nbsp;fork,&nbsp;kill,&nbsp;listen,&nbsp;tmpnam,&nbsp;unlink<br>

(case&nbsp;(machine-type)<br>

&nbsp;&nbsp;[(i3le&nbsp;ti3le&nbsp;a6le&nbsp;ta6le)&nbsp;(load-shared-object&nbsp;"libc.so.6")]<br>

&nbsp;&nbsp;[(i3osx&nbsp;ti3osx&nbsp;a6osx&nbsp;ta6osx)&nbsp;(load-shared-object&nbsp;"libc.dylib")]<br>

&nbsp;&nbsp;[else&nbsp;(load-shared-object&nbsp;"libc.so")])
<br>
<br>
;;;&nbsp;basic&nbsp;C-library&nbsp;stuff
<br>
<br>
(define&nbsp;close<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"close"&nbsp;(int)<br>

&nbsp;&nbsp;&nbsp;&nbsp;int))
<br>
<br>
(define&nbsp;dup<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"dup"&nbsp;(int)<br>

&nbsp;&nbsp;&nbsp;&nbsp;int))
<br>
<br>
(define&nbsp;execl4<br>

&nbsp;&nbsp;(let&nbsp;((execl-help<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(foreign-procedure&nbsp;"execl"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string&nbsp;string&nbsp;string&nbsp;string&nbsp;void*)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(s1&nbsp;s2&nbsp;s3&nbsp;s4)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(execl-help&nbsp;s1&nbsp;s2&nbsp;s3&nbsp;s4&nbsp;0))))
<br>
<br>
(define&nbsp;fork<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"fork"&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;int))
<br>
<br>
(define&nbsp;kill<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"kill"&nbsp;(int&nbsp;int)<br>

&nbsp;&nbsp;&nbsp;&nbsp;int))
<br>
<br>
(define&nbsp;listen<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"listen"&nbsp;(int&nbsp;int)<br>

&nbsp;&nbsp;&nbsp;&nbsp;int))
<br>
<br>
(define&nbsp;tmpnam<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"tmpnam"&nbsp;(void*)<br>

&nbsp;&nbsp;&nbsp;&nbsp;string))
<br>
<br>
(define&nbsp;unlink<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"unlink"&nbsp;(string)<br>

&nbsp;&nbsp;&nbsp;&nbsp;int))
<br>
<br>
;;;&nbsp;routines&nbsp;defined&nbsp;in&nbsp;csocket.c
<br>
<br>
(define&nbsp;accept<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"do_accept"&nbsp;(int)<br>

&nbsp;&nbsp;&nbsp;&nbsp;int))
<br>
<br>
(define&nbsp;bytes-ready?<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"bytes_ready"&nbsp;(int)<br>

&nbsp;&nbsp;&nbsp;&nbsp;boolean))
<br>
<br>
(define&nbsp;bind<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"do_bind"&nbsp;(int&nbsp;string)<br>

&nbsp;&nbsp;&nbsp;&nbsp;int))
<br>
<br>
(define&nbsp;c-error<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"get_error"&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;string))
<br>
<br>
(define&nbsp;c-read<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"c_read"&nbsp;(int&nbsp;u8*&nbsp;size_t&nbsp;size_t)<br>

&nbsp;&nbsp;&nbsp;&nbsp;ssize_t))
<br>
<br>
(define&nbsp;c-write<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"c_write"&nbsp;(int&nbsp;u8*&nbsp;size_t&nbsp;ssize_t)<br>

&nbsp;&nbsp;&nbsp;&nbsp;ssize_t))
<br>
<br>
(define&nbsp;connect<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"do_connect"&nbsp;(int&nbsp;string)<br>

&nbsp;&nbsp;&nbsp;&nbsp;int))
<br>
<br>
(define&nbsp;socket<br>

&nbsp;&nbsp;(foreign-procedure&nbsp;"do_socket"&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;int))
<br>
<br>
;;;&nbsp;higher-level&nbsp;routines
<br>
<br>
(define&nbsp;dodup<br>

&nbsp;;&nbsp;(dodup&nbsp;old&nbsp;new)&nbsp;closes&nbsp;old&nbsp;and&nbsp;dups&nbsp;new,&nbsp;then&nbsp;checks&nbsp;to<br>

&nbsp;;&nbsp;make&nbsp;sure&nbsp;that&nbsp;resulting&nbsp;fd&nbsp;is&nbsp;the&nbsp;same&nbsp;as&nbsp;old<br>

&nbsp;&nbsp;(lambda&nbsp;(old&nbsp;new)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(check&nbsp;'close&nbsp;(close&nbsp;old))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(=&nbsp;(dup&nbsp;new)&nbsp;old)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;'dodup<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"couldn't&nbsp;set&nbsp;up&nbsp;child&nbsp;process&nbsp;io&nbsp;for&nbsp;fd&nbsp;~s"&nbsp;old))))
<br>
<br>
(define&nbsp;dofork<br>

&nbsp;;&nbsp;(dofork&nbsp;child&nbsp;parent)&nbsp;forks&nbsp;a&nbsp;child&nbsp;process&nbsp;and&nbsp;invokes&nbsp;child<br>

&nbsp;;&nbsp;without&nbsp;arguments&nbsp;and&nbsp;parent&nbsp;with&nbsp;the&nbsp;child's&nbsp;pid<br>

&nbsp;&nbsp;(lambda&nbsp;(child&nbsp;parent)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([pid&nbsp;(fork)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(=&nbsp;pid&nbsp;0)&nbsp;(child)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&gt;&nbsp;pid&nbsp;0)&nbsp;(parent&nbsp;pid)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(error&nbsp;'fork&nbsp;(c-error))]))))
<br>
<br>
(define&nbsp;setup-server-socket<br>

&nbsp;;&nbsp;create&nbsp;a&nbsp;socket,&nbsp;bind&nbsp;it&nbsp;to&nbsp;name,&nbsp;and&nbsp;listen&nbsp;for&nbsp;connections<br>

&nbsp;&nbsp;(lambda&nbsp;(name)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([sock&nbsp;(check&nbsp;'socket&nbsp;(socket))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unlink&nbsp;name)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check&nbsp;'bind&nbsp;(bind&nbsp;sock&nbsp;name))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check&nbsp;'listen&nbsp;(listen&nbsp;sock&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sock)))
<br>
<br>
(define&nbsp;setup-client-socket<br>

&nbsp;;&nbsp;create&nbsp;a&nbsp;socket&nbsp;and&nbsp;attempt&nbsp;to&nbsp;connect&nbsp;to&nbsp;server<br>

&nbsp;&nbsp;(lambda&nbsp;(name)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([sock&nbsp;(check&nbsp;'socket&nbsp;(socket))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check&nbsp;'connect&nbsp;(connect&nbsp;sock&nbsp;name))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sock)))
<br>
<br>
(define&nbsp;accept-socket<br>

&nbsp;;&nbsp;accept&nbsp;a&nbsp;connection<br>

&nbsp;&nbsp;(lambda&nbsp;(sock)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(check&nbsp;'accept&nbsp;(accept&nbsp;sock))))
<br>
<br>
(define&nbsp;check<br>

&nbsp;;&nbsp;signal&nbsp;an&nbsp;error&nbsp;if&nbsp;status&nbsp;x&nbsp;is&nbsp;negative,&nbsp;using&nbsp;c-error&nbsp;to<br>

&nbsp;;&nbsp;obtain&nbsp;the&nbsp;operating-system's&nbsp;error&nbsp;message<br>

&nbsp;&nbsp;(lambda&nbsp;(who&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;x&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;who&nbsp;(c-error))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x)))
<br>
<br>
(define&nbsp;terminate-process<br>

&nbsp;;&nbsp;kill&nbsp;the&nbsp;process&nbsp;identified&nbsp;by&nbsp;pid<br>

&nbsp;&nbsp;(lambda&nbsp;(pid)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;sigterm&nbsp;15)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(kill&nbsp;pid&nbsp;sigterm)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(void)))</tt>
<p><p><b>Sample session.</b>&nbsp;&nbsp;
<p><tt>&gt;&nbsp;(define&nbsp;client-pid)<br>

&gt;&nbsp;(define&nbsp;client-socket)<br>

&gt;&nbsp;(let*&nbsp;([server-socket-name&nbsp;(tmpnam&nbsp;0)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[server-socket&nbsp;(setup-server-socket&nbsp;server-socket-name)])<br>

&nbsp;&nbsp;&nbsp;;&nbsp;fork&nbsp;a&nbsp;child,&nbsp;use&nbsp;it&nbsp;to&nbsp;exec&nbsp;a&nbsp;client&nbsp;Scheme&nbsp;process,&nbsp;and&nbsp;set<br>

&nbsp;&nbsp;&nbsp;;&nbsp;up&nbsp;server-side&nbsp;client-pid&nbsp;and&nbsp;client-socket&nbsp;variables.<br>

&nbsp;&nbsp;&nbsp;&nbsp;(dofork&nbsp;&nbsp;&nbsp;;&nbsp;child<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;the&nbsp;child&nbsp;establishes&nbsp;the&nbsp;socket&nbsp;input/output&nbsp;fds&nbsp;as<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;stdin&nbsp;and&nbsp;stdout,&nbsp;then&nbsp;starts&nbsp;a&nbsp;new&nbsp;Scheme&nbsp;session<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check&nbsp;'close&nbsp;(close&nbsp;server-socket))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([sock&nbsp;(setup-client-socket&nbsp;server-socket-name)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dodup&nbsp;0&nbsp;sock)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dodup&nbsp;1&nbsp;sock))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check&nbsp;'execl&nbsp;(execl4&nbsp;"/bin/sh"&nbsp;"/bin/sh"&nbsp;"-c"&nbsp;"exec&nbsp;scheme&nbsp;-q"))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(errorf&nbsp;'client&nbsp;"returned!"))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(pid)&nbsp;;&nbsp;parent<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;the&nbsp;parent&nbsp;waits&nbsp;for&nbsp;a&nbsp;connection&nbsp;from&nbsp;the&nbsp;client<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;client-pid&nbsp;pid)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;client-socket&nbsp;(accept-socket&nbsp;server-socket))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check&nbsp;'close&nbsp;(close&nbsp;server-socket)))))<br>

&gt;&nbsp;(define&nbsp;put&nbsp;;&nbsp;procedure&nbsp;to&nbsp;send&nbsp;data&nbsp;to&nbsp;client<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([s&nbsp;(format&nbsp;"~s~%"&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(c-write&nbsp;client-socket&nbsp;s&nbsp;(string-length&nbsp;s)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)))<br>

&gt;&nbsp;(define&nbsp;get&nbsp;;&nbsp;procedure&nbsp;to&nbsp;read&nbsp;data&nbsp;from&nbsp;client<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([buff&nbsp;(make-string&nbsp;1024)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([n&nbsp;(c-read&nbsp;client-socket&nbsp;buff&nbsp;(string-length&nbsp;buff))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(printf&nbsp;"client:~%~a~%server:~%"&nbsp;(substring&nbsp;buff&nbsp;0&nbsp;n))))))<br>

&gt;&nbsp;(get)<br>

server:<br>

&gt;&nbsp;(put&nbsp;'(let&nbsp;([x&nbsp;3])&nbsp;x))<br>

&gt;&nbsp;(get)<br>

client:<br>

3<br>

server:<br>

&gt;&nbsp;(terminate-process&nbsp;client-pid)<br>

&gt;&nbsp;(exit)</tt>
<p>



<hr class=copyright align=left>
<p>
<a class=plain href="index.html">Chez Scheme Version 9 User's Guide</a><br>
Copyright &copy; 2020 Cisco Systems, Inc.<br>
Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License Version 2.0</a>
(<a class=plain href="canned/copyright.html">full copyright notice.</a>).</br>
Revised August 2020 for Chez Scheme Version 9.5.4<br>
<a class=plain href="canned/about.html">about this book</a>
</tr></table>
</body>
</html>
