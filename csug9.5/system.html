<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>System Operations</title>
<link href="csug.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g111"></a>
<a name="./system:h0"></a>

<h1>Chapter 12. System Operations<a name="CHPTSYSTEM"></a></h1>





<p>
This chapter describes operations for
handling exceptions, interrupts, environments,
compilation and evaluation, profiling,
controlling the operation of the system,
timing and statistics,
defining and setting parameters,
and
querying the operating system environment.



<p>

<h3><a name="g112"></a><a name="./system:h1"></a>Section 12.1. Exceptions<a name="SECTSYSTEMEXCEPTIONS"></a></h3>



<p>
<a name="./system:s0"></a><i>Chez&nbsp;Scheme</i> provides some extensions to the
Revised<sup>6</sup> Report exception-handling mechanism, including mechanisms
for producing formatted error messages, displaying conditions,
and redefining the base exception handler.
These extensions are described in this section.


<p>
<a name="./system:s1"></a><span class=formdef><b>procedure</b>: <tt>(warning&nbsp;<i>who</i>&nbsp;<i>msg</i>&nbsp;<i>irritant</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>warning</tt> raises a continuable exception with condition type
<tt>&amp;warning</tt> and should be used to describe situations for which the
<tt>&amp;warning</tt> condition type is appropriate, typically a situation
that should not prevent the program from continuing but might result
in a more serious problem at some later point.

<p>
The continuation object with which the exception is raised also includes
a <tt>&amp;who</tt> condition whose who field is <tt><i>who</i></tt> if <tt><i>who</i></tt> is
not <tt>#f</tt>, a <tt>&amp;message</tt> condition whose message field is
<tt><i>msg</i></tt>, and an <tt>&amp;irritants</tt> condition whose irritants field
is <tt>(<i>irritant</i>&nbsp;...)</tt>.

<p>
<tt><i>who</i></tt> must be a string, a symbol, or <tt>#f</tt> identifying the procedure
or syntactic form reporting the warning.
It is usually best to identify a procedure the programmer has called rather
than some other procedure the programmer may not be aware is involved in
carrying out the operation.
<tt><i>msg</i></tt> must be a string and should describe the exceptional situation.
The irritants may be any Scheme objects and should include values that may
have caused or been materially involved in the exceptional situation.


<p>
<a name="./system:s2"></a><span class=formdef><b>procedure</b>: <tt>(assertion-violationf&nbsp;<i>who</i>&nbsp;<i>msg</i>&nbsp;<i>irritant</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>does not return
<br><span class=formdef><b>procedure</b>: <tt>(errorf&nbsp;<i>who</i>&nbsp;<i>msg</i>&nbsp;<i>irritant</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>does not return
<br><span class=formdef><b>procedure</b>: <tt>(warningf&nbsp;<i>who</i>&nbsp;<i>msg</i>&nbsp;<i>irritant</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./system:s3"></a>These procedures are like <tt>assertion-violation</tt>, <tt>error</tt>,
and <tt>warning</tt> except
that <tt><i>msg</i></tt> is assumed to be a format string, as if in a call to
<tt>format</tt> (Section&nbsp;<a href="./io.html#g85">9.13</a>), with
<tt><i>irritant</i>&nbsp;...</tt> treated as the additional arguments to
<tt>format</tt>.
This allows programs to control the appearance of the error message, at
least when the default exception handler is in place.

<p>
For each of these procedures, the continuation object with which the exception
is raised includes a <tt>&amp;format</tt> condition to signify that the string
contained in the condition object's <tt>&amp;message</tt> condition is a
<tt>format</tt> string and the objects contained in the condition object's
<tt>&amp;irritants</tt> condition should be treated as the additional
<tt>format</tt> arguments.

<p>
<a name="./system:s4"></a><span class=formdef><b>syntax</b>: <tt>&amp;format</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-format-condition)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;format</tt>
<br><span class=formdef><b>procedure</b>: <tt>(format-condition?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;format</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>

<p>Presence of this condition type within a compound condition indicates
that the string provided by the <tt>&amp;message</tt> condition, if
present, is a <tt>format</tt> string and the list of objects provided by
the <tt>&amp;irritants</tt> condition, if present, should be treated as
additional <tt>format</tt> arguments.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;format&nbsp;&amp;condition<br>

&nbsp;&nbsp;make-format-condition&nbsp;format-condition?)</tt>
<p><a name="./system:s5"></a><span class=formdef><b>syntax</b>: <tt>&amp;source</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-source-condition&nbsp;<i>form</i>)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;source</tt>
<br><span class=formdef><b>procedure</b>: <tt>(source-condition?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;source</tt>, <tt>#f</tt> otherwise
<br><span class=formdef><b>procedure</b>: <tt>(source-condition-form&nbsp;<i>condition</i>)</tt></span>
<br>
<b>returns: </b>the contents of <tt><i>condition</i></tt>'s <tt>form</tt> field
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>

<p>This condition type can be included within a compound condition when a
source expression can be identified in situations in which a
<tt>&amp;syntax</tt> condition would be inappropriate, such as when a
run-time assertion violation is detected.
The <tt>form</tt> argument should be an s-expression or syntax object
representing the source expression.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;source&nbsp;&amp;condition<br>

&nbsp;&nbsp;make-source-condition&nbsp;source-condition?<br>

&nbsp;&nbsp;(form&nbsp;source-condition-form))</tt>
<p><a name="./system:s6"></a><span class=formdef><b>syntax</b>: <tt>&amp;continuation</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-continuation-condition&nbsp;<i>continuation</i>)</tt></span>
<br>
<b>returns: </b>a condition of type <tt>&amp;continuation</tt>
<br><span class=formdef><b>procedure</b>: <tt>(continuation-condition?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition of type <tt>&amp;continuation</tt>, <tt>#f</tt> otherwise
<br><span class=formdef><b>procedure</b>: <tt>(condition-continuation&nbsp;<i>condition</i>)</tt></span>
<br>
<b>returns: </b>the contents of <tt><i>condition</i></tt>'s <tt>continuation</tt> field
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>

<p>This condition type can be included within a compound condition to indicate
the current continuation at the point where the exception described by the
condition occurred.
The continuation of a failed <tt>assert</tt> or a call to
<tt>assertion-violation</tt>, <tt>assertion-violationf</tt>,
<tt>error</tt>, <tt>errorf</tt>, or <tt>syntax-error</tt> is now included
via this condition type in the conditions passed to <tt>raise</tt>.
The <tt>continuation</tt> argument should be a continuation.
This condition type might be defined as follows.

<p><tt>(define-condition-type&nbsp;&amp;continuation&nbsp;&amp;condition<br>

&nbsp;&nbsp;make-continuation-condition&nbsp;continuation-condition?<br>

&nbsp;&nbsp;(continuation&nbsp;condition-continuation))</tt>
<p><a name="./system:s7"></a><span class=formdef><b>procedure</b>: <tt>(display-condition&nbsp;<i>obj</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(display-condition&nbsp;<i>obj</i>&nbsp;<i>textual-output-port</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>textual-output-port</i></tt> is not supplied, it defaults to the current output port.
This procedure displays a message to the effect that an exception
has occurred with value <tt><i>obj</i></tt>.
If <tt><i>obj</i></tt> is a condition (Chapter&nbsp;<a href="http://scheme.com/tspl4/./exceptions.html#g147">11</a> of
<i>The Scheme Programming Language, 4th Edition</i>), it displays information encapsulated within the condition,
handling messages, <tt><i>who</i></tt> conditions, irritants, source information,
etc., as appropriate.

<p>
<a name="./system:s8"></a><span class=formdef><b>procedure</b>: <tt>(default-exception-handler&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure is the default value of the <tt>base-exception-handler</tt>
parameter called on a condition when no other exception handler has been
defined or when all dynamically established exception handlers have chosen
not to handle the condition.
It first displays <tt><i>obj</i></tt>, as if with <tt>display-condition</tt>, to the
console error port.
For non-serious warning conditions, it returns immediately after displaying
the condition.

<p>
For serious or other non-warning conditions, it
saves the condition in the parameter <tt>debug-condition</tt>, where
<tt>debug</tt> (Section&nbsp;<a href="./debug.html#g17">3.2</a>) can retrieve it and
allow it to be inspected.
If the <tt>debug-on-exception</tt> parameter is set to <tt>#f</tt> (the
default unless the <a name="./system:s9"></a><tt>--debug-on-exception</tt> command-line option is provided), the
handler prints a message instructing the user to type <tt>(debug)</tt> to
enter the debugger, then resets to the current caf&eacute;.
Otherwise, the handler invokes <tt>debug</tt> directly and resets if
<tt>debug</tt> returns.

<p>
If an I/O exception occurs while attempting to display the condition,
the default exception handler resets (as if by calling <tt>reset</tt>).
The intent is to avoid an infinite regression (ultimately ending
in exhaustion of memory) in which the process repeatedly recurs
back to the default exception handler trying to write to a console-error
port (typically stderr) that is no longer writable, e.g., due to
the other end of a pipe or socket having been closed.

<p>
<a name="./system:s10"></a><span class=formdef><b>global parameter</b>: <tt>debug-on-exception</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of this parameter determines whether the default exception handler
immediately enters the debugger immediately when it receives a serious or
non-warning condition.
If the <a name="./system:s11"></a><tt>--debug-on-exception</tt>
command-line option (Section&nbsp;<a href="./use.html#g6">2.1</a>) has been provided, the
initial value of this parameter is <tt>#t</tt>.
Otherwise, the initial value is <tt>#f</tt>.


<p>
<a name="./system:s12"></a><span class=formdef><b>thread parameter</b>: <tt>base-exception-handler</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of this parameter must be a procedure, and the procedure
should accept one argument.
The default value of <tt>base-exception-handler</tt> is
the procedure <tt>default-exception-handler</tt>.

<p>
The value of this parameter is invoked whenever no exception handler
established by a program has chosen to handle an exception.

<p>
<a name="./system:s13"></a><span class=formdef><b>thread parameter</b>: <tt>debug-condition</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This parameter is used by the default exception handler to hold the
last serious or non-warning condition received by the handler, where
it can be inspected via the <tt>debug</tt> procedure
(Section&nbsp;<a href="./debug.html#g17">3.2</a>).
It can also be invoked by user code to store or retrieve a
condition.

<p>
<a name="./system:s14"></a><span class=formdef><b>thread parameter</b>: <tt>current-exception-state</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>current-exception-state</tt> may be used to get or set
the current exception state.
When called without arguments, <tt>current-exception-state</tt> returns
an <i>exception state</i> comprising the current stack of handlers established
by <tt>with-exception-handler</tt> and <tt>guard</tt>.
When called with a single argument, which must be an exception state,
<tt>current-exception-state</tt> sets the exception state.

<p>
<a name="./system:s15"></a><span class=formdef><b>procedure</b>: <tt>(create-exception-state)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(create-exception-state&nbsp;<i>procedure</i>)</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>create-exception-state</tt> creates an exception
state whose stack of exception handlers is empty except for, in effect,
an infinite number of occurrences of <i>handler</i> at its
base.
<tt><i>handler</i></tt> must be a procedure, and should accept one argument.
If not provided, <tt><i>handler</i></tt> defaults to a procedure equivalent
to the value of the following expression.

<p>

<p><tt>(lambda&nbsp;(x)&nbsp;((base-exception-handler)&nbsp;x))</tt>
<p>
<h3><a name="g113"></a><a name="./system:h2"></a>Section 12.2. Interrupts<a name="SECTSYSTEMINTERRUPTS"></a></h3>



<p>
<a name="./system:s16"></a><i>Chez&nbsp;Scheme</i> allows programs to control
the action of the Scheme system when various events
occur, including an interrupt from the
keyboard, the expiration of an internal timer set by <tt>set-timer</tt>,
a breakpoint caused by a call to <tt>break</tt>, or a request from the
storage manager to initiate a garbage collection.
These mechanisms are described in this section, except for the
collect request mechanism, which is described in Section&nbsp;<a href="./smgmt.html#g129">13.1</a>.

<p>
Timer, keyboard, and collect-request interrupts are supported via a counter
that is decremented approximately once for each call to a nonleaf procedure.
(A leaf procedure is one that does not itself make any calls.)
When no timer is running, this counter is set to a default value (1000
in Version&nbsp;9) when a program starts or after an interrupt occurs.
If a timer is set (via <tt>set-timer</tt>), the counter is set to the
minimum of the default value and the number of ticks to which the timer is
set.
When the counter reaches zero, the system looks to see if the timer
is set and has expired or if a keyboard or collect request interrupt
has occurred.
If so, the current procedure call is pended ("put on hold") while the
appropriate interrupt handler is invoked to handle the interrupt.
When (if) the interrupt handler returns, the pended call takes place.
Thus, timer, keyboard, and collect-request interrupts effectively occur
synchronously with respect to the procedure call mechanism, and
keyboard and collect request interrupts may be delayed by a number
of calls equal to the default timer value.

<p>
Calls to the break handler occur immediately
whenever <tt>break</tt> is called.

<p>
<a name="./system:s17"></a><span class=formdef><b>procedure</b>: <tt>(break&nbsp;<i>who</i>&nbsp;<i>msg</i>&nbsp;<i>irritant</i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(break&nbsp;<i>who</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(break)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The arguments to <tt>break</tt> follow the protocol described above for
<tt>errorf</tt>.
The default break handler (see <tt>break-handler</tt>) displays a message and
invokes the <a name="./system:s18"></a>debugger.
The format string and objects may be omitted, in which case the
message issued by the default break handler identifies the break
using the <tt><i>who</i></tt> argument but provides no more information
about the break.
If the <tt><i>who</i></tt> argument is omitted as well, no message is generated.
The default break handler returns normally if the debugger
exits normally.

<p>
<a name="./system:s19"></a><span class=formdef><b>thread parameter</b>: <tt>break-handler</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of this parameter must be a procedure.
The current break handler is called by <tt>break</tt>, which passes
along its arguments.
See <tt>break</tt> for a description of the default break
handler.
The example below shows how to disable breaks.

<p>

<p><tt>(break-handler&nbsp;(lambda&nbsp;args&nbsp;(void)))</tt>
<p><a name="./system:s20"></a><span class=formdef><b>thread parameter</b>: <tt>keyboard-interrupt-handler</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of this parameter must be a procedure.
The keyboard-interrupt handler is called (with no arguments) when
a keyboard interrupt occurs.
The default keyboard-interrupt handler invokes the interactive
<a name="./system:s21"></a>debugger.
If the debugger exits normally the interrupted computation is
resumed.
The example below shows how to install a keyboard-interrupt handler
that resets without invoking the debugger.

<p>

<p><tt>(keyboard-interrupt-handler<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(newline&nbsp;(console-output-port))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(reset)))</tt>
<p><a name="./system:s22"></a><a name="desc:set-timer"></a>
<span class=formdef><b>procedure</b>: <tt>(set-timer&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>previous current timer value
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./system:s23"></a><tt><i>n</i></tt> must be a nonnegative integer.
When <tt><i>n</i></tt> is nonzero, <tt>set-timer</tt> starts an internal timer with
an initial value of <tt><i>n</i></tt>.
When <tt><i>n</i></tt> ticks elapse, a timer interrupt occurs, resulting in
invocation of the timer interrupt handler.
Each tick corresponds roughly to one nonleaf procedure call (see the
introduction to this section); thus, ticks are not
uniform time units but instead depend heavily on how much work is done
by each procedure call.

<p>
When <tt><i>n</i></tt> is zero, <tt>set-timer</tt> turns the timer off.

<p>
The value returned in either case is the value of the timer before the
call to <tt>set-timer</tt>.
A return value of 0 should not be taken to imply that the timer was not on;
the return value may also be 0 if the timer was just about to fire when
the call to <tt>set-timer</tt> occurred.

<p>
The engine mechanism (Section&nbsp;<a href="./control.html#g46">6.4</a>) is built on top of the
timer interrupt so timer interrupts should not be used with engines.


<p>
<a name="./system:s24"></a><span class=formdef><b>thread parameter</b>: <tt>timer-interrupt-handler</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./system:s25"></a>The value of this parameter must be a procedure.
The timer interrupt handler is called by the system when the internal timer
(set by <tt>set-timer</tt>) expires.
The default handler raises an exception with condition type <tt>&amp;assertion</tt>
to say that the handler has not
been defined; any program that uses the timer should redefine the
handler before setting the timer.

<p>
<a name="./system:s26"></a><span class=formdef><b>procedure</b>: <tt>(disable-interrupts)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(enable-interrupts)</tt></span>
<br>
<b>returns: </b>disable count
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>disable-interrupts</tt> disables the handling of interrupts,
including timer, keyboard, and collect request interrupts.
<tt>enable-interrupts</tt> re-enables these interrupts.
The system maintains a disable count that starts at zero; when zero,
interrupts are enabled.
Each call to <tt>disable-interrupts</tt> increments the count,
effectively disabling interrupts.
Each call to <tt>enable-interrupts</tt> decrements the count, if
not already zero, effectively enabling interrupts.
For example, two calls to <tt>disable-interrupts</tt> followed by one call to
<tt>enable-interrupts</tt> leaves interrupts disabled.
Calls to <tt>enable-interrupts</tt> when the count is already zero
(and interrupts are enabled) have no effect.
The value returned by either procedure is the number of calls to
<tt>enable-interrupts</tt> required to enable interrupts.

<p>
Great care should be exercised when using these procedures, since disabling
interrupts inhibits the normal processing of keyboard interrupts,
timer interrupts, and, perhaps most importantly, collect request interrupts.
Since garbage collection does not happen automatically when interrupts are
disabled, it is possible for the storage allocator to run out of space
unnecessarily should interrupts be disabled for a long period of time.

<p>
The <tt>with-interrupts-disabled</tt> syntactic form should be used instead of
these more primitive procedures whenever possible,
since <tt>with-interrupts-disabled</tt> ensures that interrupts are re-enabled
whenever a nonlocal exit occurs, such as when an exception is handled by
the default exception handler.


<p>
<a name="./system:s27"></a><span class=formdef><b>syntax</b>: <tt>(with-interrupts-disabled&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>(critical-section&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the values of the body <tt><i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>with-interrupts-disabled</tt> evaluates the body
<tt><i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...</tt> with interrupts disabled.
That is, upon entry, interrupts are disabled, and
upon exit, interrupts are re-enabled.
Thus, <tt>with-interrupts-disabled</tt> allows the implementation of indivisible
operations in nonthreaded versions of <i>Chez&nbsp;Scheme</i> or within a single thread
in threaded versions of <i>Chez&nbsp;Scheme</i>.
<tt>critical-section</tt> is the same as <tt>with-interrupts-disabled</tt> and
is provided for backward compatibility.

<p>
<tt>with-interrupts-disabled</tt> can be defined as follows.

<p>

<p><tt>(define-syntax&nbsp;with-interrupts-disabled<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dynamic-wind<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disable-interrupts<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enable-interrupts)]))</tt>
<p>The use of <tt>dynamic-wind</tt> ensures that interrupts are
disabled whenever the body of the <tt>with-interrupts-disabled</tt> expression
is active and re-enabled whenever it is not.
Since calls to <tt>disable-interrupts</tt> are counted (see the
discussion under <tt>disable-interrupts</tt> and
<tt>enable-interrupts</tt> above), <tt>with-interrupts-disabled</tt>
expressions may be nested with the desired effect.


<p>
<a name="./system:s28"></a><span class=formdef><b>procedure</b>: <tt>(register-signal-handler&nbsp;<i>sig</i>&nbsp;<i>procedure</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>register-signal-handler</tt> is used to
establish a signal handler for a given low-level signal.
<tt><i>sig</i></tt> must be an exact integer identifying a valid signal, and
<tt><i>procedure</i></tt> should accept one argument.
See your host system's <tt>&lt;signal.h&gt;</tt> or documentation for a list
of valid signals and their numbers.
After a signal handler for a given signal has been registered, receipt
of the specified signal results in a call to the handler.
The handler is passed the signal number, allowing the same handler to
be used for different signals while differentiating among them.

<p>
Signals handled in this fashion are treated like keyboard interrupts in
that the handler is not called immediately when the signal is delivered
to the process, but rather at some procedure call boundary after the
signal is delivered.
It is generally not a good idea, therefore, to establish handlers for
memory faults, illegal instructions, and the like, since the code that
causes the fault or illegal instruction will continue to execute
(presumably erroneously) for some time before the handler is invoked.
A finite amount of storage is used to buffer as-yet unhandled
signals, after which additional signals are dropped.

<p>
<tt>register-signal-handler</tt> is supported only on Unix-based
systems.


<p>

<h3><a name="g114"></a><a name="./system:h3"></a>Section 12.3. Environments<a name="SECTMISCENVIRONMENTS"></a></h3>



<p>
Environments are first-class objects containing identifier bindings.
They are similar to modules but, unlike modules, may be manipulated
at run time.
Environments may be provided as optional arguments to <tt>eval</tt>,
<tt>expand</tt>, and the procedures that define, assign, or
reference top-level values.

<p>
There are several built-in environments, and new environments can
be created by copying existing environments or selected bindings
from existing environments.

<p>
Environments can be mutable or immutable.
A mutable environment can be extended with new bindings, its
existing bindings can be modified, and its variables can be assigned.
An immutable environment cannot be modified in any of these ways.

<p>
<a name="./system:s29"></a><span class=formdef><b>procedure</b>: <tt>(environment?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an environment, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>(environment?&nbsp;(interaction-environment))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(environment?&nbsp;'interaction-environment)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(environment?&nbsp;(copy-environment&nbsp;(scheme-environment)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(environment?&nbsp;(environment&nbsp;'(prefix&nbsp;(rnrs)&nbsp;$rnrs-)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./system:s30"></a><span class=formdef><b>procedure</b>: <tt>(environment-mutable?&nbsp;<i>env</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>env</i></tt> is mutable, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>(environment-mutable?&nbsp;(interaction-environment))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(environment-mutable?&nbsp;(scheme-environment))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(environment-mutable?&nbsp;(copy-environment&nbsp;(scheme-environment)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(environment-mutable?&nbsp;(environment&nbsp;'(prefix&nbsp;(rnrs)&nbsp;$rnrs-)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./system:s31"></a><span class=formdef><b>procedure</b>: <tt>(scheme-environment)</tt></span>
<br>
<b>returns: </b>an environment
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>scheme-environment</tt> returns an environment containing
the initial top-level bindings.
This environment corresponds to the <tt>scheme</tt> module.

<p>
The environment returned by this procedure is immutable.

<p>

<p><tt>(define&nbsp;cons&nbsp;3)<br>

(top-level-value&nbsp;'cons&nbsp;(scheme-environment))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;procedure&nbsp;cons&gt;<br>

(set-top-level-value!&nbsp;'cons&nbsp;3&nbsp;(scheme-environment))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception</i></tt>
<p><a name="./system:s32"></a><span class=formdef><b>procedure</b>: <tt>(ieee-environment)</tt></span>
<br>
<b>returns: </b>an IEEE/ANSI standard compatibility environment
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>ieee-environment</tt> returns an environment containing
bindings for the keywords and variables whose meanings are
defined by the IEEE/ANSI Standard for Scheme&nbsp;[<a class=citation href="./bibliography.html#g177">26</a>].

<p>
The bindings for each of the identifiers in the IEEE environment are those
of the corresponding Revised<sup>6</sup> Report library, so this does not provide
full backward compatibility.

<p>
The environment returned by this procedure is immutable.

<p>

<p><tt>(define&nbsp;cons&nbsp;3)<br>

(top-level-value&nbsp;'cons&nbsp;(ieee-environment))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;procedure&nbsp;cons&gt;<br>

(set-top-level-value!&nbsp;'cons&nbsp;3&nbsp;(ieee-environment))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception</i></tt>
<p><a name="./system:s33"></a><span class=formdef><b>thread parameter</b>: <tt>interaction-environment</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The original value of <tt>interaction-environment</tt> is the default
top-level environment.
It is initially set to a mutable copy of
<tt>(scheme-environment)</tt> and which may be extended or otherwise
altered by top-level definitions and assignments.
It may be set to any environment, mutable or not, to change the
default top-level evaluation environment.

<p>
An expression's top-level bindings resolve to the environment that is
in effect when the expression is expanded, and changing the value
of this parameter has no effect on running code.
Changes affect only code that is subsequently expanded, e.g., as the
result of a call to <tt>eval</tt>, <tt>load</tt>, or
<tt>compile-file</tt>.

<p>

<p><tt>(define&nbsp;cons&nbsp;3)<br>

cons&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(top-level-value&nbsp;'cons&nbsp;(interaction-environment))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3
<br>
<br>
(interaction-environment&nbsp;(scheme-environment))<br>

cons&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;procedure&nbsp;cons&gt;<br>

(set!&nbsp;cons&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;attempt&nbsp;to&nbsp;assign&nbsp;immutable&nbsp;variable</i><br>

(define&nbsp;cons&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;invalid&nbsp;definition&nbsp;in&nbsp;immutable&nbsp;environment</i></tt>
<p><a name="./system:s34"></a><span class=formdef><b>procedure</b>: <tt>(copy-environment&nbsp;<i>env</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(copy-environment&nbsp;<i>env</i>&nbsp;<i>mutable?</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(copy-environment&nbsp;<i>env</i>&nbsp;<i>mutable?</i>&nbsp;<i>syms</i>)</tt></span>
<br>
<b>returns: </b>a new environment
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>copy-environment</tt> returns a copy of <tt><i>env</i></tt>, i.e., a new
environment that contains the same bindings as <tt><i>env</i></tt>.

<p>
The environment is mutable if <tt><i>mutable?</i></tt> is omitted or true;
if <tt><i>mutable?</i></tt> is false, the environment is immutable.

<p>
The set of bindings copied from <tt><i>env</i></tt> to the new environment
is determined by <tt><i>syms</i></tt>, which defaults to the value of
<tt>(environment-symbols&nbsp;<i>env</i>)</tt>.
The binding, if any, for each element of <tt><i>syms</i></tt> is copied to the
new environment, and no other bindings are present in the new
environment.

<p>
In the current implementation, the storage space used by an environment
is never collected, so repeated use of <tt>copy-environment</tt> will
eventually cause the system to run out of memory.

<p>

<p><tt>(define&nbsp;e&nbsp;(copy-environment&nbsp;(scheme-environment)))<br>

(eval&nbsp;'(define&nbsp;cons&nbsp;+)&nbsp;e)<br>

(eval&nbsp;'(cons&nbsp;3&nbsp;4)&nbsp;e)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;7<br>

(eval&nbsp;'(cons&nbsp;3&nbsp;4)&nbsp;(scheme-environment))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(3&nbsp;.&nbsp;4)</tt>
<p><a name="./system:s35"></a><span class=formdef><b>procedure</b>: <tt>(environment-symbols&nbsp;<i>env</i>)</tt></span>
<br>
<b>returns: </b>a list of symbols
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure returns a list of symbols representing the identifiers
bound in environment <tt><i>env</i></tt>.
It is primarily useful in building the list of symbols to be copied
from one environment to another.

<p>

<p><tt>(define&nbsp;listless-environment<br>

&nbsp;&nbsp;(copy-environment<br>

&nbsp;&nbsp;&nbsp;&nbsp;(scheme-environment)<br>

&nbsp;&nbsp;&nbsp;&nbsp;#t<br>

&nbsp;&nbsp;&nbsp;&nbsp;(remq&nbsp;'list&nbsp;(environment-symbols&nbsp;(scheme-environment)))))<br>

(eval&nbsp;'(let&nbsp;([x&nbsp;(cons&nbsp;3&nbsp;4)])&nbsp;x)&nbsp;listless-environment)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(3&nbsp;.&nbsp;4)<br>

(eval&nbsp;'(list&nbsp;3&nbsp;4)&nbsp;listless-environment)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception</i></tt>
<p><a name="./system:s36"></a><span class=formdef><b>procedure</b>: <tt>(apropos-list&nbsp;<i>s</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(apropos-list&nbsp;<i>s</i>&nbsp;<i>env</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure returns a selected list of symbols and pairs.
Each symbol in the list represents an identifier bound in <tt><i>env</i></tt>.
Each pair represents a set of identifiers exported by a
predefined library or a library previously defined or loaded
into the system.
The car of the pair is the library name, and the cdr is a list
of symbols.
If <tt><i>s</i></tt> is a string, only entries whose names have <tt><i>s</i></tt> as a
substring are included, and if <tt><i>s</i></tt> is a symbol, only those whose names
have the name of <tt><i>s</i></tt> as a substring are selected.
If no environment is provided, it defaults to the value of
<tt>interaction-environment</tt>.

<p>

<p><tt>(library&nbsp;(a)&nbsp;(export&nbsp;a-vector-sortof)&nbsp;(import&nbsp;(rnrs))<br>

&nbsp;&nbsp;(define&nbsp;a-vector-sortof&nbsp;'(vector&nbsp;1&nbsp;2&nbsp;3)))<br>

(apropos-list&nbsp;'vector-sort)&nbsp;<img src="math/csug/0.gif" alt="<graphic>"><br>

&nbsp;&nbsp;(vector-sort&nbsp;vector-sort!<br>

&nbsp;&nbsp;&nbsp;((a)&nbsp;a-vector-sortof)<br>

&nbsp;&nbsp;&nbsp;((chezscheme)&nbsp;vector-sort&nbsp;vector-sort!)<br>

&nbsp;&nbsp;&nbsp;((rnrs)&nbsp;vector-sort&nbsp;vector-sort!)<br>

&nbsp;&nbsp;&nbsp;((rnrs&nbsp;sorting)&nbsp;vector-sort&nbsp;vector-sort!)<br>

&nbsp;&nbsp;&nbsp;((scheme)&nbsp;vector-sort&nbsp;vector-sort!))</tt>
<p><a name="./system:s37"></a><span class=formdef><b>procedure</b>: <tt>(apropos&nbsp;<i>s</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(apropos&nbsp;<i>s</i>&nbsp;<i>env</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>apropos</tt> is like <tt>apropos-list</tt> except the information is
displayed to the current output port, as shown in the following
transcript.

<p>

<p><tt>&gt;&nbsp;(library&nbsp;(a)&nbsp;(export&nbsp;a-vector-sortof)&nbsp;(import&nbsp;(rnrs))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;a-vector-sortof&nbsp;'(vector&nbsp;1&nbsp;2&nbsp;3)))<br>

&gt;&nbsp;(apropos&nbsp;'vector-sort)<br>

interaction&nbsp;environment:<br>

&nbsp;&nbsp;vector-sort,&nbsp;vector-sort!<br>

(a):<br>

&nbsp;&nbsp;a-vector-sortof<br>

(chezscheme):<br>

&nbsp;&nbsp;vector-sort,&nbsp;vector-sort!<br>

(rnrs):<br>

&nbsp;&nbsp;vector-sort,&nbsp;vector-sort!<br>

(rnrs&nbsp;sorting):<br>

&nbsp;&nbsp;vector-sort,&nbsp;vector-sort!<br>

(scheme):<br>

&nbsp;&nbsp;vector-sort,&nbsp;vector-sort!</tt>
<p>
<h3><a name="g115"></a><a name="./system:h4"></a>Section 12.4. Compilation, Evaluation, and Loading<a name="SECTMISCCOMPILEEVAL"></a></h3>




<p>
<a name="./system:s38"></a><span class=formdef><b>procedure</b>: <tt>(eval&nbsp;<i>obj</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(eval&nbsp;<i>obj</i>&nbsp;<i>env</i>)</tt></span>
<br>
<b>returns: </b>value of the Scheme form represented by <tt><i>obj</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>eval</tt> treats <tt><i>obj</i></tt> as the representation of an expression.
It evaluates the expression in environment <tt><i>env</i></tt> and returns
its value.
If no environment is provided, it defaults to the environment
returned by <tt>interaction-environment</tt>.

<p>
Single-argument <tt>eval</tt> is a <i>Chez&nbsp;Scheme</i> extension.
<i>Chez&nbsp;Scheme</i> also permits <tt><i>obj</i></tt> to be the representation of a
nonexpression form, i.e., a definition, whenever the environment
is mutable.
<i>Chez&nbsp;Scheme</i> further allows <tt><i>obj</i></tt> to be an annotation
(Section&nbsp;<a href="./syntax.html#g109">11.11</a>), and the default evaluators
make use of annotations to incorporate source-file
information in error messages and associate source-file
information with compiled code.

<p>
In <i>Chez&nbsp;Scheme</i>, <tt>eval</tt> is actually a wrapper that simply
passes its arguments to the current evaluator.
(See <tt>current-eval</tt>.)
The default evaluator is <tt>compile</tt>, which expands the
expression via the current expander (see
<tt>current-expand</tt>), compiles it,
executes the resulting code, and returns its value.
If the environment argument, <tt><i>env</i></tt>, is present,
<tt>compile</tt> passes it along to the current expander,
which is <tt>sc-expand</tt> by default.


<p>
<a name="./system:s39"></a><span class=formdef><b>thread parameter</b>: <tt>current-eval</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>current-eval</tt> determines the evaluation procedure used by the
procedures <a name="./system:s40"></a><tt>eval</tt>, <tt>load</tt>, and
<tt>new-cafe</tt>.
<tt>current-eval</tt> is initially bound to the value of
<a name="./system:s41"></a><tt>compile</tt>.
(In <i>Petite&nbsp;Chez&nbsp;Scheme</i>, it is initially bound to the value of
<a name="./system:s42"></a><tt>interpret</tt>.)
The evaluation procedure should expect one or two arguments: an object
to evaluate and an optional environment.
The second argument might be an annotation
(Section&nbsp;<a href="./syntax.html#g109">11.11</a>).

<p>

<p><tt>(current-eval&nbsp;interpret)<br>

(+&nbsp;1&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2
<br>
<br>
(current-eval&nbsp;(lambda&nbsp;(x&nbsp;.&nbsp;ignore)&nbsp;x))<br>

(+&nbsp;1&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(+&nbsp;1&nbsp;1)</tt>
<p><a name="./system:s43"></a><span class=formdef><b>procedure</b>: <tt>(compile&nbsp;<i>obj</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(compile&nbsp;<i>obj</i>&nbsp;<i>env</i>)</tt></span>
<br>
<b>returns: </b>value of the Scheme form represented by <tt><i>obj</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>obj</i></tt>, which can be an annotation (Section&nbsp;<a href="./syntax.html#g109">11.11</a>)
or unannotated value, is treated as a Scheme expression, expanded with the
current expander (the value of <tt>current-expand</tt>) in the specified
environment (or the interaction environment, if no environment
is provided), compiled to machine code, and executed.
<tt>compile</tt> is the default value of the <tt>current-eval</tt>
parameter.


<p>
<a name="./system:s44"></a><span class=formdef><b>procedure</b>: <tt>(interpret&nbsp;<i>obj</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(interpret&nbsp;<i>obj</i>&nbsp;<i>env</i>)</tt></span>
<br>
<b>returns: </b>value of the Scheme form represented by <tt><i>obj</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>interpret</tt> is like <tt>compile</tt>, except that the expression
is interpreted rather than compiled.
<tt>interpret</tt> may be used as a replacement for <tt>compile</tt>,
with the following caveats:

<p>
<ul>
<li>Interpreted code runs significantly slower.

<p>
<li>Inspector information is not generated for
interpreted code, so the inspector is not as useful for interpreted
code as it is for compiled code.

<p>
<li>Foreign procedure expressions cannot be
interpreted, so the interpreter invokes the compiler for all
foreign procedure expressions (this is done transparently).
</ul>
<p>

<p>
<tt>interpret</tt> is sometimes faster than <tt>compile</tt> when the
form to be evaluated is short running, since it avoids some of the
work done by <tt>compile</tt> prior to evaluation.


<p>
<a name="./system:s45"></a><span class=formdef><b>procedure</b>: <tt>(load&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(load&nbsp;<i>path</i>&nbsp;<i>eval-proc</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt>load</tt> reads and evaluates the contents of the file specified by
<tt><i>path</i></tt>.
The file may contain source or object code.
By default, <tt>load</tt> employs <tt>eval</tt> to evaluate each source
expression found in a source file.
If <tt><i>eval-proc</i></tt> is specified, <tt>load</tt> uses this procedure instead.
<tt><i>eval-proc</i></tt> must accept one argument, the expression to evaluate.
The expression passed to <tt><i>eval-proc</i></tt> might be an annotation
(Section&nbsp;<a href="./syntax.html#g109">11.11</a>) or an unannotated value.

<p>
The <tt><i>eval-proc</i></tt> argument
facilitates the implementation of embedded Scheme-like languages
and the use of alternate
evaluation mechanisms to be used for Scheme programs.
<tt><i>eval-proc</i></tt> can be put to other uses as well.
For example,

<p>

<p><tt>(load&nbsp;"myfile.ss"<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(pretty-print<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(annotation?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(annotation-stripped&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(newline)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(eval&nbsp;x)))</tt>
<p>pretty-prints each expression before evaluating it.

<p>
<a name="./system:s46"></a>The parameter <tt>source-directories</tt> (Section&nbsp;<a href="./system.html#g116">12.5</a>)
determines the set of directories searched for source files not identified
by absolute path names.

<p>
<a name="./system:s47"></a><span class=formdef><b>procedure</b>: <tt>(load-library&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(load-library&nbsp;<i>path</i>&nbsp;<i>eval-proc</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>load-library</tt> is identical to <tt>load</tt> except
that it treats the input file as if it were prefixed by an implicit
<tt>#!r6rs</tt>.
This effectively disables any non-R6RS lexical
syntax except where subsequently overridden by <tt>#!chezscheme</tt>.


<p>
<a name="./system:s48"></a><span class=formdef><b>procedure</b>: <tt>(load-program&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(load-program&nbsp;<i>path</i>&nbsp;<i>eval-proc</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt>load-program</tt> reads and evaluates the contents of the file specified by
<tt><i>path</i></tt>.
The file may contain source or object code.
If it contains source code, <tt>load-program</tt> wraps
the code in a <tt>top-level-program</tt> form so that the file's
content is treated as an RNRS top-level program
(Section&nbsp;<a href="http://scheme.com/tspl4/./libraries.html#g145">10.3</a> of <i>The Scheme Programming Language, 4th Edition</i>).
By default, <tt>load-program</tt> employs <tt>eval</tt> to evaluate each source
expression found in the file.
If <tt><i>eval-proc</i></tt> is specified, <tt>load-program</tt> uses this procedure instead.
<tt><i>eval-proc</i></tt> must accept one argument, the expression to evaluate.
The expression passed to <tt><i>eval-proc</i></tt> might be an annotation
(Section&nbsp;<a href="./syntax.html#g109">11.11</a>) or an unannotated value.

<p>
<a name="./system:s49"></a>The parameter <tt>source-directories</tt> (Section&nbsp;<a href="./system.html#g116">12.5</a>)
determines the set of directories searched for source files not identified
by absolute path names.


<p>
<a name="./system:s50"></a><span class=formdef><b>procedure</b>: <tt>(verify-loadability&nbsp;<i>situation</i>&nbsp;<i>input</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>situation</i></tt> must be one of the symbols <tt>visit</tt>, <tt>revisit</tt>, or <tt>load</tt>.
Each <tt><i>input</i></tt> must be a string pathname or a pair of a string pathname and a library search path.
Each of the pathnames should name a file containing object code for a set of libraries and
top-level programs, such as would be produced by
<a name="./system:s51"></a><tt>compile-program</tt>,
<a name="./system:s52"></a><tt>compile-library</tt>,
<a name="./system:s53"></a><tt>compile-whole-program</tt>,
or
<a name="./system:s54"></a><tt>compile-whole-library</tt>.
A library search path must be a suitable argument for
<a name="./system:s55"></a><tt>library-directories</tt>.

<p>
<tt>verify-loadability</tt> verifies, without actually loading any
code or defining any libraries, whether the object files named
by the specified pathnames and their library dependencies, direct
or indirect, are present, readable, and mutually compatible.
The type of dependencies for each named object file is determined
by the <tt><i>situation</i></tt> argument: compile-time dependencies for
<tt><i>visit</i></tt>, run-time dependencies for <tt><i>revisit</i></tt> and both for
<tt><i>load</i></tt>.

<p>
For each input pathname that is paired with a search path,
the <tt>library-directories</tt> parameter is parameterized to the
library search path during the recursive search for dependencies
of the programs and libraries found in the object file named by the
pathname.

<p>
If <tt>verify-loadability</tt> finds a problem, such as a missing
library dependency or compilation-instance mismatch, it raises an
exception with an appropriate condition.
Otherwise, it returns an unspecified value.

<p>
Since <tt>verify-loadability</tt> does not load or run any code
from the files it processes, it cannot determine whether errors
unrelated to missing or unreadable files or mutual compatibility
will occur when the files are actually loaded.


<p>
<a name="./system:s56"></a><span class=formdef><b>procedure</b>: <tt>(load-compiled-from-port&nbsp;<i>input-port</i>)</tt></span>
<br>
<b>returns: </b>result of the last compiled expression
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>load-compiled-from-port</tt> reads and evaluates the object-code contents
of <tt><i>input-port</i></tt> as previously created by functions like <tt>compile-file</tt>,
<tt>compile-script</tt>, <tt>compile-library</tt>, and
<tt>compile-to-port</tt>.

<p>
The return value is the value of the last expression whose compiled
form is in <tt><i>input-port</i></tt>. If <tt><i>input-port</i></tt> is empty, then the
result value is unspecified.
The port is left at end-of-file but is not closed.


<p>
<a name="./system:s57"></a><span class=formdef><b>procedure</b>: <tt>(visit-compiled-from-port&nbsp;<i>input-port</i>)</tt></span>
<br>
<b>returns: </b>result of the last compiled expression processed
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>visit-compiled-from-port</tt> reads and evaluates the object-code contents
of <tt><i>input-port</i></tt> as previously created by functions like <tt>compile-file</tt>,
<tt>compile-script</tt>, <tt>compile-library</tt>, and
<tt>compile-to-port</tt>.  In the process, it skips any revisit (run-time-only) code.

<p>
The return value is the value of the last expression whose last non-revisit compiled
form is in <tt><i>input-port</i></tt>. If there are no such forms, then the
result value is unspecified.
The port is left at end-of-file but is not closed.


<p>
<a name="./system:s58"></a><span class=formdef><b>procedure</b>: <tt>(revisit-compiled-from-port&nbsp;<i>input-port</i>)</tt></span>
<br>
<b>returns: </b>result of the last compiled expression processed
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>revisit-compiled-from-port</tt> reads and evaluates the object-code contents
of <tt><i>input-port</i></tt> as previously created by functions like <tt>compile-file</tt>,
<tt>compile-script</tt>, <tt>compile-library</tt>, and
<tt>compile-to-port</tt>.  In the process, it skips any visit (compile-time-only) code.

<p>
The return value is the value of the last expression whose last non-visit compiled
form is in <tt><i>input-port</i></tt>. If there are no such forms, then the
result value is unspecified.
The port is left at end-of-file but is not closed.


<p>
<a name="./system:s59"></a><span class=formdef><b>procedure</b>: <tt>(visit&nbsp;<i>path</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt>visit</tt> reads the named file, which must contain compiled object
code compatible with the current machine type and version, and it
runs those portions of the compiled object code that
establish compile-time information or correspond to expressions
identified as "visit" time by <tt>eval-when</tt> forms contained in
the original source file.

<p>
For example, assume the file <tt>t1.ss</tt> contains the following
forms:

<p>

<p><tt>(define-syntax&nbsp;a&nbsp;(identifier-syntax&nbsp;3))<br>

(module&nbsp;m&nbsp;(x)&nbsp;(define&nbsp;x&nbsp;4))<br>

(define&nbsp;y&nbsp;5)</tt>
<p>If <tt>t1.ss</tt> is compiled to <tt>t1.so</tt>, applying <tt>load</tt>
to <tt>t1.so</tt> has the effect of defining all three identifiers.
Applying <tt>visit</tt> to <tt>t1.so</tt>, however, has the effect of
installing the transformer for <tt>a</tt>, installing the interface for
<tt>m</tt> (for use by <tt>import</tt>),  and recording <tt>y</tt> as
a variable.
<tt>visit</tt> is useful when separately compiling one file that depends
on bindings defined in another without actually loading and evaluating
the code in the supporting file.

<p>
<a name="./system:s60"></a>The parameter <tt>source-directories</tt> (Section&nbsp;<a href="./system.html#g116">12.5</a>)
determines the set of directories searched for source files not identified
by absolute path names.

<p>
<a name="./system:s61"></a><span class=formdef><b>procedure</b>: <tt>(revisit&nbsp;<i>path</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt>revisit</tt> reads the named file, which must contain compiled object
code compatible with the current machine type and version, and it
runs those portions of the compiled object code that compute
run-time values or correspond to expressions identified as "revisit" time by
<tt>eval-when</tt> forms contained in the original source file.

<p>
Continuing the example given for <tt>visit</tt> above,
applying <tt>revisit</tt> to the object file, <tt>t1.so</tt>, has
the effect of establishing the values of the variable <tt>x</tt>
exported from <tt>m</tt> and the top-level variable <tt>y</tt>,
without installing either the interface for <tt>m</tt> or
the transformer for <tt>a</tt>.

<p>
<tt>revisit</tt> is useful for loading compiled application code without
loading unnecessary compile-time information.
Care must be taken when using this feature if the application calls
<tt>eval</tt> or uses <tt>top-level-value</tt>,
<tt>set-top-level-value!</tt>, or <tt>top-level-syntax</tt> to access
top-level bindings at run-time, since these procedures use compile-time
information to resolve top-level bindings.

<p>
<a name="./system:s62"></a>The parameter <tt>source-directories</tt> (Section&nbsp;<a href="./system.html#g116">12.5</a>)
determines the set of directories searched for source files not identified
by absolute path names.

<p>
<a name="./system:s63"></a><span class=formdef><b>procedure</b>: <tt>(compile-file&nbsp;<i>input-filename</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(compile-file&nbsp;<i>input-filename</i>&nbsp;<i>output-filename</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>input-filename</i></tt> and <tt><i>output-filename</i></tt> must be strings.
<tt><i>input-filename</i></tt> must name an existing, readable file.
It must contain a sequence of zero or more source expressions;
if this is not the case, <tt>compile-file</tt> raises an exception
with condition type <tt>&amp;syntax</tt>.

<p>
The normal evaluation process proceeds in two steps: <a name="./system:s64"></a>compilation and
execution.
<tt>compile-file</tt> performs the compilation process for an entire source
file, producing an object file.
When the object file is subsequently loaded (see <a name="./system:s65"></a><tt>load</tt>), the
compilation process is not necessary, and the file typically loads
several times faster.

<p>
If the optional <tt><i>output-filename</i></tt> argument is omitted, the
actual input and output filenames are determined as follows.
If <tt><i>input-filename</i></tt> has no extension, the input filename
is <tt><i>input-filename</i></tt> followed by <tt>.ss</tt>  and the
output filename is <tt><i>input-filename</i></tt> followed by <tt>.so</tt>.
If <tt><i>input-filename</i></tt> has the extension <tt>.so</tt>, the
input filename is <tt><i>input-filename</i></tt> and the output filename
is <tt><i>input-filename</i></tt> followed by <tt>.so</tt>.
Otherwise, the input filename is <tt><i>input-filename</i></tt> and the
output filename is <tt><i>input-filename</i></tt> without its extension,
followed by <tt>.so</tt>.
For example, <tt>(compile-file&nbsp;"myfile")</tt> produces an object file
with the name <tt>"myfile.so"</tt> from the source file named
<tt>"myfile.ss"</tt>, <tt>(compile-file&nbsp;"myfile.sls")</tt> produces an
object file with the name <tt>"myfile.so"</tt> from the source file named
<tt>"myfile.sls"</tt>, and
<tt>(compile-file&nbsp;"myfile1"&nbsp;"myfile2")</tt> produces an object file with
the name <tt>"myfile2"</tt> from the source file name <tt>"myfile1"</tt>.

<p>
Before compiling a file, <tt>compile-file</tt> saves the values of the
following parameters:

<p>

<p><tt>optimize-level<br>

debug-level<br>

run-cp0<br>

cp0-effort-limit<br>

cp0-score-limit<br>

cp0-outer-unroll-limit<br>

generate-inspector-information<br>

generate-procedure-source-information<br>

compile-profile<br>

generate-covin-files<br>

generate-interrupt-trap<br>

enable-cross-library-optimization</tt>
<p>It restores the values after the file has been compiled.
This allows the programmer to control the values of these parameters on
a per-file basis, e.g., via an <tt>eval-when</tt> with situation
<tt>compile</tt> embedded in the source file.
For example, if

<p>

<p><tt>(eval-when&nbsp;(compile)&nbsp;(optimize-level&nbsp;3))</tt>
<p>appears at the top of a source file, the optimization level is set
to 3 just while the remainder of file is compiled.

<p>
<a name="./system:s66"></a><span class=formdef><b>procedure</b>: <tt>(compile-script&nbsp;<i>input-filename</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(compile-script&nbsp;<i>input-filename</i>&nbsp;<i>output-filename</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>input-filename</i></tt> and <tt><i>output-filename</i></tt> must be strings.

<p>
<tt>compile-script</tt> is like <tt>compile-file</tt> but differs in
that it copies the leading <tt>#!</tt> line from the
source-file script into the object file.

<p>
<tt>compile-script</tt> permits compiled script files to be created from
source script to reduce script load time.
As with source-code scripts, compiled scripts may be run with the
<a name="./system:s67"></a><tt>--script</tt>
command-line option.

<p>
<a name="./system:s68"></a><span class=formdef><b>procedure</b>: <tt>(compile-library&nbsp;<i>input-filename</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(compile-library&nbsp;<i>input-filename</i>&nbsp;<i>output-filename</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>input-filename</i></tt> and <tt><i>output-filename</i></tt> must be strings.

<p>
<tt>compile-library</tt> is identical to <tt>compile-file</tt> except
that it treats the input file as if it were prefixed by an implicit
<tt>#!r6rs</tt>.
This effectively disables any non-R6RS lexical
syntax except where subsequently overridden by <tt>#!chezscheme</tt>.

<p>
<a name="./system:s69"></a><span class=formdef><b>procedure</b>: <tt>(compile-program&nbsp;<i>input-filename</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(compile-program&nbsp;<i>input-filename</i>&nbsp;<i>output-filename</i>)</tt></span>
<br>
<b>returns: </b>a list of libraries invoked by the program
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>input-filename</i></tt> and <tt><i>output-filename</i></tt> must be strings.

<p>
<tt>compile-program</tt> is like <tt>compile-script</tt> but differs in
that it implements the semantics of RNRS top-level programs, while
<tt>compile-script</tt> implements the semantics of the interactive
top-level.
The resulting compiled program will also run faster than if compiled
via <tt>compile-file</tt> or <tt>compile-script</tt>.

<p>
<tt>compile-program</tt> returns a list of libraries directly
invoked by the compiled top-level program, excluding built-in
libraries like <tt>(rnrs)</tt> and <tt>(chezscheme)</tt>.
The procedure <tt>library-requirements</tt> may be used to determine
the indirect requirements, i.e., additional libraries required by
the directly invoked libraries.
When combined with <tt>library-object-filename</tt>, this information can
be used to determine the set of files that must be distributed with the
compiled program file.

<p>
A program invokes a library only if it references one or more variables
exported from the library.
The set of libraries invoked by a top-level program, and hence
loaded when the program is loaded, might be smaller than the set
imported by the program, and it might be larger than the set
directly imported by the program.

<p>
As with source-code top-level programs, compiled top-level programs may be
run with the
<a name="./system:s70"></a><tt>--program</tt>
command-line option.

<p>
<a name="./system:s71"></a><span class=formdef><b>procedure</b>: <tt>(maybe-compile-file&nbsp;<i>input-filename</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(maybe-compile-file&nbsp;<i>input-filename</i>&nbsp;<i>output-filename</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(maybe-compile-library&nbsp;<i>input-filename</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(maybe-compile-library&nbsp;<i>input-filename</i>&nbsp;<i>output-filename</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(maybe-compile-program&nbsp;<i>input-filename</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(maybe-compile-program&nbsp;<i>input-filename</i>&nbsp;<i>output-filename</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These procedures are like their non-<tt>maybe</tt> counterparts but
compile the source file only if the object file is out-of-date.
An object file <tt><i>X</i></tt> is considered out-of-date if it does not exist or
if it is older than the source file or any files included (via <tt>include</tt>)
when <tt><i>X</i></tt> was created.
When the value of the parameter <tt>compile-imported-libraries</tt>
is <tt>#t</tt>, <tt><i>X</i></tt> is also considered out-of-date if the object
file for any library imported when <tt><i>X</i></tt> was compiled is out-of-date.
If <tt>maybe-compile-file</tt> determines that compilation is necessary,
it compiles the source file by passing <tt>compile-file</tt> the
input and output filenames.
<tt>compile-library</tt> does so by similarly invoking the value of the
<tt>compile-library-handler</tt> parameter, and
<tt>compile-program</tt> does so by similarly invoking the value of the
<tt>compile-program-handler</tt> parameter.

<p>
When <tt><i>output-filename</i></tt> is not specified, the input and output
filenames are determined in the same manner as for <tt>compile-file</tt>.

<p>
<a name="./system:s72"></a><span class=formdef><b>thread parameter</b>: <tt>compile-library-handler</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This parameter must be set to a procedure, and the procedure should
accept two string arguments naming a source file and an object file.
The procedure should typically invoke <tt>compile-library</tt> and
pass it the two arguments, but it can also use one of the other
file or port compilation procedures.
For example, it might read the source file using its own parser and
use <a name="./system:s73"></a><tt>compile-to-file</tt> to finish
the compilation process.
The procedure can perform other actions as well, such as parameterizing
compilation parameters, establishing guards, or gathering statistics.
The default value of this parameter simply invokes
<tt>compile-library</tt> on the two string arguments without taking
any other action.

<p>
The value of this parameter is called by <tt>maybe-compile-library</tt>
when the object file is out-of-date.
It is also called by the expander to compile an
imported library when <tt>compile-imported-libraries</tt> is <tt>#t</tt>
and the expander determines the object file is out-of-date.

<p>
<a name="./system:s74"></a><span class=formdef><b>thread parameter</b>: <tt>compile-program-handler</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This parameter must be set to a procedure, and the procedure should
accept two string arguments naming a source file and an object file.
The procedure should typically invoke <tt>compile-program</tt> and
pass it the two arguments, but it can also use one of the other
file or port compilation procedures.
For example, it might read the source file using its own parser and
use <a name="./system:s75"></a><tt>compile-to-file</tt> to finish
the compilation process.
The procedure can perform other actions as well, such as parameterizing
compilation parameters, establishing guards, or gathering statistics.
The default value of this parameter simply invokes
<tt>compile-program</tt> on the two string arguments without taking
any other action and returns the list of libraries returned by
<tt>compile-program</tt>.

<p>
The value of this parameter is called by <tt>maybe-compile-program</tt>
when the object file is out-of-date.

<p>
<a name="./system:s76"></a><span class=formdef><b>procedure</b>: <tt>(compile-whole-program&nbsp;<i>input-filename</i>&nbsp;<i>output-filename</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(compile-whole-program&nbsp;<i>input-filename</i>&nbsp;<i>output-filename</i>&nbsp;<i>libs-visible?</i>)</tt></span>
<br>
<b>returns: </b>a list of libraries left to be loaded at run time
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>compile-whole-program</tt> accepts as input a filename naming
a "whole program optimization" (wpo) file for a top-level program
and produces an object file incorporating the program and each
library upon which it depends, provided that a wpo file for the
library can be found.

<p>
If a wpo file for a required library cannot be found, but an object
file for the library can, the library is not incorporated in the
resulting object file.
Such libraries are left to be loaded at run time.
<tt>compile-whole-program</tt> returns a list of such libraries.
If there are no such libraries, the resulting object file is
self-contained and <tt>compile-whole-program</tt> returns the empty
list.

<p>
The libraries incorporated into the resulting object file are visible (for
use by <tt>environment</tt> and <tt>eval</tt>) if the <tt><i>libs-visible?</i></tt>
argument is supplied and non-false.
Any library incorporated into the resulting object file and required by
an object file left to be loaded at run time is also visible, as are any
libraries the object file depends upon, regardless of the value of
<tt><i>libs-visible?</i></tt>.

<p>
<tt>compile-whole-program</tt> linearizes the initialization code for the
set of incorporated libraries in a way that respects static
dependencies among the libraries but not necessary dynamic dependencies
deriving from initialization-time uses of <tt>environment</tt>
or <tt>eval</tt>.
Additional static dependencies can be added in most cases to force
an ordering that allows the dynamic imports to succeed,
though not in general since a different order might be required each
time the program is run.
Adding a static dependency of one library on a second requires
adding an import of the second in the first as well as a run-time
reference to one of the variables exported by the second in the
body of the first.

<p>
<tt><i>input-filename</i></tt> and <tt><i>output-filename</i></tt> must be strings.
<tt><i>input-filename</i></tt> must identify a wpo file, and a wpo or object
file must also be present for each required library somewhere in
the directories specified by the <tt>library-directories</tt>
parameter.

<p>
To the extent possible given the specified set of visible libraries
and requirements of libraries to be loaded at run time,
<tt>compile-whole-program</tt> discards unused code and optimizes
across program and library boundaries, potentially reducing program
load time, run time, and memory requirements.
Some optimization also occurs even across the boundaries of libraries
that are not incorporated into the output, though this optimization
is limited in nature.

<p>
<a name="./system:s77"></a>The procedures <tt>compile-file</tt>, <tt>compile-program</tt>, <tt>compile-library</tt>,
<tt>compile-script</tt>, and <tt>compile-whole-library</tt> produce wpo files as well as ordinary
object files when the <tt>generate-wpo-files</tt> parameter is set
to <tt>#t</tt> (the default is <tt>#f</tt>).
<tt>compile-port</tt> and <tt>compile-to-port</tt> do so when passed
an optional wpo port.

<p>
<a name="./system:s78"></a><span class=formdef><b>procedure</b>: <tt>(compile-whole-library&nbsp;<i>input-filename</i>&nbsp;<i>output-filename</i>)</tt></span>
<br>
<b>returns: </b>a list of libraries left to be loaded at run time
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>compile-whole-library</tt> is like <tt>compile-whole-program</tt>,
except <tt><i>input-filename</i></tt> must specify a wpo file for a library,
all libraries are automatically made visible, and a new wpo file is
produced (when <tt>generate-wpo-files</tt> is <tt>#t</tt>) as well
as an object file for the resulting combination of libraries.

<p>
The comment in the description of <tt>compile-whole-program</tt>
about the effect of initialization-code linearization on dynamic
dependencies applies to <tt>compile-whole-library</tt> as well.

<p>
<a name="./system:s79"></a><span class=formdef><b>procedure</b>: <tt>(compile-port&nbsp;<i>input-port</i>&nbsp;<i>output-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(compile-port&nbsp;<i>input-port</i>&nbsp;<i>output-port</i>&nbsp;<i>sfd</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(compile-port&nbsp;<i>input-port</i>&nbsp;<i>output-port</i>&nbsp;<i>sfd</i>&nbsp;<i>wpo-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(compile-port&nbsp;<i>input-port</i>&nbsp;<i>output-port</i>&nbsp;<i>sfd</i>&nbsp;<i>wpo-port</i>&nbsp;<i>covop</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>input-port</i></tt> must be a textual input port.
<tt><i>output-port</i></tt> and, if present and non-false, <tt><i>wpo-port</i></tt> must be binary output ports.
If present and non-false, <tt><i>sfd</i></tt> must be a source-file descriptor.
If present and non-false, <tt><i>covop</i></tt> must be a textual output port.

<p>
<tt>compile-port</tt> is like <tt>compile-file</tt> except that it takes
input from an arbitrary textual input port and sends output to an arbitrary
binary output port.
If <tt><i>sfd</i></tt> is supplied, it is passed to the reader so that source information
can be associated with the expressions read from <tt><i>input-port</i></tt>.
It is also used to associate block-profiling information with the input
file name encapsulated within <tt><i>sfd</i></tt>.
If <tt><i>wpo-port</i></tt> is supplied, <tt>compile-port</tt> sends whole-program optimization information
to <tt><i>wpo-port</i></tt> for use by <tt>compile-whole-program</tt>, as if
(and regardless of whether) <tt>generate-wpo-files</tt> is set.
If <tt><i>covop</i></tt> is supplied, <tt>compile-port</tt> sends coverage information to
<tt><i>covop</i></tt>, as if (and regardless of whether) <tt>generate-covin-files</tt> is set.

<p>
The ports are closed automatically after compilation under the assumption
the program that opens the ports and invokes <tt>compile-port</tt>
will take care of closing the ports.

<p>
<a name="./system:s80"></a><span class=formdef><b>procedure</b>: <tt>(compile-to-port&nbsp;<i>obj-list</i>&nbsp;<i>output-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(compile-to-port&nbsp;<i>obj-list</i>&nbsp;<i>output-port</i>&nbsp;<i>sfd</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(compile-to-port&nbsp;<i>obj-list</i>&nbsp;<i>output-port</i>&nbsp;<i>sfd</i>&nbsp;<i>wpo-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(compile-to-port&nbsp;<i>obj-list</i>&nbsp;<i>output-port</i>&nbsp;<i>sfd</i>&nbsp;<i>wpo-port</i>&nbsp;<i>covop</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>obj-list</i></tt> must be a list containing a sequence of
objects that represent syntactically valid expressions, each possibly
annotated (Section&nbsp;<a href="./syntax.html#g109">11.11</a>).
If any of the objects does not represent a syntactically valid
expression, <tt>compile-to-port</tt> raises an exception with
condition type <tt>&amp;syntax</tt>.
<tt><i>output-port</i></tt> and, if present, <tt><i>wpo-port</i></tt> must be binary output ports.
If present, <tt><i>sfd</i></tt> must be a source-file descriptor.

<p>
<tt>compile-to-port</tt> is like <tt>compile-file</tt> except that it takes
input from a list of objects and sends output to an arbitrary binary
output port.
<tt><i>sfd</i></tt> is used to associate block-profiling information with the
input file name encapsulated within <tt><i>sfd</i></tt>.
If <tt><i>wpo-port</i></tt> is present, <tt><i>compile-to-port</i></tt> sends whole-program optimization information
to <tt><i>wpo-port</i></tt> for use by <tt>compile-whole-program</tt>, as if
(and regardless of whether) <tt>generate-wpo-files</tt> is set.
If <tt><i>covop</i></tt> is present, <tt><i>compile-to-port</i></tt> sends coverage information to
<tt><i>covop</i></tt>, as if (and regardless of whether) <tt>generate-covin-files</tt> is set.

<p>
The ports are not closed automatically after compilation under the assumption
the program that opens the port and invokes <tt>compile-to-port</tt>
will take care of closing the port.

<p>
When <tt><i>obj-list</i></tt> contains a single list-structured element whose
first-element is the symbol <tt>top-level-program</tt>,
<tt>compile-to-port</tt> returns a list of the libraries the top-level
program requires at run time, as with <tt>compile-program</tt>.
Otherwise, the return value is unspecified.

<p>
<a name="./system:s81"></a><span class=formdef><b>procedure</b>: <tt>(compile-to-file&nbsp;<i>obj-list</i>&nbsp;<i>output-file</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(compile-to-file&nbsp;<i>obj-list</i>&nbsp;<i>output-file</i>&nbsp;<i>sfd</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>obj-list</i></tt> must be a list containing a sequence of
objects that represent syntactically valid expressions, each possibly
annotated (Section&nbsp;<a href="./syntax.html#g109">11.11</a>).
If any of the objects does not represent a syntactically valid
expression, <tt>compile-to-file</tt> raises an exception with
condition type <tt>&amp;syntax</tt>.
<tt><i>output-file</i></tt> must be a string.
If present, <tt><i>sfd</i></tt> must be a source-file descriptor.

<p>
<tt>compile-to-file</tt> is like <tt>compile-file</tt> except that it takes
input from a list of objects.
<tt><i>sfd</i></tt> is used to associate block-profiling information with the
input file name encapsulated within <tt><i>sfd</i></tt>.

<p>
When <tt><i>obj-list</i></tt> contains a single list-structured element whose
first-element is the symbol <tt>top-level-program</tt>,
<tt>compile-to-file</tt> returns a list of the libraries the top-level
program requires at run time, as with <tt>compile-program</tt>.
Otherwise, the return value is unspecified.

<p>
<a name="./system:s82"></a><span class=formdef><b>procedure</b>: <tt>(concatenate-object-files&nbsp;<i>out-file</i>&nbsp;<i>in-file<sub>1</sub></i>&nbsp;<i>in-file<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>out-file</i></tt> and each <tt><i>in-file</i></tt> must be strings.

<p>
<tt>concatenate-object-files</tt> combines the header information
contained in the object files named by each <tt><i>in-file</i></tt>.  It then
writes the combined header information to the file named by
<tt><i>out-file</i></tt>, followed by the remaining object code from each
input file in turn.

<p>
<a name="./system:s83"></a><span class=formdef><b>procedure</b>: <tt>(make-boot-file&nbsp;<i>output-filename</i>&nbsp;<i>base-boot-list</i>&nbsp;<i>input-filename</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>output-filename</i></tt>, <tt><i>input-filename</i></tt>, and the elements of
<tt><i>base-boot-list</i></tt> must be strings.

<p>
<tt>make-boot-file</tt> writes a boot header to the file named by
<tt><i>output-filename</i></tt>, followed by the object code for each
<tt><i>input-filename</i></tt> in turn.
If an input file is not already compiled, <tt>make-boot-file</tt> compiles
the file as it proceeds.

<p>
The boot header identifies the elements of <tt><i>base-boot-list</i></tt> as
alternative boot files upon which the new boot file depends.
If the list of strings naming base boot files is empty, the first named
input file should be a base boot file, i.e., petite.boot or some boot file
derived from petite.boot.

<p>
<a name="./system:s84"></a><a name="./system:s85"></a>Boot files are loaded explicitly via the <tt>--boot</tt> or <tt>-b</tt>
command-line options or implicitly based on the name of the executable
(Section&nbsp;<a href="./use.html#g14">2.9</a>).

<p>
See Section&nbsp;<a href="./use.html#g13">2.8</a> for more information on boot files
and the use of <tt>make-boot-file</tt>.

<p>
<a name="./system:s86"></a><span class=formdef><b>procedure</b>: <tt>(make-boot-header&nbsp;<i>output-filename</i>&nbsp;<i>base-boot<sub>1</sub></i>&nbsp;<i>base-boot<sub>2</sub></i>...)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure has been subsumed by <tt>make-boot-file</tt> and is provided for
backward compatibility.
The call

<p>

<p><tt>(make-boot-header&nbsp;<i>output-filename</i>&nbsp;<i>base-boot<sub>1</sub></i>&nbsp;<i>base-boot<sub>2</sub></i>&nbsp;...)</tt>
<p>is equivalent to

<p>

<p><tt>(make-boot-file&nbsp;<i>output-filename</i>&nbsp;'(<i>base-boot<sub>1</sub></i>&nbsp;<i>base-boot<sub>2</sub></i>&nbsp;...))</tt>
<p><a name="./system:s87"></a><span class=formdef><b>procedure</b>: <tt>(strip-fasl-file&nbsp;<i>input-path</i>&nbsp;<i>output-path</i>&nbsp;<i>options</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>input-path</i></tt> and <tt><i>output-path</i></tt> must be strings.
<tt><i>input-path</i></tt> must name an existing, readable file containing
object code produced by <tt>compile-file</tt>, one of the other
file-compiling procedures, or an earlier run of <tt>strip-fasl-file</tt>.
<tt><i>options</i></tt> must be an enumeration set over the symbols constituting
valid strip options, as described in the <tt>fasl-strip-options</tt>
entry below.

<p>
The new procedure <tt>strip-fasl-file</tt> allows the removal of
source information of various sorts from a compiled object (fasl)
file produced by <tt>compile-file</tt> or one of the other file
compiling procedures.
It also allows removal of library visit code from object files
containing compiled libraries.
Visit code is the code for macro transformers and meta definitions
required to compile (but not run) dependent libraries.

<p>
On most platforms, the input and output paths can be the same,
in which case the input file is replaced with a new file containing
the stripped object code.
Using the same path will likely fail on Windows file systems,
which do not generally permit an open file to be removed.

<p>
If <tt><i>options</i></tt> is empty, the output file is effectively equivalent
to the input file, though it will not necessarily be identical.

<p>
<a name="./system:s88"></a><span class=formdef><b>syntax</b>: <tt>(fasl-strip-options&nbsp;<i>symbol</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>a fasl-strip-options enumeration set
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Fasl-strip-options enumeration sets are passed to <tt>strip-fasl-file</tt>
to determine what is stripped.
The available options are described below.

<p>
<dl compact>
<dt><tt>inspector-source</tt>:<dd>
Strip inspector source information.
This includes source expressions that might otherwise be available
for procedures and continuations with the "code" and "call"
commands and messages in the interactive and object inspectors.
It also includes filename and position information that might
otherwise be available for the same via the "file" command and
"source" messages.

<p>
<dt><tt>source-annotations</tt>:<dd>
Strip source annotations, which typically appear only on syntax objects,
e.g., identifiers, in the templates of macro transformers.

<p>
<dt><tt>profile-source</tt>:<dd>
Strip source file and character position information from profiled
code objects.
This does not remove the profile counters or eliminate the overhead
for incrementing them at run time.

<p>
<dt><tt>compile-time-information</tt>: <dd>
This strips compile-time information from compiled libraries, potentially
reducing the size of the resulting file but making it impossible to
use the file to compile dependent code.
This option is useful for creating smaller object files to ship
as part of a binary-only package.
</dl>


<p>
<a name="./system:s89"></a><span class=formdef><b>procedure</b>: <tt>(machine-type)</tt></span>
<br>
<b>returns: </b>the current machine type
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Consult the release notes for the current version of <i>Chez&nbsp;Scheme</i>
for a list of supported machine types.


<p>
<a name="./system:s90"></a><a name="desc:expand"></a>
<span class=formdef><b>procedure</b>: <tt>(expand&nbsp;<i>obj</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(expand&nbsp;<i>obj</i>&nbsp;<i>env</i>)</tt></span>
<br>
<b>returns: </b>expansion of the Scheme form represented by <tt><i>obj</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>expand</tt> treats <tt><i>obj</i></tt> as the representation of an expression.
It expands the expression in environment <tt><i>env</i></tt> and returns
an object representing the expanded form.
If no environment is provided, it defaults to the environment
returned by <tt>interaction-environment</tt>.

<p>
<tt><i>obj</i></tt> can be an annotation
(Section&nbsp;<a href="./syntax.html#g109">11.11</a>), and the default expander
makes use of annotations to incorporate source-file
information in error messages.

<p>
<tt>expand</tt> actually passes its arguments to the current expander
(see <tt>current-expand</tt>), initially <tt>sc-expand</tt>.

<p>
<a name="./system:s91"></a>See also <tt>expand-output</tt> (page&nbsp;<a href="./system.html#desc:expand-output">363</a>)
which can be used to request that the compiler or interpreter show
expander output.

<p>
<a name="./system:s92"></a><span class=formdef><b>thread parameter</b>: <tt>current-expand</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>current-expand</tt> determines the expansion procedure used by
the compiler, interpreter, and direct calls to
<a name="./system:s93"></a><tt>expand</tt>
to expand syntactic extensions.
<tt>current-expand</tt> is initially bound to the value of
<a name="./system:s94"></a><tt>sc-expand</tt>.

<p>
It may be set another procedure, but since the format of
expanded code expected by the compiler and interpreter is not publicly
documented, only <tt>sc-expand</tt> produces correct output, so the
other procedure must ultimately be defined in terms of
<tt>sc-expand</tt>.

<p>
The first argument to the expansion procedure represents the input
expression.
It can be an annotation (Section&nbsp;<a href="./syntax.html#g109">11.11</a>) or an
unannotated value.
the second argument is an environment.
Additional arguments might be passed to the expansion procedure
by the compiler, interpreter, and <tt>expand</tt>; their number
and roles are unspecified.

<p>
<a name="./system:s95"></a><span class=formdef><b>procedure</b>: <tt>(sc-expand&nbsp;<i>obj</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(sc-expand&nbsp;<i>obj</i>&nbsp;<i>env</i>)</tt></span>
<br>
<b>returns: </b>the expanded form of <tt><i>obj</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The procedure
<tt>sc-expand</tt> is used to expand programs written using
<tt>syntax-case</tt> macros.
<tt>sc-expand</tt> is the default expander, i.e., the initial
value of <tt>current-expand</tt>.
<tt><i>obj</i></tt> represents the program to be expanded, and
<tt><i>env</i></tt> must be an environment.
<tt><i>obj</i></tt> can be an annotation (Section&nbsp;<a href="./syntax.html#g109">11.11</a>)
or unannotated value.
If not provided, <tt><i>env</i></tt> defaults to the environment returned by
<tt>interaction-environment</tt>.

<p>
<a name="./system:s96"></a><a name="desc:expand/optimize"></a>
<span class=formdef><b>procedure</b>: <tt>(expand/optimize&nbsp;<i>obj</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(expand/optimize&nbsp;<i>obj</i>&nbsp;<i>env</i>)</tt></span>
<br>
<b>returns: </b>result of expanding and optimizing form represented by <tt><i>obj</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>expand/optimize</tt> treats <tt><i>obj</i></tt> as the representation of
an expression.
<tt><i>obj</i></tt> can be an annotation (Section&nbsp;<a href="./syntax.html#g109">11.11</a>)
or unannotated value.
<tt>expand/optimize</tt> expands the expression in environment <tt><i>env</i></tt>
and passes the expression through the source optimizer <tt>cp0</tt>
(unless <tt>cp0</tt> is disabled via <tt>run-cp0</tt>).
It also simplifies <tt>letrec</tt> and <tt>letrec*</tt> expressions within
the expression and makes their undefined checks explicit.
It returns an object representing the expanded, simplified, and optimized form.
If no environment is provided, it defaults to the environment
returned by <tt>interaction-environment</tt>.

<p>
<tt>expand/optimize</tt> is primarily useful for understanding what
<tt>cp0</tt> does and does not optimize.
Many optimizations are performed later in the compiler,
so <tt>expand/optimize</tt> does not give a complete picture of
optimizations performed.

<p>

<p><tt>(expand/optimize<br>

&nbsp;&nbsp;'(let&nbsp;([y&nbsp;'(3&nbsp;.&nbsp;4)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(car&nbsp;y)&nbsp;(cdr&nbsp;y))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;7
<br>
<br>
(print-gensym&nbsp;#f)<br>

(expand/optimize<br>

&nbsp;&nbsp;'(let&nbsp;([y&nbsp;'(3&nbsp;.&nbsp;4)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(+&nbsp;(car&nbsp;y)&nbsp;(cdr&nbsp;y))&nbsp;x))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(lambda&nbsp;(x)&nbsp;(#2%*&nbsp;7&nbsp;x))
<br>
<br>
(expand/optimize<br>

&nbsp;&nbsp;'(let&nbsp;([n&nbsp;(expt&nbsp;2&nbsp;10)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;even?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(or&nbsp;(zero?&nbsp;x)&nbsp;(not&nbsp;(odd?&nbsp;x)))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;odd?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(not&nbsp;(even?&nbsp;(-&nbsp;x&nbsp;1)))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;f<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(z)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;z&nbsp;0)&nbsp;(omega)&nbsp;(+&nbsp;x&nbsp;y&nbsp;z))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;omega<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((lambda&nbsp;(x)&nbsp;(x&nbsp;x))&nbsp;(lambda&nbsp;(x)&nbsp;(x&nbsp;x)))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([g&nbsp;(f&nbsp;1)]&nbsp;[m&nbsp;(f&nbsp;n)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([h&nbsp;(if&nbsp;(&gt;&nbsp;((g&nbsp;2)&nbsp;3)&nbsp;5)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;odd?)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(h&nbsp;n)))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1025</tt>
<p><a name="./system:s97"></a>See also <tt>expand/optimize-output</tt> (page&nbsp;<a href="./system.html#desc:expand/optimize-output">363</a>)
which can be used to request that the compiler or interpreter show
source-optimizer output.

<p>
<a name="./system:s98"></a><span class=formdef><b>syntax</b>: <tt>(eval-when&nbsp;<i>situations</i>&nbsp;<i>form<sub>1</sub></i>&nbsp;<i>form<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>situations</i></tt> must be a list containing some combination of the symbols
<tt>eval</tt>, <tt>compile</tt>, <tt>load</tt>, <tt>visit</tt>, and
<tt>revisit</tt>.

<p>
When source files are loaded (see <tt>load</tt>), the forms in the file
are read, compiled, and executed sequentially, so that each form in
the file is fully evaluated before the next one is read.
When a source file is compiled (see <tt>compile-file</tt>), however, the
forms are read and compiled, <i>but not executed</i>, in sequence.
This distinction matters only when the execution of one
form in the file affects the compilation of later forms, e.g.,
when the form results in the definition of a module or syntactic form or
sets a compilation parameter such as <tt>optimize-level</tt> or
<tt>case-sensitive</tt>.

<p>
For example, assume that a file contains the following two forms:

<p>

<p><tt>(define-syntax&nbsp;reverse-define<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e&nbsp;x)&nbsp;(define&nbsp;x&nbsp;e)]))
<br>
<br>
(reverse-define&nbsp;3&nbsp;three)</tt>
<p>Loading this from source has the effect of defining
<tt>reverse-define</tt> as a syntactic form and binding the identifier
<tt>three</tt> to 3.
The situation may be different if the file is compiled with
<tt>compile-file</tt>, however.
Unless the system or programmer takes steps to assure that the first
form is fully executed before the second expression is compiled,
the syntax expander will not recognize <tt>reverse-define</tt> as a syntactic
form and will generate code for a procedure call to <tt>reverse-define</tt>
instead of generating code to define <tt>three</tt> to be 3.
When the object file is subsequently loaded, the attempt to reference
either <tt>reverse-define</tt> or <tt>three</tt> will fail.

<p>
As it happens, when a <tt>define-syntax</tt>, <tt>module</tt>,
<tt>import</tt>, or <tt>import-only</tt> form appears at top level, as in the
example above, the compiler does indeed arrange to evaluate it before
going on to compile the remainder of the file.
If the compiler encounters a variable definition for an identifier that
was previously something else, it records that fact as well.
The compiler also generates the
appropriate code so that the bindings will be present as well when
the object file is subsequently loaded.
This solves most, but not all, problems of this nature, since most are
related to the use of <tt>define-syntax</tt> and modules.
Some problems are not so straightforwardly handled, however.
For example, assume that the file contains the following definitions
for <a name="./system:s99"></a><tt>nodups?</tt> and <a name="./system:s100"></a><tt>mvlet</tt>.

<p>

<p><tt>(define&nbsp;nodups?<br>

&nbsp;&nbsp;(lambda&nbsp;(ids)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;bound-id-member?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(id&nbsp;ids)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(not&nbsp;(null?&nbsp;ids))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(bound-identifier=?&nbsp;id&nbsp;(car&nbsp;ids))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bound-id-member?&nbsp;id&nbsp;(cdr&nbsp;ids))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(null?&nbsp;ids)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(not&nbsp;(bound-id-member?&nbsp;(car&nbsp;ids)&nbsp;(cdr&nbsp;ids)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(nodups?&nbsp;(cdr&nbsp;ids))))))
<br>
<br>
(define-syntax&nbsp;mvlet<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((x&nbsp;...)&nbsp;expr)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(andmap&nbsp;identifier?&nbsp;#'(x&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(nodups?&nbsp;#'(x&nbsp;...)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(call-with-values<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;expr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...))])))
<br>
<br>
(mvlet&nbsp;((a&nbsp;b&nbsp;c)&nbsp;(values&nbsp;1&nbsp;2&nbsp;3))<br>

&nbsp;&nbsp;(list&nbsp;(*&nbsp;a&nbsp;a)&nbsp;(*&nbsp;b&nbsp;b)&nbsp;(*&nbsp;c&nbsp;c)))</tt>
<p>When loaded directly, this results in the definition of
<tt>nodups?</tt> as a procedure and <tt>mvlet</tt> as a syntactic
abstraction before evaluation of the <tt>mvlet</tt> expression.
Because <tt>nodups?</tt> is defined before the <tt>mvlet</tt>
expression is expanded, the call to <tt>nodups?</tt> during the
expansion of <tt>mvlet</tt> causes no difficulty.
If instead this file were compiled, using <tt>compile-file</tt>, the
compiler would arrange to define <tt>mvlet</tt> before continuing
with the expansion and evaluation of the <tt>mvlet</tt> expression,
but it would not arrange to define <tt>nodups?</tt>.
Thus the expansion of the <tt>mvlet</tt> expression would fail.

<p>
In this case it does not help to evaluate the syntactic extension alone.
A solution in this case would be to move the definition of
<tt>nodups?</tt> inside the definition for <tt>mvlet</tt>, just as
the definition for <tt>bound-id-member?</tt> is placed within
<tt>nodups?</tt>, but this does not work for help routines shared
among several syntactic definitions.
Another solution is to label the <tt>nodups?</tt> definition a
"meta" definition (see Section&nbsp;<a href="./syntax.html#g106">11.8</a>) but this
does not work for helpers that are used both by syntactic
abstractions and by run-time code.

<p>
A somewhat simpler problem occurs when setting parameters that affect
compilation, such as <tt>optimize-level</tt> and
<tt>case-sensitive?</tt>.
If not set prior to compilation, their settings usually will not have
the desired effect.

<p>
<tt>eval-when</tt> offers a solution to these problems by allowing the
programmer to explicitly control what forms should or should not
be evaluated during compilation.
<tt>eval-when</tt> is a syntactic form and is handled directly by the
expander.
The action of <tt>eval-when</tt> depends upon the <tt><i>situations</i></tt> argument
and whether or not the forms <tt><i>form<sub>1</sub></i>&nbsp;<i>form<sub>2</sub></i>&nbsp;...</tt>
are being compiled via <tt>compile-file</tt> or are being evaluated
directly.
Let's consider each of the possible situation specifiers
<tt>eval</tt>, <tt>compile</tt>, <tt>load</tt>, <tt>visit</tt>, and
<tt>revisit</tt> in turn.

<p>
<dl compact>
<dt><tt>eval</tt>:<dd>
The <tt>eval</tt> specifier is relevant only when the <tt>eval-when</tt>
form is being
evaluated directly, i.e., if it is typed at the keyboard or loaded from a
source file.
Its presence causes <tt><i>form<sub>1</sub></i>&nbsp;<i>form<sub>2</sub></i>&nbsp;...</tt> to be
expanded and this expansion to be included in the expansion of the
<tt>eval-when</tt> form.
Thus, the forms will be evaluated directly as if not contained within an
<tt>eval-when</tt> form.

<p>
<dt><tt>compile</tt>:<dd>
The <tt>compile</tt> specifier is relevant only when the <tt>eval-when</tt>
form appears in a file currently being compiled.
(Its presence is simply ignored otherwise.)
Its presence forces <tt><i>form<sub>1</sub></i>&nbsp;<i>form<sub>2</sub></i>&nbsp;...</tt> to be
expanded and evaluated immediately.

<p>
<dt><tt>load</tt>:<dd>
The <tt>load</tt> specifier is also relevant only when the <tt>eval-when</tt>
form appears
in a file currently being compiled.
Its presence causes <tt><i>form<sub>1</sub></i>&nbsp;<i>form<sub>2</sub></i>&nbsp;...</tt> to be
expanded and this expansion to be included in the expansion of the
<tt>eval-when</tt> form.
Any code necessary to record binding information and evaluate syntax
transformers for definitions contained in the forms is marked for
execution when the file is "visited," and any code necessary to
compute the values of variable definitions and the expressions contained
within the forms is marked for execution when the file is "revisited."

<p>
<dt><tt>visit</tt>:<dd>
The <tt>visit</tt> specifier is also relevant only when the <tt>eval-when</tt>
form appears
in a file currently being compiled.
Its presence causes <tt><i>form<sub>1</sub></i>&nbsp;<i>form<sub>2</sub></i>&nbsp;...</tt> to be
expanded and this expansion to be included in the expansion of the
<tt>eval-when</tt> form, with an annotation that the forms are to be
executed when the file is "visited."

<p>
<dt><tt>revisit</tt>:<dd>
The <tt>revisit</tt> specifier is also relevant only when the <tt>eval-when</tt>
form appears
in a file currently being compiled.
Its presence causes <tt><i>form<sub>1</sub></i>&nbsp;<i>form<sub>2</sub></i>&nbsp;...</tt> to be
expanded and this expansion to be included in the expansion of the
<tt>eval-when</tt> form, with an annotation that the forms are to be
executed when the file is "revisited."
</dl>

<p>
A file is considered "visited" when it is brought in by either
<tt>load</tt> or <tt>visit</tt> and "revisited" when it is brought in
by either <tt>load</tt> or <tt>revisit</tt>.

<p>
Top-level expressions are treated as if they are wrapped in an
<tt>eval-when</tt> with situations <tt>load</tt> and <tt>eval</tt>.
This means that, by default, forms typed at the keyboard or
loaded from a source file are evaluated, and forms appearing in a
file to be compiled are not evaluated directly but are compiled for
execution when the resulting object file is subsequently loaded.

<p>
The treatment of top-level definitions is slightly more involved.
All definitions result in changes to the compile-time environment.
For example, an identifier defined by <tt>define</tt> is recorded
as a variable, and an identifier defined by <tt>define-syntax</tt>
is recorded as a keyword and associated with the value of its
right-hand-side (transformer) expression.
These changes are made at eval, compile, and load
time as if the definitions were wrapped in an <tt>eval-when</tt> with
situations <tt>eval</tt>, <tt>load</tt>, and <tt>compile</tt>.
(This behavior can be altered by changing the value of the
parameter <tt>eval-syntax-expanders-when</tt>.)
Some definitions also result in changes to the run-time environment.
For example, a variable is associated with the value of its
right-hand-side expression.
These changes are made just at evaluation and load time as if the
definitions were wrapped in an <tt>eval-when</tt> with situations
<tt>eval</tt> and <tt>load</tt>.

<p>
The treatment of local expressions or definitions (those not at top level)
that are wrapped in an <tt>eval-when</tt> depends only upon whether the
situation <tt>eval</tt> is present in the list of situations.
If the situation <tt>eval</tt> is present, the definitions and expressions
are evaluated as if they were not wrapped in an <tt>eval-when</tt> form,
i.e., the <tt>eval-when</tt> form is treated as a <tt>begin</tt> form.
If the situation <tt>eval</tt> is not present, the forms are ignored;
in a definition context, the <tt>eval-when</tt> form is treated as an
empty <tt>begin</tt>, and in an expression context, the <tt>eval-when</tt>
form is treated as a constant with an unspecified value.

<p>
Since top-level syntax bindings are established, by default, at compile
time as well as eval and load time, top-level variable bindings needed
by syntax transformers should be wrapped in an <tt>eval-when</tt> form
with situations <tt>compile</tt>, <tt>load</tt>, and <tt>eval</tt>.
We can thus <tt>nodups?</tt> problem above by enclosing the definition
of <tt>nodups?</tt> in an <tt>eval-when</tt> as follows.

<p>

<p><tt>(eval-when&nbsp;(compile&nbsp;load&nbsp;eval)<br>

&nbsp;&nbsp;(define&nbsp;nodups?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ids)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;bound-id-member?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(id&nbsp;ids)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(not&nbsp;(null?&nbsp;ids))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(bound-identifier=?&nbsp;id&nbsp;(car&nbsp;ids))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bound-id-member?&nbsp;id&nbsp;(cdr&nbsp;ids))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(null?&nbsp;ids)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(not&nbsp;(bound-id-member?&nbsp;(car&nbsp;ids)&nbsp;(cdr&nbsp;ids)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(nodups?&nbsp;(cdr&nbsp;ids)))))))</tt>
<p>This forces it to be evaluated before it is needed during the expansion
of the <tt>mvlet</tt> expression.

<p>
Just as it is useful to add <tt>compile</tt> to the default
<tt>load</tt> and <tt>eval</tt> situations, omitting options is also
useful.
Omitting one or more of <tt>compile</tt>, <tt>load</tt>, and
<tt>eval</tt> has the effect of preventing the evaluation at the given
time.
Omitting all of the options has the effect of inhibiting evaluation
altogether.

<p>
One common combination of situations is <tt>(compile&nbsp;eval)</tt>, which by the
inclusion of <tt>compile</tt> causes the expression to be evaluated at
compile time, and by the omission of <tt>load</tt> inhibits the generation
of code by the compiler for execution when the file is subsequently loaded.
This is typically used for the definition of syntactic extensions used only
within the file in which they appear; in this case their presence in the
object file is not necessary.
It is also used to set compilation parameters that are intended to be in
effect whether the file is loaded from source or compiled via
<tt>compile-file</tt>

<p>

<p><tt>(eval-when&nbsp;(compile&nbsp;eval)&nbsp;(case-sensitive&nbsp;#t))</tt>
<p>Another common situations list is <tt>(compile)</tt>, which might be
used to set compilation options to be used only when the file is
compiled via <tt>compile-file</tt>.

<p>

<p><tt>(eval-when&nbsp;(compile)&nbsp;(optimize-level&nbsp;3))</tt>
<p>Finally, one other common combination is <tt>(load&nbsp;eval)</tt>, which might
be useful for inhibiting the double evaluation (during the compilation of
a file and again when the resulting object file is loaded) of syntax
definitions when the syntactic extensions are not needed within
the file in which their definitions appear.

<p>
The behavior of <tt>eval-when</tt> is usually intuitive but can be
understood precisely as follows.
The <tt>syntax-case</tt> expander, which handles <tt>eval-when</tt>
forms, maintains two state sets, one for compile-time forms and
one for run-time forms.
The set of possible states in each set are "L" for <tt>load</tt>,
"C" for <tt>compile</tt>, "V" for <tt>visit</tt>, "R" for
<tt>revisit</tt>, and "E" for <tt>eval</tt>.

<p>
When compiling a file, the compile-time set initially contains "L"
and "C" and the run-time set initially contains only "L."
When not compiling a file (as when a form is evaluated by the
read-eval-print loop or loaded from a source file), both sets
initially contain only "E."
The subforms of an <tt>eval-when</tt> form at top level are expanded with
new compile- and run-time sets determined by the current sets and
the situations listed in the <tt>eval-when</tt> form.
Each element of the current set contributes zero or more elements to the
new set depending upon the given situations according to the following
table.

<p>
<TABLE><TR><TD nowrap align="center">
  </TD><TD nowrap align="center"> <tt>load</tt>&nbsp; </TD><TD nowrap align="center"> &nbsp;<tt>compile</tt>&nbsp; </TD><TD nowrap align="center"> &nbsp;<tt>visit</tt>&nbsp; </TD><TD nowrap align="center"> &nbsp;<tt>revisit</tt>&nbsp; </TD><TD nowrap align="center"> &nbsp;<tt>eval</tt></TD></TR><TR><TD nowrap align="center">
L </TD><TD nowrap align="center">  L  </TD><TD nowrap align="center">  C  </TD><TD nowrap align="center">  V  </TD><TD nowrap align="center">  R  </TD><TD nowrap align="center"> --- </TD></TR><TR><TD nowrap align="center">
C </TD><TD nowrap align="center"> --- </TD><TD nowrap align="center"> --- </TD><TD nowrap align="center"> --- </TD><TD nowrap align="center"> --- </TD><TD nowrap align="center">  C  </TD></TR><TR><TD nowrap align="center">
V </TD><TD nowrap align="center">  V  </TD><TD nowrap align="center">  C  </TD><TD nowrap align="center">  V  </TD><TD nowrap align="center"> --- </TD><TD nowrap align="center"> --- </TD></TR><TR><TD nowrap align="center">
R </TD><TD nowrap align="center">  R  </TD><TD nowrap align="center">  C  </TD><TD nowrap align="center"> --- </TD><TD nowrap align="center">  R  </TD><TD nowrap align="center"> --- </TD></TR><TR><TD nowrap align="center">
E </TD><TD nowrap align="center"> --- </TD><TD nowrap align="center"> --- </TD><TD nowrap align="center"> --- </TD><TD nowrap align="center"> --- </TD><TD nowrap align="center">  E  </TD></TR><TR><TD nowrap align="center">
</TD></TR></TABLE>

<p>
For example, if the current compile-time state set is {L}
and the situations are <tt>load</tt> and <tt>compile</tt>, the new compile-time
state set is {L,&nbsp;C}, since L/<tt>load</tt>
contributes "L" and L/<tt>compile</tt> contributes "C."

<p>
The state sets determine how forms are treated by the expander.
Compile-time forms such as syntax definitions are evaluated at a time
or times determined by the compile-time state set, and run-time forms
are evaluated at a time or times determined by the run-time state set.
A form is evaluated immediately if "C" is in the state set.
Code is generated to evaluate the form at visit or revisit
time if "V" or "R" is present.
If "L" is present in the compile-time set, it is treated as "V;"
likewise, if "L" is present in the run-time set, it is treated as
"R."
If more than one of states is present in the state set, the
form is evaluated at each specified time.

<p>
"E" can appear in the state set only when not compiling a file, i.e.,
when the expander is invoked from an evaluator such as <tt>compile</tt>
or <tt>interpret</tt>.
When it does appear, the expanded form is returned from the expander to be
processed by the evaluator, e.g., <tt>compile</tt> or <tt>interpret</tt>,
that invoked the expander.

<p>
The value of the parameter <tt>eval-syntax-expanders-when</tt> actually determines
the initial compile-time state set.
The parameter is bound to a list of situations, which defaults to
<tt>(compile&nbsp;load&nbsp;eval)</tt>.
When compiling a file, <tt>compile</tt> contributes "C" to the
state set, <tt>load</tt> contributes "L," <tt>visit</tt> contributes
"V," <tt>revisit</tt> contributes "R," and <tt>eval</tt>
contributes nothing.
When not compiling a file, <tt>eval</tt> contributes "E" to the
state set, and the other situations contribute nothing.
There is no corresponding parameter for controlling the initial value
of the run-time state set.

<p>
<a name="eval-when-tlp"></a>For RNRS top-level programs, <tt>eval-when</tt> is essentially ineffective.
The entire program is treated as a single expression, so <tt>eval-when</tt>
becomes a local <tt>eval-when</tt> for which only the <tt>eval</tt>
situation has any relevance.
As for any local <tt>eval-when</tt> form, the subforms are ignored if
the <tt>eval</tt> situation is not present; otherwise, they are treated as
if the <tt>eval-when</tt> wrapper were absent.

<p>
<a name="./system:s101"></a><span class=formdef><b>thread parameter</b>: <tt>eval-syntax-expanders-when</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This parameter must be set to a list representing a set of
<tt>eval-when</tt> situations, e.g., a list containing at most one
occurrence of each of the symbols <tt>eval</tt>, <tt>compile</tt>,
<tt>load</tt>, <tt>visit</tt>, and <tt>revisit</tt>.
It is used to determine the evaluation time of syntax
definitions, module forms, and import forms are expanded.
(See the discussion of <tt>eval-when</tt> above.)
The default value is <tt>(compile&nbsp;load&nbsp;eval)</tt>, which causes
compile-time information in a file to be established when the file is
loaded from source, when it is compiled via <tt>compile-file</tt>,
and when a compiled version of the file is loaded via <tt>load</tt>
or <tt>visit</tt>.

<p>

<h3><a name="g116"></a><a name="./system:h5"></a>Section 12.5. Source Directories and Files<a name="SECTSYSTEMSOURCE"></a></h3>



<p>
<a name="./system:s102"></a><span class=formdef><b>global parameter</b>: <tt>source-directories</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of <tt>source-directories</tt> must be a list of strings, each
of which names a directory path.
<tt>source-directories</tt> determines the set of directories searched
for source or object files when a file is loaded via <tt>load</tt>, <tt>load-library</tt>,
<tt>load-program</tt>, <tt>include</tt>,
<tt>visit</tt>, or <tt>revisit</tt>,
when a syntax error occurs, or when a source
file is opened in the interactive inspector.

<p>
The default value is the list <tt>(".")</tt>, which means source files
will be found only in or relative to the current directory, unless named
with an absolute path.

<p>
This parameter is never altered by the system, with one exception.
The expander temporarily adds (via <tt>parameterize</tt>) the directory
in which a library file resides to the front of the <tt>source-directories</tt>
list when it compiles (when <tt>compile-imported-libraries</tt> is true) or loads the library from source, which it does
only if the library is not already defined.

<p>
<a name="./system:s103"></a><span class=formdef><b>procedure</b>: <tt>(with-source-path&nbsp;<i>who</i>&nbsp;<i>name</i>&nbsp;<i>procedure</i>)</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The procedure <tt>with-source-path</tt> searches through the current
source-directories path, in order, for a file with the specified
<tt><i>name</i></tt> and invokes <tt><i>procedure</i></tt> on the result.
If no such file is found, an exception is raised with condition types
<tt>&amp;assertion</tt> and <tt>&amp;who</tt> with <tt><i>who</i></tt> as
who value.

<p>
If <tt><i>name</i></tt> is an absolute pathname or one beginning with <tt>./</tt>
(or <tt>.\</tt> under Windows) or <tt>../</tt> (or <tt>..\</tt> under
Windows), or if the list of source directories
contains only <tt>"."</tt>, the default, or <tt>""</tt>, which is
equivalent to <tt>"."</tt>, no searching is performed and <tt><i>name</i></tt> is
returned.

<p>
<tt><i>who</i></tt> must be a symbol, <tt><i>name</i></tt> must be a string, and
<tt><i>procedure</i></tt> should accept one argument.

<p>
The following examples assumes that the file "pie" exists
in the directory "../spam" but not in "../ham" or the current
directory.

<p>

<p><tt>(define&nbsp;find-file<br>

&nbsp;&nbsp;(lambda&nbsp;(fn)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(with-source-path&nbsp;'find-file&nbsp;fn&nbsp;values)))
<br>
<br>
(find-file&nbsp;"pie")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"pie"
<br>
<br>
(source-directories&nbsp;'("."&nbsp;"../ham"))<br>

(find-file&nbsp;"pie")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception&nbsp;in&nbsp;find-file:&nbsp;pie&nbsp;not&nbsp;found</i>
<br>
<br>
(source-directories&nbsp;'("."&nbsp;"../spam"))<br>

(find-file&nbsp;"pie")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"../spam/pie"
<br>
<br>
(source-directories&nbsp;'("."&nbsp;"../ham"))<br>

(find-file&nbsp;"/pie")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"/pie"
<br>
<br>
(source-directories&nbsp;'("."&nbsp;"../ham"))<br>

(find-file&nbsp;"./pie")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"./pie"
<br>
<br>
(source-directories&nbsp;'("."&nbsp;"../spam"))<br>

(find-file&nbsp;"../pie")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"../ham/pie"</tt>
<p>
<h3><a name="g117"></a><a name="./system:h6"></a>Section 12.6. Compiler Controls<a name="SECTMISCOPTIMIZE"></a></h3>



<p>
<a name="./system:s104"></a><span class=formdef><b>thread parameter</b>: <tt>optimize-level</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This parameter can take on one of the four values 0, 1, 2, and 3.

<p>
In theory, this parameter controls the amount of optimization
performed by the compiler.
In practice, it does so only indirectly, and the only difference
is between optimize level 3, at which the compiler generates
"unsafe" code, and optimize levels 0-2, at which the compiler
generates "safe" code.
Safe code performs full type and bounds checking so that, for example,
an attempt to apply a non-procedure, an attempt to take the car of a
non-pair, or an attempt to reference beyond the end of a vector each
result in an exception being raised.
With unsafe code, the same situations may result in invalid memory
references, corruption of the Scheme heap (which may cause
seemingly unrelated problems later), system crashes, or other undesirable
behaviors.
Unsafe code is typically faster, but optimize-level 3 should be used with
caution and only on sections of well-tested code that must run as quickly
as possible.

<p>
While the compiler produces the same code for optimize levels 0-2,
user-defined macro transformers can differentiate among the different
levels if desired.

<p>
One way to use optimize levels is on a per-file
basis, using <a name="./system:s105"></a><tt>eval-when</tt> to force the use of a particular
optimize level at compile time.
For example, placing:

<p>

<p><tt>(eval-when&nbsp;(compile)&nbsp;(optimize-level&nbsp;3))</tt>
<p>at the front of a file will cause all of the forms in the file to be
compiled at optimize level 3 when the file is compiled (using
<a name="./system:s106"></a><tt>compile-file</tt>) but does not affect the optimize level used
when the file is loaded from source.
Since <tt>compile-file</tt> parameterizes <tt>optimize-level</tt> (see <tt>parameterize</tt>),
the above
expression does not permanently alter the optimize level in the
system in which the <tt>compile-file</tt> is performed.

<p>
The optimize level can also be set via the
<a name="./system:s107"></a><tt>--optimize-level</tt>
command-line option (Section&nbsp;<a href="./use.html#g14">2.9</a>).
This option is particularly useful for running RNRS top-level programs
at optimize-level&nbsp;3 via the
<a name="./system:s108"></a><tt>--program</tt> command-line option,
since <tt>eval-when</tt> is ineffective for RNRS top-level programs as described
on page&nbsp;<a href="./system.html#eval-when-tlp">355</a>.


<p>
<a name="./system:s109"></a><a name="desc:hash-primitive"></a>
<span class=formdef><b>syntax</b>: <tt>($primitive&nbsp;<i>variable</i>)</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>#%<i>variable</i></tt></span>
<br><span class=formdef><b>syntax</b>: <tt>($primitive&nbsp;2&nbsp;<i>variable</i>)</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>#2%<i>variable</i></tt></span>
<br><span class=formdef><b>syntax</b>: <tt>($primitive&nbsp;3&nbsp;<i>variable</i>)</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>#3%<i>variable</i></tt></span>
<br>
<b>returns: </b>the primitive value for <tt><i>variable</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>variable</i></tt> must name a primitive procedure.
The <tt>$primitive</tt> syntactic form allows control over the
optimize level at the granularity of individual primitive references,
and it can be used to access the original value
of a primitive, regardless of the lexical context or the current
top-level binding for the variable originally bound to the primitive.

<p>
The expression <tt>($primitive&nbsp;<i>variable</i>)</tt> may
be abbreviated as <tt>#%<i>variable</i></tt>.
The reader expands <tt>#%</tt> followed by an object
into a <tt>$primitive</tt> expression, much as it expands <tt>'<i>object</i></tt>
into a <tt>quote</tt> expression.

<p>
If a <tt>2</tt> or <tt>3</tt> appears in the form or between the
<tt>#</tt> and <tt>%</tt> in the abbreviated form, the compiler treats
an application of the primitive as if it were compiled
at the corresponding optimize level (see the <tt>optimize-level</tt>
parameter).
If no number appears in the form, an application of the primitive is
treated as an optimize-level 3 application if the current optimize
level is 3;
otherwise, it is treated as an optimize-level 2 application.

<p>

<p><tt>(#%car&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;a<br>

(let&nbsp;([car&nbsp;cdr])&nbsp;(car&nbsp;'(a&nbsp;b&nbsp;c)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(b&nbsp;c)<br>

(let&nbsp;([car&nbsp;cdr])&nbsp;(#%car&nbsp;'(a&nbsp;b&nbsp;c)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;a<br>

(begin&nbsp;(set!&nbsp;car&nbsp;cdr)&nbsp;(#%car&nbsp;'(a&nbsp;b&nbsp;c)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;a</tt>
<p><a name="./system:s110"></a><span class=formdef><b>thread parameter</b>: <tt>debug-level</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This parameter can take on one of the four values 0, 1, 2, and 3.
It is used to tell the compiler how important the preservation of
debugging information is, with 0 being least important and 3 being
most important.
The default value is 1.
As of Version&nbsp;9.0, it is used solely to determine whether an
error-causing call encountered in nontail position is treated as
if it were in tail position (thus causing the caller's frame not
to appear in a stack backtrace); this occurs at debug levels below&nbsp;2.

<p>
<a name="./system:s111"></a><span class=formdef><b>thread parameter</b>: <tt>generate-interrupt-trap</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>To support interrupts, including keyboard, timer, and collect request
interrupts, the compiler inserts a short sequence of instructions at the
entry to each nonleaf procedure (Section&nbsp;<a href="./system.html#g113">12.2</a>).
This small overhead may be eliminated by setting
<tt>generate-interrupt-trap</tt> to <tt>#f</tt>.
The default value of this parameter is <tt>#t</tt>.

<p>
It is rarely a good idea to compile code without interrupt trap
generation, since a tight loop in the generated code may completely
prevent interrupts from being serviced, including the collect request
interrupt that causes garbage collections to occur automatically.
Disabling trap generation may be useful, however, for routines that act
simply as "wrappers" for other routines for which code is presumably
generated with interrupt trap generation enabled.
It may also be useful for short performance-critical routines with
embedded loops or recursions that are known to be short running and
that make no other calls.


<p>
<a name="./system:s112"></a><span class=formdef><b>thread parameter</b>: <tt>compile-interpret-simple</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>At all optimize levels, when the value of
<tt>compile-interpret-simple</tt> is set to a true value (the default),
<a name="./system:s113"></a><tt>compile</tt> interprets simple
expressions.
A simple expression is one that creates no procedures.
This can save a significant amount of time over the course of many
calls to <tt>compile</tt> or <tt>eval</tt> (with <tt>current-eval</tt>
set to <tt>compile</tt>, its default value).
When set to false, <tt>compile</tt> compiles all expressions.


<p>
<a name="./system:s114"></a><a name="desc:generate-inspector-information"></a>
<span class=formdef><b>thread parameter</b>: <tt>generate-inspector-information</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When this parameter is set to a true value (the default), information
about the source and contents of procedures and continuations is
generated during compilation and retained in tables associated with
each code segment.
This information allows the inspector to provide more complete
information, at the expense of using more memory and producing
larger object files (via <tt>compile-file</tt>).
Although compilation and loading may be slower when inspector
information is generated, the speed of the compiled code is not
affected.
If this parameter is changed during the compilation of a file, the
original value will be restored.
For example, if:

<p>

<p><tt>(eval-when&nbsp;(compile)&nbsp;(generate-inspector-information&nbsp;#f))</tt>
<p>is included in a file, generation of inspector information will be
disabled only for the remainder of that particular file.

<p>
<a name="./system:s115"></a><a name="desc:generate-procedure-source-information"></a>
<span class=formdef><b>thread parameter</b>: <tt>generate-procedure-source-information</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When <tt>generate-inspector-information</tt> is set to <tt>#f</tt> and
this parameter is set to <tt>#t</tt>, then a source location is preserved
for a procedure, even though other inspector information is not preserved.
Source information provides a small amount of debugging support at a
much lower cost in memory and object-file size than full inspector information.
If this parameter is changed during the compilation of a file, the
original value will be restored.

<p>
<a name="./system:s116"></a><span class=formdef><b>thread parameter</b>: <tt>enable-cross-library-optimization</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This parameter controls whether information is included with the
object code for a compiled library to enable propagation of constants
and inlining of procedures defined in the library into dependent
libraries.
When set to <tt>#t</tt> (the default), this information is included;
when set to <tt>#f</tt>, the information is not included.
Setting the parameter to <tt>#f</tt> potentially reduces the sizes
of the resulting object files and the exposure of near-source
information via the object file.

<p>
<a name="./system:s117"></a><span class=formdef><b>thread parameter</b>: <tt>generate-wpo-files</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./system:s118"></a>When this parameter is set to <tt>#t</tt> (the default is <tt>#f</tt>),
<tt>compile-file</tt>, <tt>compile-library</tt>, <tt>compile-program</tt>,
and <tt>compile-script</tt> produce whole-program optimization (wpo)
files for use by <tt>compile-whole-program</tt>.
The name of the <tt>wpo</tt> file is derived from the output-file
name by replacing the object-file extension (normally <tt>.so</tt>)
with <tt>.wpo</tt>, or adding the extension <tt>.wpo</tt> if the
object filename has no extension or has the extension <tt>.wpo</tt>.

<p>
<a name="./system:s119"></a><span class=formdef><b>thread parameter</b>: <tt>compile-file-message</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When this parameter is set to true, the default, <tt>compile-file</tt>,
<tt>compile-library</tt>, <tt>compile-program</tt>, and
<tt>compile-script</tt> print a message of the form:

<p>

<p><tt>compiling&nbsp;<i>input-path</i>&nbsp;with&nbsp;output&nbsp;to&nbsp;<i>output-path</i></tt>
<p>When the parameter is set to <tt>#f</tt>, the message is not printed.

<p>
<a name="./system:s120"></a><a name="desc:run-cp0"></a>
<span class=formdef><b>thread parameter</b>: <tt>run-cp0</tt></span>
<br><span class=formdef><b>thread parameter</b>: <tt>cp0-effort-limit</tt></span>
<br><span class=formdef><b>thread parameter</b>: <tt>cp0-score-limit</tt></span>
<br><span class=formdef><b>thread parameter</b>: <tt>cp0-outer-unroll-limit</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These parameters control the operation of <tt>cp0</tt>, a source
optimization pass that runs after macro expansion and prior
to most other compiler passes.
<tt>cp0</tt> performs procedure inlining, in which the code of one
procedure is inlined at points where it is called by other procedures,
as well as copy propagation, constant folding, useless code
elimination, and several related optimizations.
The algorithm used by the optimizer is described in detail in the paper
"Fast and effective procedure inlining"&nbsp;[<a class=citation href="./bibliography.html#g182">31</a>].

<p>
When <tt>cp0</tt> is enabled, the programmer can count on the compiler
to fold constants, eliminate unnecessary <tt>let</tt> bindings, and
eliminate unnecessary and inaccessible code.
This is particularly useful when writing macros, since the programmer
can usually handle only the general case and let the compiler simplify
the code when possible.
For example, the programmer can define <tt>case</tt> as follows:

<p>

<p><tt>(define-syntax&nbsp;case<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e&nbsp;[(k&nbsp;...)&nbsp;a1&nbsp;a2&nbsp;...]&nbsp;...&nbsp;[else&nbsp;b1&nbsp;b2&nbsp;...])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([t&nbsp;e])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(memv&nbsp;t&nbsp;'(k&nbsp;...))&nbsp;a1&nbsp;a2&nbsp;...]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;b1&nbsp;b2&nbsp;...]))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e&nbsp;[(k&nbsp;...)&nbsp;a1&nbsp;a2&nbsp;...]&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([t&nbsp;e])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(memv&nbsp;t&nbsp;'(k&nbsp;...))&nbsp;a1&nbsp;a2&nbsp;...]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...))]))</tt>
<p>and count on the introduce <tt>let</tt> expression to be eliminated
if <tt>e</tt> turns out to be an unassigned variable, and count on
the entire <tt>case</tt> expression to be folded if <tt>e</tt> turns
out to be a constant.

<p>
It is possible to see what <tt>cp0</tt> does with an expression
via the procedure <a name="./system:s121"></a><tt>expand/optimize</tt>,
which expands its argument and passes the result through <tt>cp0</tt>, as
illustrated by the following transcript.

<p>

<p><tt>&gt;&nbsp;(print-gensym&nbsp;#f)<br>

&gt;&nbsp;(expand/optimize<br>

&nbsp;&nbsp;&nbsp;&nbsp;'(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(case&nbsp;x&nbsp;[(a)&nbsp;1]&nbsp;[(b&nbsp;c)&nbsp;2]&nbsp;[(d)&nbsp;3]&nbsp;[else&nbsp;4])))<br>

(lambda&nbsp;(x)<br>

&nbsp;&nbsp;(if&nbsp;(#2%memv&nbsp;x&nbsp;'(a))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(#2%memv&nbsp;x&nbsp;'(b&nbsp;c))&nbsp;2&nbsp;(if&nbsp;(#2%memv&nbsp;x&nbsp;'(d))&nbsp;3&nbsp;4))))<br>

&gt;&nbsp;(expand/optimize<br>

&nbsp;&nbsp;&nbsp;&nbsp;'(+&nbsp;(let&nbsp;([f&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(case&nbsp;x&nbsp;[(a)&nbsp;1]&nbsp;[(b&nbsp;c)&nbsp;2]&nbsp;[(d)&nbsp;3]&nbsp;[else&nbsp;4]))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;'b))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15))<br>

17</tt>
<p>In the first example, the <tt>let</tt> expression produced by <tt>case</tt>
is eliminated, and in the second, the entire expression is optimized down
to the constant <tt>17</tt>.
Although not shown by <tt>expand/optimize</tt>, the <tt>memv</tt> calls
in the output code for the first example will be replaced by calls to the
less expensive <tt>eq?</tt> by a later pass of the compiler.
Additional examples are given in the description
of <tt>expand/optimize</tt>.

<p>
The value of <tt>run-cp0</tt> must be a procedure.
Whenever the compiler is invoked on a Scheme form, the value <tt><i>p</i></tt>
of this parameter is called to determine whether and how
<tt>cp0</tt> is run.
<tt><i>p</i></tt> receives two arguments: <tt><i>cp0</i></tt>, the entry point into
<tt>cp0</tt>, and <tt><i>x</i></tt>, the form being compiled.
The default value of <tt>run-cp0</tt> simply invokes <tt><i>cp0</i></tt> on
<tt><i>x</i></tt>, then <tt><i>cp0</i></tt> again on the result.
The second run is useful in some cases because the first run
may not eliminate bindings for certain variables that appear to be
referenced but are not actually referenced after inlining.
The marginal benefit of the second run is usually minimal, but so is the
cost.

<p>
Interesting variants include

<p>

<p><tt>(run-cp0&nbsp;(lambda&nbsp;(cp0&nbsp;x)&nbsp;x))</tt>
<p>which bypasses (disables) <tt>cp0</tt>, and

<p>

<p><tt>(run-cp0&nbsp;(lambda&nbsp;(cp0&nbsp;x)&nbsp;(cp0&nbsp;x)))</tt>
<p>which runs <tt>cp0</tt> just once.

<p>
The value of <tt>cp0-effort-limit</tt> determines the maximum amount
of effort spent on each inlining attempt.
The time spent optimizing a program is a linear function of this limit and the
number of calls in the program's source, so small values for this parameter
enforce a tighter bound on compile time.
When set to zero, inlining is disabled except when the name of a procedure
is referenced only once.
The value of <tt>cp0-score-limit</tt> determines the maximum amount of
code produced per inlining attempt.
Small values for this parameter limit the amount of overall code expansion.
These parameters must be set to nonnegative fixnum values.

<p>
The parameter <tt>cp0-outer-unroll-limit</tt>
controls the amount of inlining performed by the optimizer for
recursive procedures.
With the parameter's value set to the default value of <tt>0</tt>, recursive
procedures are not inlined.
A nonzero value for the outer unroll limit allows calls external to
a recursive procedure to be inlined.
For example, the expression

<p>

<p><tt>(letrec&nbsp;([fact&nbsp;(lambda&nbsp;(x)&nbsp;(if&nbsp;(zero?&nbsp;x)&nbsp;1&nbsp;(*&nbsp;x&nbsp;(fact&nbsp;(-&nbsp;x&nbsp;1)))))])<br>

&nbsp;&nbsp;(fact&nbsp;10))</tt>
<p>would be left unchanged with the outer unroll limit set to zero, but would
be converted into

<p>

<p><tt>(letrec&nbsp;([fact&nbsp;(lambda&nbsp;(x)&nbsp;(if&nbsp;(zero?&nbsp;x)&nbsp;1&nbsp;(*&nbsp;x&nbsp;(fact&nbsp;(-&nbsp;x&nbsp;1)))))])<br>

&nbsp;&nbsp;(*&nbsp;10&nbsp;(fact&nbsp;9)))</tt>
<p>with the outer unroll limit set to one.

<p>
Interesting effects can be had by varying several of these parameters at
once.
For example, setting the
effort and outer unroll limits to large values and the score limit
to <tt>1</tt> has the effect of inlining even complex recursive procedures
whose values turn out to be constant at compile time without risking
any code expansion.
For example,

<p>

<p><tt>(letrec&nbsp;([fact&nbsp;(lambda&nbsp;(x)&nbsp;(if&nbsp;(zero?&nbsp;x)&nbsp;1&nbsp;(*&nbsp;x&nbsp;(fact&nbsp;(-&nbsp;x&nbsp;1)))))])<br>

&nbsp;&nbsp;(fact&nbsp;10))</tt>
<p>would be reduced to <tt>3628800</tt>, but

<p>

<p><tt>(letrec&nbsp;([fact&nbsp;(lambda&nbsp;(x)&nbsp;(if&nbsp;(zero?&nbsp;x)&nbsp;1&nbsp;(*&nbsp;x&nbsp;(fact&nbsp;(-&nbsp;x&nbsp;1)))))])<br>

&nbsp;&nbsp;(fact&nbsp;z))</tt>
<p>would be left unchanged, although the optimizer may take a while to
reach this decision if the effort and outer unroll limits are large.

<p>
<a name="./system:s122"></a><span class=formdef><b>thread parameter</b>: <tt>commonization-level</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>After running the main source optimization pass (cp0) for the last time, the
compiler optionally runs a <i>commonization</i> pass.
The pass commonizes the code for lambda expressions that have
identical structure by abstracting differences at certain leaves
of the program, namely constants, references to unassigned variables,
and references to primitives.
The parameter <tt>commonization-level</tt> controls whether commonization
is run and, if so, how aggressive it is.
Its value must be a nonnegative exact integer ranging from 0 through 9.
When the parameter is set to 0, the default, commonization is not run.
Otherwise, higher values result in more commonization.

<p>
Commonization can undo some of the effects of cp0's inlining, can
add run-time overhead, and can complicate debugging, particularly
at higher commonization levels, which is why it is disabled by
default.
On the other hand, for macros or other meta programs that can
generate large, mostly similar lambda expressions, enabling
commonization can result in significant savings in object-code size
and even reduce run-time overhead by making more efficient use of
instruction caches.

<p>
<a name="./system:s123"></a><span class=formdef><b>thread parameter</b>: <tt>undefined-variable-warnings</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When <tt>undefined-variable-warnings</tt> is set to <tt>#t</tt>, the
compiler issues a warning message whenever it cannot determine that
a variable bound by <tt>letrec</tt>, <tt>letrec*</tt>, or an internal
definition will not be referenced before it is defined.
The default value is <tt>#f</tt>.

<p>
Regardless of the setting of this parameter, the compiler inserts code
to check for the error, except at optimize level 3.
The check is fairly inexpensive and does not typically inhibit inlining
or other optimizations.
In code that must be carefully tuned, however, it is sometimes useful
to reorder bindings or make other changes to eliminate the checks.
Enabling undefined-variable warnings can facilitate this process.

<p>
The checks are also visible in the output of <tt>expand/optimize</tt>.

<p>
<a name="./system:s124"></a><a name="desc:expand-output"></a><a name="desc:expand/optimize-output"></a>
<span class=formdef><b>thread parameter</b>: <tt>expand-output</tt></span>
<br><span class=formdef><b>thread parameter</b>: <tt>expand/optimize-output</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The parameters <tt>expand-output</tt> and <tt>expand/optimize-output</tt>
can be used to request that the compiler and interpreter print
expander and source-optimizer output produced during the compilation or
interpretation process.
Each parameter must be set to either <tt>#f</tt> (the default) or a
textual output port.

<p>
When <tt>expand-output</tt> is set to a textual output port, the output
of the expander is printed to the port as a side effect of running
<tt>compile</tt>, <tt>interpret</tt>, or any of the file compiling
primitives, e.g., <tt>compile-file</tt> or <tt>compile-library</tt>.
Similarly, when <tt>expand/optimize-output</tt> is set to a textual
output port, the output of the source optimizer is printed.

<p>
<a name="./system:s125"></a><a name="./system:s126"></a>See also <tt>expand</tt> (page&nbsp;<a href="./system.html#desc:expand">349</a>) and
<tt>expand-optimize</tt> (page&nbsp;<a href="./system.html#desc:expand/optimize">350</a>), which
can be used to run the expander or the expander and source optimizer
directly on an individual form.

<p>
<a name="./system:s127"></a><span class=formdef><b>syntax</b>: <tt>(pariah&nbsp;<i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the values of the last subexpression
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A <tt>pariah</tt> expression is just like a <tt>begin</tt> expression
except that it informs the compiler that the code is expected to
be executed infrequently.
The compiler uses this information to optimize code layout, register
assignments, and other aspects of the generated code.
The <tt>pariah</tt> form can be used in performance-critical code
to mark the branches of a conditional (e.g., <tt>if</tt>, <tt>cond</tt>,
or <tt>case</tt>) that are less likely to be executed than the
others.


<p>

<h3><a name="g118"></a><a name="./system:h7"></a>Section 12.7. Profiling<a name="SECTMISCPROFILE"></a></h3>



<p>
<a name="./system:s128"></a><a name="./system:s129"></a><a name="./system:s130"></a>ChezScheme supports two forms of profiling: source profiling and
block profiling.
With source profiling enabled, the compiler instruments the code
it produces to count the number of times each source-code expression
is executed.
This information can be
displayed in HTML format, or it can be packaged in a list or
source table for arbitrary user-defined processing.
It can also be dumped to a file to be loaded subsequently into the
compiler's database of profile information for use in source-level
optimizations, such as reordering the clauses of a <tt>case</tt>
or <tt>exclusive-cond</tt> form.
In connection with coverage-information (covin) files generated by the
compiler when
<a name="./system:s131"></a><tt>generate-covin-files</tt>
is <tt>#t</tt>, profile information can also be used to gauge coverage
of a source-code base by a set of tests.

<p>
The association between source-code expressions and profile counts
is usually established via annotations produced by the reader and
present in the input to the expander (Section&nbsp;<a href="./syntax.html#g109">11.11</a>).
It is also possible to explicitly identify source positions
to be assigned profile counts via <tt>profile</tt> expressions.
A <tt>profile</tt> expression has one subform, a source object, and
returns an unspecified value.
Its only effect is to cause the number of times the expression is
executed to be accounted to the source object.

<p>
In cases where source positions explicitly identified by <tt>profile</tt>
forms are the only ones whose execution counts should be tracked,
the parameter <tt>generate-profile-forms</tt> can be set to <tt>#f</tt>
to inhibit the expander's implicit generation of <tt>profile</tt> forms
for all annotated source expressions.
It is also possible to obtain finer control over implicit generation of
<tt>profile</tt> forms by marking which annotations that should and
should not be used for profiling (Section&nbsp;<a href="./syntax.html#g109">11.11</a>).

<p>
With block profiling enabled, the compiler similarly instruments the
code it produces to count the number of times each "basic block"
in the code it produces is executed.
Basic blocks are the building blocks of the code produced by many
compilers, including <i>Chez&nbsp;Scheme</i>'s compiler, and are sequences
of straight-line code entered only at the top and exited only at
the bottom.
Counting the number of times each basic block is executed is
equivalent to counting the number of times each instruction is
executed, but more efficient.
Block-profile information cannot be viewed, but it can be dumped
to a file to be loaded subsequently into the compiler's database of
profile information for use in block- and instruction-level
optimizations.
These optimizations include reordering blocks to push less frequently
used sequences of code out-of-line, so they will not occupy space
in the instruction cache, and giving registers to variables that are
used in more frequently executed instructions.

<p>
Source profiling involves at least the following steps:

<p>
<ul>
<li>compile the code with source profiling enabled,
<li>run the compiled code to generate source-profile information, and
<li>dump the profile information.
</ul>
<p>

<p>
<a name="./system:s132"></a>Source profiling is enabled by setting the parameter
<tt>compile-profile</tt> to the symbol <tt>source</tt>
or to the boolean value <tt>#t</tt>.
The profile information can be dumped via:

<p>
<dl compact>
<dt><tt>profile-dump-html</tt><dd><a name="./system:s133"></a>
in HTML format to allow the programmer to visualize how
often each expression is executed using a color-coding system that
makes it easy to spot "hot spots,"
<dt><tt>profile-dump-list</tt><dd><a name="./system:s134"></a>
in a form suitable for user-defined post-processing,
<dt><tt>profile-dump</tt><dd><a name="./system:s135"></a>
in a form suitable for off-line processing by one of the methods
above or by some custom means, or
<dt><tt>profile-dump-data</tt><dd><a name="./system:s136"></a>
in a form suitable for loading into the compiler's database.
</dl>

<p>
If the information is intended to be fed back into the compiler for
optimization, the following additional steps are required, either
in the same or a different Scheme process:

<p>
<ul>
<li>load the profile information into the compiler's profile
database, and
<li>recompile the code.
</ul>
<p>

<p>
<a name="./system:s137"></a>Profile information dumped by <tt>profile-dump-data</tt> is loaded
into the compiler's profile database via <tt>profile-load-data</tt>.
Profiling information is <i>not</i> available to the compiler unless
it is explicitly dumped via <tt>profile-dump-data</tt> and loaded
via <tt>profile-load-data</tt>.

<p>
When block-profile information is to be used for optimization,
the steps are similar:

<p>
<ul>
<li>compile the code with block profiling enabled,
<li>run the code to generate block-profile information,
<li>dump the profile information,
<li>load the profile information, and
<li>recompile the code.
</ul>
<p>

<p>
<a name="./system:s138"></a><a name="./system:s139"></a>Block profiling is enabled by setting the parameter
<tt>compile-profile</tt> to the symbol <tt>block</tt>
or to the boolean value <tt>#t</tt>.
The profile information must be dumped via <tt>profile-dump-data</tt>
and loaded via <tt>profile-load-data</tt>.
As with source profile information, block profile information can be
loaded in the same or in a different Scheme process as the one that
dumped the information.

<p>
For block optimization, the code to be recompiled must be identical.
In general, this means the files involved must not have been modified,
and nothing else can change that indirectly affects the code produced
by the compiler, e.g., settings for compiler parameters such as
<tt>optimize-level</tt> or the contents of configuration files read
by macros at compile time.
Otherwise, the set of blocks or the instructions within them might
be different, in which case the block profile information will not
line up properly and the compiler will raise an exception.

<p>
For the same reason, when both source profiling and block profiling
information is to be used for optimization, the source information
must be gathered first and loaded before both the first and second
compilation runs involved in block profiling.
That is, the following steps must be used:

<p>
<ul>
<li>1 compile the code with source profiling enabled,
<li>2 run the code to generate source-profile information,
<li>2 dump the source-profile information,
<li>3 load the source-profile information,
<li>3 recompile the code with block profiling enabled,
<li>4 run the code to generate block-profile information,
<li>4 dump the block-profile information,
<li>5 load the source- and block-profile information, and
<li>5 recompile the code.
</ul>
<p>

<p>
The numbers labeling each step indicate both the order of the steps
and those that must be performed in the same Scheme process.
(All of the steps can be performed in the same Scheme process, if
desired.)

<p>
Both source and block profiling are disabled when <tt>compile-profile</tt>
is set to <tt>#f</tt>, its default value.

<p>
The following example highlights the use of source profiling for
identifying hot spots in the code.
Let's assume that the file /tmp/fatfib/fatfib.ss contains the
following source code.

<p>

<p><tt>(define&nbsp;fat+<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fat+&nbsp;(1+&nbsp;x)&nbsp;(1-&nbsp;y)))))
<br>
<br>
(define&nbsp;fatfib<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;x&nbsp;2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fat+&nbsp;(fatfib&nbsp;(1-&nbsp;x))&nbsp;(fatfib&nbsp;(1-&nbsp;(1-&nbsp;x)))))))</tt>
<p>We can load fatfib.ss with profiling enabled as follows.

<p>

<p><tt>(parameterize&nbsp;([compile-profile&nbsp;'source])<br>

&nbsp;&nbsp;(load&nbsp;"/tmp/fatfib/fatfib.ss"))</tt>
<p>We then run the application as usual.

<p>

<p><tt>(fatfib&nbsp;20)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;10946</tt>
<p>After the run (or multiple runs), we
dump the profile information as a set of html files using
<tt>profile-dump-html</tt>.

<p>

<p><tt>(profile-dump-html)</tt>
<p>This creates a file named profile.html containing a summary of the profile
information gathered during the run.
If we view this file in a browser, we should see something like the
following.

<p>

<img src="canned/profilehtml.png" alt="profile.html listing">


<p>
The most frequently executed code is highlighted in colors closer to
red in the visible spectrum, while
the least frequently executed code is highlighted in colors closer to
violet.
Each of the entries in the lists of files and hot spots are links into
additional generated files, one per source file (provided
<tt>profile-dump-html</tt> was able to locate an unmodified copy of
the source file).
In this case, there is only one, fatfib.ss.html.
If we move to that file, we should see something like this:

<p>

<img src="canned/fatfibhtml.png" alt="fatfib.html listing">


<p>
As in the summary, the code is color-coded according to frequency
of execution.
Hovering over a color-coded section of code should cause a pop-up
box to appear with the starting position and count of the source
expression.
If a portion of source code is not color-coded or is identified
via the starting position as having inherited its color from some
enclosing expression, it may have been recognized as dead code by
the compiler or garbage collector and discarded, or the expander
might not have been able to track it through the macro-expansion
process.

<p>
<tt>profile-dump</tt> and <tt>profile-dump-list</tt> may be used to
generate a list of profile entries, which may then be analyzed manually
or via a custom profile-viewing application.

<p>
<a name="./system:s140"></a><span class=formdef><b>thread parameter</b>: <tt>compile-profile</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When this parameter is set to the symbol <tt>source</tt> or the
boolean value <tt>#t</tt>, the compiler instruments the code it
generates with instructions that count the number of times each
section of source code is executed.
When set to the symbol <tt>block</tt>, the compiler similarly
instruments the code it generates with instructions that count the
number of times each block of code is executed.
When set to <tt>#f</tt> (the default), the compiler does not insert
these instructions.

<p>
The general description of profiling above describes how the source
and block profile information can be viewed or used for optimization.

<p>
The code generated when <tt>compile-profile</tt> is non-false is
larger and less efficient, so this parameter should be set only
when profile information is needed.

<p>
The profile counters for code compiled when profile instrumentation
is enabled are retained indefinitely, even if the code with which
they are associated is reclaimed by the garbage collector.
This results in more complete and accurate profile data but can lead
to space leaks in programs that dynamically generate or load code.
Such programs can avoid the potential space leak by releasing the
counters explicitly via the procedure
<a name="./system:s141"></a><tt>profile-release-counters</tt>.


<p>
<a name="./system:s142"></a><span class=formdef><b>thread parameter</b>: <tt>generate-covin-files</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When this parameter is set to <tt>#t</tt>, the compiler generates
"coverage-information" (covin) files that can be used in connection with
profile information to measure coverage of a source-code base by a
set of tests.
One covin file is created for each object file, with the object-file
extension replaced by the extension <tt>.covin</tt>.
Each covin file contains the printed representation of a source table
(Section&nbsp;<a href="./syntax.html#g110">11.12</a>), compressed using the compression
format and level specified by <tt>compress-format</tt> and
<tt>compress-level</tt>.
This information can be read via
<a name="./system:s143"></a><tt>get-source-table!</tt> and used
as a universe of source expressions to identify source expressions
that are not evaluated during the running of a set of tests.


<p>
<a name="./system:s144"></a><span class=formdef><b>syntax</b>: <tt>(profile&nbsp;<i>source-object</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A <tt>profile</tt> form has the effect of accounting to the source
position identified by <tt><i>source-object</i></tt> the number of times the
<tt>profile</tt> form is executed.
Profile forms are generated implicitly by the expander for source
expressions in annotated input, e.g., input read by the compiler or
interpreter from a Scheme source file, so this form is typically
useful only when unannotated source code is produced by the front
end for some language that targets Scheme.

<p>
<a name="./system:s145"></a><span class=formdef><b>thread parameter</b>: <tt>(generate-profile-forms)</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When this parameter is set to <tt>#t</tt>, the default, the expander
implicitly introduces <tt>profile</tt> forms for each annotated input
expression, unless the annotation has not been marked for use in
profiling  (Section&nbsp;<a href="./syntax.html#g109">11.11</a>).
It can be set to <tt>#f</tt> to inhibit the expander's implicit
generation of <tt>profile</tt> forms, typically when explicit
<tt>profile</tt> forms are already present for all source positions
that should be profiled.

<p>
<a name="./system:s146"></a><span class=formdef><b>procedure</b>: <tt>(profile-clear)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Calling this procedure causes profile information to be cleared, i.e.,
the counts associated with each section of code are set to zero.

<p>
<a name="./system:s147"></a><span class=formdef><b>procedure</b>: <tt>(profile-release-counters)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Calling this procedure causes profile information associated with reclaimed
code objects to be dropped.

<p>
<a name="./system:s148"></a><span class=formdef><b>procedure</b>: <tt>(profile-dump)</tt></span>
<br>
<b>returns: </b>a list of pairs of source-object and count
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure produces a dump of all
profile information gathered since startup or the last call to
<tt>profile-clear</tt>.
It returns a list of pairs, where the car of each pair
is a source object (Section&nbsp;<a href="./syntax.html#g109">11.11</a>) and the
cdr is an exact nonnegative integer count.

<p>
The list might contain more than one entry per source object due
to macro expansion and procedure inlining, and it might contain
more than one (non-eq) source object per file and source position
due to separate compilation.
In such cases, the counts are not overlapping and can be summed
together to obtain the full count.

<p>
The advantage of <tt>profile-dump</tt> over <tt>profile-dump-list</tt>
is that <tt>profile-dump</tt> performs only minimal processing and
preserves complete source objects, including their embedded source-file
descriptors.
It might be used, for example, to dump profile information to a
fasl file on one machine for subsequent processing on another.

<p>
<a name="./system:s149"></a><tt>with-profile-tracker</tt>
can be used to obtain the same set of counts as a source table.


<p>
<a name="./system:s150"></a><span class=formdef><b>procedure</b>: <tt>(with-profile-tracker&nbsp;<i>thunk</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(with-profile-tracker&nbsp;<i>preserve-existing?</i>&nbsp;<i>thunk</i>)</tt></span>
<br>
<b>returns: </b>a source table and the values returned by <tt><i>thunk</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>thunk</i></tt> must be a procedure and should accept zero arguments.
It may return any number of values.

<p>
<tt>with-profile-tracker</tt> invokes <tt><i>thunk</i></tt> without arguments.
If <tt><i>thunk</i></tt> returns <i>n</i> values <tt><i>x<sub>1</sub></i>,&nbsp;<i>x<sub>2</sub></i>,&nbsp;...,&nbsp;<i>x<sub>n</sub></i></tt>, <tt>with-profile-tracker</tt>
returns <i>n</i> + 1 values <tt><i>st</i>,&nbsp;<i>x<sub>1</sub></i>,&nbsp;<i>x<sub>2</sub></i>,&nbsp;...,&nbsp;<i>x<sub>n</sub></i></tt>, where <tt><i>st</i></tt> is a
source table associating source objects with profile counts.
If <tt><i>preserve-existing?</i></tt> is absent or <tt>#f</tt>, each count
represents the number of times the source expression represented
by the associated source object is evaluated during the invocation
of <tt><i>thunk</i></tt>.
Otherwise, each count represents the number of times the source
expression represented by the associated source object is evaluated
before or during the invocation of <tt><i>thunk</i></tt>.

<p>
Profile data otherwise cleared by a call to
<a name="./system:s151"></a><tt>profile-clear</tt> or
<a name="./system:s152"></a><tt>profile-release-counters</tt>
during the invocation of <tt><i>thunk</i></tt> is included in the
resulting table.
That is, invoking these procedures while <tt><i>thunk</i></tt> is running has
no effect on the resulting counts.
On the other hand, profile data cleared before <tt>with-profile-tracker</tt>
is invoked is not included in the resulting table.

<p>
The idiom <tt>(with-profile-tracker&nbsp;#t&nbsp;values)</tt> can be used to obtain
the current set of profile counts as a source table.


<p>
<a name="./system:s153"></a><span class=formdef><b>procedure</b>: <tt>(source-table-dump&nbsp;<i>source-table</i>)</tt></span>
<br>
<b>returns: </b>a list of pairs of source objects and their associated values in <tt><i>source-table</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure can be used to convert a source-table produced by
<a name="./system:s154"></a><tt>with-profile-tracker</tt> or some other mechanism into the form returned
by <a name="./system:s155"></a><tt>profile-dump</tt> for use as an argument to
<a name="./system:s156"></a><tt>profile-dump-html</tt>,
<a name="./system:s157"></a><tt>profile-dump-list</tt>,
or
<a name="./system:s158"></a><tt>profile-dump-data</tt>.

<p>
<a name="./system:s159"></a><span class=formdef><b>procedure</b>: <tt>(profile-dump-html)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(profile-dump-html&nbsp;<i>prefix</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(profile-dump-html&nbsp;<i>prefix</i>&nbsp;<i>dump</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure produces one or more HTML files, including
profile.html, which contains color-coded summary information,
and one file <tt><i>source</i></tt>.html for each source
file <tt><i>source</i></tt> containing a color-coded copy of the
source code, as described in the lead-in to this section.
If <tt><i>prefix</i></tt> is specified, it must be a string and is prepended
to the names of the generated HTML files.
For example, if <tt><i>prefix</i></tt> is <tt>"/tmp/"</tt>, the generated
files are placed in the directory /tmp.
The raw profile information is obtained from <tt><i>dump</i></tt>, which
defaults to the value returned by <tt>profile-dump</tt>.

<p>
<a name="./system:s160"></a><span class=formdef><b>thread parameter</b>: <tt>(profile-palette)</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This value of this parameter must be a nonempty vector of at least
three pairs.
The car of each pair is a background color and the cdr is a foreground
(text) color.
Each color must be a string, and each string should contain an HTML
cascading style sheet (CSS) color specifier.
The first pair is used for unprofiled code, and the second is used
for unexecuted profiled code.
The third is used for code that is executed least frequently, the fourth
for code executed next-least frequently, and so on, with the last
being used for code that is executed most frequently.
Programmers may wish to supply their own palette to enhance visibility
or to change the number of colors used.

<p>
By default, a black background is used for unprofiled code, and a gray
background is used for unexecuted profiled code.
Background colors ranging from purple to red are used for executed
profiled code, depending on frequency of execution, with red for the most
frequently executed code.

<p>

<p><tt>(profile-palette)&nbsp;<img src="math/csug/0.gif" alt="<graphic>"><br>

&nbsp;&nbsp;#(("#111111"&nbsp;.&nbsp;"white")&nbsp;("#607D8B"&nbsp;.&nbsp;"white")<br>

&nbsp;&nbsp;&nbsp;&nbsp;("#9C27B0"&nbsp;.&nbsp;"black")&nbsp;("#673AB7"&nbsp;.&nbsp;"white")<br>

&nbsp;&nbsp;&nbsp;&nbsp;("#3F51B5"&nbsp;.&nbsp;"white")&nbsp;("#2196F3"&nbsp;.&nbsp;"black")<br>

&nbsp;&nbsp;&nbsp;&nbsp;("#00BCD4"&nbsp;.&nbsp;"black")&nbsp;("#4CAF50"&nbsp;.&nbsp;"black")<br>

&nbsp;&nbsp;&nbsp;&nbsp;("#CDDC39"&nbsp;.&nbsp;"black")&nbsp;("#FFEB3B"&nbsp;.&nbsp;"black")<br>

&nbsp;&nbsp;&nbsp;&nbsp;("#FFC107"&nbsp;.&nbsp;"black")&nbsp;("#FF9800"&nbsp;.&nbsp;"black")<br>

&nbsp;&nbsp;&nbsp;&nbsp;("#F44336"&nbsp;.&nbsp;"white"))<br>

(profile-palette<br>

&nbsp;;&nbsp;set&nbsp;palette&nbsp;with&nbsp;rainbow&nbsp;colors&nbsp;and&nbsp;black&nbsp;text<br>

&nbsp;;&nbsp;for&nbsp;all&nbsp;but&nbsp;unprofiled&nbsp;or&nbsp;unexecuted&nbsp;code<br>

&nbsp;&nbsp;'#(("#000000"&nbsp;.&nbsp;"white")&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;black<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;("#666666"&nbsp;.&nbsp;"white")&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;gray<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;("#8B00FF"&nbsp;.&nbsp;"black")&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;violet<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;("#6600FF"&nbsp;.&nbsp;"black")&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;indigo<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;("#0000FF"&nbsp;.&nbsp;"black")&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;blue<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;("#00FF00"&nbsp;.&nbsp;"black")&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;green<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;("#FFFF00"&nbsp;.&nbsp;"black")&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;yellow<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;("#FF7F00"&nbsp;.&nbsp;"black")&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;orange<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;("#FF0000"&nbsp;.&nbsp;"black")))&nbsp;&nbsp;;&nbsp;red</tt>
<p><a name="./system:s161"></a><span class=formdef><b>thread parameter</b>: <tt>(profile-line-number-color)</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This value of this parameter must be a string or <tt>#f</tt>.
If it is a string, the string should contain an HTML cascading style sheet (CSS)
color specifier.
If the parameter is set to a string, <tt>profile-dump-html</tt> includes line numbers
in its html rendering of each source file, using the specified color.
If the parameter is set to <tt>#f</tt>, no line numbers are included.

<p>
<a name="./system:s162"></a><span class=formdef><b>procedure</b>: <tt>(profile-dump-list)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(profile-dump-list&nbsp;<i>warn?</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(profile-dump-list&nbsp;<i>warn?</i>&nbsp;<i>dump</i>)</tt></span>
<br>
<b>returns: </b>a list of profile entries (see below)
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure produces a dump of all
profile information present in <tt><i>dump</i></tt>, which defaults to
the value returned by <tt>profile-dump</tt>.
It returns a list of entries, each of which is itself a list containing the
following elements identifying one block of code and how many times it
has been executed.

<p>
<ul>
 <li>execution count
 <li>pathname
 <li>beginning file position in characters (inclusive)
 <li>ending file position in characters (exclusive)
 <li>line number of beginning file position
 <li>character position of beginning file position
</ul>
<p>

<p>
<tt>profile-dump-list</tt> may be unable to locate an unmodified copy
of the file in the current source directories
or at the absolute address, if an absolute address was used when
the file was compiled or loaded.
If this happens, the line number and character position of the beginning
file position are <tt>#f</tt> and the pathname is the pathname originally
used.
A warning is also issued (an exception with condition type
<tt>&amp;warning</tt> is raised) unless the <tt>warn?</tt> argument is provided
and is false.

<p>
Otherwise, the pathname is the path to an unmodified copy of the source
and the line and character positions are set to exact nonnegative integers.

<p>
In either case, the execution count, beginning file position, and ending
file position are all exact nonnegative integers, and the pathname is a string.

<p>
For source positions in files that cannot be found, the list might
contain more than one entry per position due to macro expansion,
procedure inlining, and separate compilation.
In such cases, the counts are not overlapping and can be summed
together to obtain the full count.

<p>
The information returned by <tt>profile-dump-list</tt> can be used to
implement a custom viewer or used as input for offline analysis of
profile information.

<p>
The advantage of <tt>profile-dump-list</tt> over <tt>profile-dump</tt>
is that it attempts to determine the line number and character
position for each source point and, if successful, aggregates
multiple counts for the source point into a single entry.

<p>
<a name="./system:s163"></a><span class=formdef><b>procedure</b>: <tt>(profile-dump-data&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(profile-dump-data&nbsp;<i>path</i>&nbsp;<i>dump</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.

<p>
This procedure writes, in a machine-readable form consumable by
<tt>profile-load-data</tt>, profile counts represented by <tt><i>dump</i></tt>
to the file named by <tt><i>path</i></tt>, replacing the file if it already exists.
<tt><i>dump</i></tt> defaults to the value returned by <tt>profile-dump</tt>.

<p>
<a name="./system:s164"></a><span class=formdef><b>procedure</b>: <tt>(profile-load-data&nbsp;<i>path</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Each <tt><i>path</i></tt> must be a string.

<p>
This procedure reads profile information from the files named by
<tt><i>path</i>&nbsp;...</tt> and stores it in the compiler's internal
database of profile information.
The contents of the files must have been created originally by
<tt>profile-dump-data</tt> using the same version of <i>Chez&nbsp;Scheme</i>.

<p>
The database stores a weight for each source expression or block
rather than the actual count.
When a single file is loaded into the database, the weight is the
proportion of the actual count over the maximum count for all
expressions or blocks represented in the file.
When more than one file is loaded, either by one or multiple calls
to <tt>profile-load-data</tt>, the weights are averaged.

<p>
<a name="./system:s165"></a><span class=formdef><b>procedure</b>: <tt>(profile-query-weight&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt><i>obj</i></tt>'s profile weight, or <tt>#f</tt> if <tt><i>obj</i></tt> is not in the database
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The compiler's profile database maps source objects
(Section&nbsp;<a href="./syntax.html#g109">11.11</a>) to weights.
If <tt><i>obj</i></tt> is a source object, the <tt>profile-query-weight</tt> returns
the weight associated with the source object or <tt>#f</tt> if the database
does not have a weight recorded for the source object.
<tt><i>obj</i></tt> can also be an annotation or syntax object, in which case
<tt>profile-query-weight</tt> first extracts the source object, if any,
using <tt>syntax-&gt;annotation</tt> and <tt>annotation-source</tt>,
returning <tt>#f</tt> if no source-object is found.

<p>
A weight is a flonum in the range 0.0 to 1.0, inclusive, and denotes the
ratio of the actual count to the maximum count as described in the
description of <tt>profile-load-data</tt>.

<p>
<tt>profile-query-weight</tt> can be used by a macro to determine
the relative frequency with which its subexpressions were executed
in the run or runs that generated the information in the database.
This information can be used to guide the generation of code that
is likely to be more efficient.
For example, the <tt>case</tt> macro uses profile information, when
available, to order the clauses so that those whose keys matched
more frequently are tested before those whose keys matched less
frequently.

<p>
<a name="./system:s166"></a><span class=formdef><b>procedure</b>: <tt>(profile-clear-database)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure clears the compiler's profile database.
It has no impact on the counts associated with individual sections
of instrumented code; <tt>profile-clear</tt> can be used to reset
those counts.

<p>

<h3><a name="g119"></a><a name="./system:h8"></a>Section 12.8. Waiter Customization<a name="SECTMISCWAITERS"></a></h3>



<p>
<a name="./system:s167"></a><span class=formdef><b>procedure</b>: <tt>(new-cafe)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(new-cafe&nbsp;<i>eval-proc</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./system:s168"></a><a name="./system:s169"></a><i>Chez&nbsp;Scheme</i> interacts with the user
through a <i>waiter</i>, or read-eval-print loop (REPL).
The waiter operates within a context called a <i>caf&eacute;</i>.
When the system starts up, the user is placed in a caf&eacute; and
given a waiter.
<tt>new-cafe</tt> opens a new Scheme caf&eacute;, stacked on top of the old one.
In addition to starting the waiter, <tt>new-cafe</tt> sets up the caf&eacute;'s
reset and exit handlers (see <tt>reset-handler</tt> and <tt>exit-handler</tt>).
Exiting a caf&eacute; resumes the continuation of the call
to <tt>new-cafe</tt> that created the caf&eacute;.
Exiting from the initial caf&eacute; leaves Scheme altogether.
A caf&eacute; may be exited from either by an explicit call to <tt>exit</tt> or
by receipt of end-of-file ("control-D" on Unix systems) in response
to the waiter's prompt.
In the former case, any values passed to <tt>exit</tt> are returned from
<tt>new-cafe</tt>.

<p>
If the optional <tt><i>eval-proc</i></tt> argument is specified, <tt><i>eval-proc</i></tt>
is used to evaluate forms entered from the console.
Otherwise, the value of the parameter <tt>current-eval</tt> is used.
<tt><i>eval-proc</i></tt> must accept one argument, the expression to evaluate.

<p>
Interesting values for <tt><i>eval-proc</i></tt> include <a name="./system:s170"></a><tt>expand</tt>,
which causes the macro expanded value of each expression entered to
be printed and <tt>(lambda&nbsp;(x)&nbsp;x)</tt>, which simply causes each expression
entered to be printed.
An arbitrary procedure of one argument may be used to facilitate
testing of a program on a series of input values.

<p>

<p><tt>&gt;&nbsp;(new-cafe&nbsp;(lambda&nbsp;(x)&nbsp;x))<br>

&gt;&gt;&nbsp;3<br>

3<br>

&gt;&gt;&nbsp;(a&nbsp;.&nbsp;(b&nbsp;.&nbsp;(c&nbsp;.&nbsp;())))<br>

(a&nbsp;b&nbsp;c)</tt>
<p>
<p><tt>(define&nbsp;sum<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(car&nbsp;ls)&nbsp;(sum&nbsp;(cdr&nbsp;ls))))))<br>

&gt;&nbsp;(new-cafe&nbsp;sum)<br>

&gt;&gt;&nbsp;(1&nbsp;2&nbsp;3)<br>

6</tt>
<p>The default waiter reader (see <tt>waiter-prompt-and-read</tt>) displays
the current waiter prompt (see <tt>waiter-prompt-string</tt>)
to the current value of <a name="./system:s171"></a><tt>console-output-port</tt> and
reads
from the current value of <a name="./system:s172"></a><tt>console-input-port</tt>.
The default waiter printer (see <tt>waiter-write</tt>) sends output
to the current value of <a name="./system:s173"></a><tt>console-output-port</tt>.
These parameters, along with <tt>current-eval</tt>,
can be modified to change the behavior of the waiter.

<p>
<a name="./system:s174"></a><span class=formdef><b>thread parameter</b>: <tt>waiter-prompt-string</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of <tt>waiter-prompt-string</tt> must be a string.
It is used by the default waiter prompter (see the parameter
<tt>waiter-prompt-and-read</tt>) to print a prompt.
Nested caf&eacute;s
are marked by repeating the prompt string once for each nesting level.

<p>

<p><tt>&gt;&nbsp;(waiter-prompt-string)<br>

"&gt;"<br>

&gt;&nbsp;(waiter-prompt-string&nbsp;"%")<br>

%&nbsp;(waiter-prompt-string)<br>

"%"<br>

%&nbsp;(new-cafe)<br>

%%&nbsp;(waiter-prompt-string)<br>

"%"</tt>
<p><a name="./system:s175"></a><span class=formdef><b>thread parameter</b>: <tt>waiter-prompt-and-read</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>waiter-prompt-and-read</tt> must be set to a procedure.
It is used by the waiter to
print a prompt and read an expression.
The value of <tt>waiter-prompt-and-read</tt> is called by the waiter with a
positive integer that indicates the caf&eacute; nesting level.
It should return an expression to be evaluated by the current
evaluator (see <tt>new-cafe</tt> and <tt>current-eval</tt>).

<p>
<a name="./system:s176"></a><span class=formdef><b>procedure</b>: <tt>(default-prompt-and-read&nbsp;<i>level</i>)</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>level</i></tt> must be a positive integer indicating the cafe&eacute; nesting
level as described above.

<p>
This procedure is the default value of the <tt>waiter-prompt-and-read</tt>
parameter whenever the expression editor
(Section&nbsp;<a href="./use.html#g7">2.2</a>, Chapter&nbsp;<a href="./expeditor.html#g132">14</a>) is
<i>not</i> enabled.
It might be defined as follows.

<p>

<p><tt>(define&nbsp;default-prompt-and-read<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(and&nbsp;(integer?&nbsp;n)&nbsp;(&gt;=&nbsp;n&nbsp;0))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violationf&nbsp;'default-prompt-and-read<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"~s&nbsp;is&nbsp;not&nbsp;a&nbsp;nonnegative&nbsp;integer"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([prompt&nbsp;(waiter-prompt-string)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(string=?&nbsp;prompt&nbsp;"")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([n&nbsp;n&nbsp;(-&nbsp;n&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(write-char&nbsp;#\space&nbsp;(console-output-port))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(flush-output-port&nbsp;(console-output-port)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;prompt&nbsp;(console-output-port))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([x&nbsp;(read&nbsp;(console-input-port))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;(and&nbsp;(eof-object?&nbsp;x)&nbsp;(not&nbsp;(string=?&nbsp;prompt&nbsp;"")))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(newline&nbsp;(console-output-port))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(flush-output-port&nbsp;(console-output-port)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x))))</tt>
<p><a name="./system:s177"></a><span class=formdef><b>thread parameter</b>: <tt>waiter-write</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of <tt>waiter-write</tt> must be a procedure.
The waiter uses the value of <tt>waiter-write</tt> to print the results
of each expression read and evaluated by the waiter.
The following example installs a procedure equivalent to the default
<tt>waiter-write</tt>:

<p>

<p><tt>(waiter-write<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(eq?&nbsp;x&nbsp;(void))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pretty-print&nbsp;x&nbsp;(console-output-port)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(flush-output-port&nbsp;(console-output-port))))</tt>
<p><a name="./system:s178"></a><span class=formdef><b>procedure</b>: <tt>(reset)</tt></span>
<br>
<b>returns: </b>does not return
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>reset</tt> invokes the current reset handler (see <tt>reset-handler</tt>)
without arguments.


<p>
<a name="./system:s179"></a><span class=formdef><b>thread parameter</b>: <tt>reset-handler</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of this parameter must be a procedure and should accept zero
arguments.
The current reset handler is called by <tt>reset</tt>.
The default reset handler resets to the current caf&eacute;.


<p>
<a name="./system:s180"></a><span class=formdef><b>procedure</b>: <tt>(exit&nbsp;<i>obj</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>does not return
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>exit</tt> invokes the current exit handler (see
<tt>exit-handler</tt>), passing along its arguments, if any.


<p>
<a name="./system:s181"></a><span class=formdef><b>thread parameter</b>: <tt>exit-handler</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of this parameter must be a procedure and should accept any
number of arguments.
The current exit handler is called by <tt>exit</tt>.

<p>
The default exit handler exits from the current caf&eacute;,
returning its arguments as the values of the call to
<tt>new-cafe</tt> that created the current caf&eacute;.
If the current caf&eacute; is the original caf&eacute;, or if <tt>exit</tt>
is called from a script, <tt>exit</tt> exits from Scheme.
In this case, the exit code for the Scheme process is 0 if
no arguments were supplied or if the first argument is void,
the value of the first argument cast to a C int if
it is an exact integer of the host machine's bit width, and 1 otherwise.

<p>
<a name="./system:s182"></a><span class=formdef><b>procedure</b>: <tt>(abort)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(abort&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>does not return
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>abort</tt> invokes the current abort handler (see <tt>abort-handler</tt>),
passing along its argument, if any.


<p>
<a name="./system:s183"></a><span class=formdef><b>thread parameter</b>: <tt>abort-handler</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of this parameter must be a procedure and should accept either
zero arguments or one argument.
The current abort handler is called by <tt>abort</tt>.

<p>
The default abort handler exits the Scheme process.
The exit code for the Scheme process is -1 if no arguments were supplied,
0 if the first argument is void, the value of the first argument if it is
a 32-bit exact integer, and -1 otherwise.


<p>
<a name="./system:s184"></a><span class=formdef><b>global parameter</b>: <tt>scheme-start</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of <tt>scheme-start</tt> is a procedure that determines the
system's action upon start-up.
The procedure receives zero or more arguments, which are strings
representing the file names (or command-line arguments not recognized
by the Scheme executable) after given on the command line.
The default value first loads the files named by the arguments, then
starts up the initial caf&eacute;:

<p>

<p><tt>(lambda&nbsp;fns<br>

&nbsp;&nbsp;(for-each&nbsp;load&nbsp;fns)<br>

&nbsp;&nbsp;(new-cafe))</tt>
<p><tt>scheme-start</tt> may be altered to start up an application or to
perform customization prior to normal system start-up.

<p>
To have any effect, this parameter must be set within a boot file.
(See Chapter&nbsp;<a href="./use.html#g5">2</a>.)

<p>
<a name="./system:s185"></a><span class=formdef><b>global parameter</b>: <tt>scheme-script</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./system:s186"></a><a name="./system:s187"></a><a name="./system:s188"></a>The value of <tt>scheme-script</tt> is a procedure that determines the
system's action upon start-up,
when the <tt>--script</tt> option is used.
The procedure receives one or more arguments.
The first is a string identifying the script filename and the remainder
are strings representing the remaining file names (or command-line
arguments not recognized by the Scheme executable) given on the command
line.
The default value of this parameter is a procedure that sets the
<tt>command-line</tt> and <tt>command-line-arguments</tt> parameters,
loads the script using <tt>load</tt>, and returns void, which is
translated into a 0 exit status for the script process.

<p>

<p><tt>(lambda&nbsp;(fn&nbsp;.&nbsp;fns)<br>

&nbsp;&nbsp;(command-line&nbsp;(cons&nbsp;fn&nbsp;fns))<br>

&nbsp;&nbsp;(command-line-arguments&nbsp;fns)<br>

&nbsp;&nbsp;(load&nbsp;fn))</tt>
<p><tt>scheme-script</tt> may be altered to start up an application or to
perform customization prior to normal system start-up.

<p>
To have any effect, this parameter must be set within a boot file.
(See Chapter&nbsp;<a href="./use.html#g5">2</a>.)


<p>
<a name="./system:s189"></a><span class=formdef><b>global parameter</b>: <tt>scheme-program</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./system:s190"></a><a name="./system:s191"></a><a name="./system:s192"></a>The value of <tt>scheme-program</tt> is a procedure that determines the
system's action upon start-up
when the <tt>--program</tt> (RNRS top-level program) option is used.
The procedure receives one or more arguments.
The first is a string identifying the program filename and the remainder
are strings representing the remaining file names (or command-line
arguments not recognized by the Scheme executable) given on the command
line.
The default value of this parameter is a procedure that sets the
<tt>command-line</tt> and <tt>command-line-arguments</tt> parameters,
loads the program using <tt>load-program</tt>, and returns void, which is
translated into a 0 exit status for the script process.

<p>

<p><tt>(lambda&nbsp;(fn&nbsp;.&nbsp;fns)<br>

&nbsp;&nbsp;(command-line&nbsp;(cons&nbsp;fn&nbsp;fns))<br>

&nbsp;&nbsp;(command-line-arguments&nbsp;fns)<br>

&nbsp;&nbsp;(load-program&nbsp;fn))</tt>
<p><tt>scheme-program</tt> may be altered to start up an application or to
perform customization prior to normal system start-up.

<p>
To have any effect, this parameter must be set within a boot file.
(See Chapter&nbsp;<a href="./use.html#g5">2</a>.)


<p>
<a name="./system:s193"></a><span class=formdef><b>global parameter</b>: <tt>command-line</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./system:s194"></a>This parameter is set by the default values of <tt>scheme-script</tt>
and <tt>scheme-program</tt>
to a list representing the command line, with the script name followed
by the command-line arguments, when the <tt>--script</tt> or
<tt>--program</tt> option is used on system startup.

<p>
<a name="./system:s195"></a><span class=formdef><b>global parameter</b>: <tt>command-line-arguments</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./system:s196"></a>This parameter is set by the default values of <tt>scheme-script</tt>
and <tt>scheme-program</tt>
to a list of the command-line arguments when the <tt>--script</tt>
or <tt>--program</tt> option is used on system startup.

<p>
<a name="./system:s197"></a><span class=formdef><b>global parameter</b>: <tt>suppress-greeting</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of <tt>suppress-greeting</tt> is a boolean value that determines
whether <i>Chez&nbsp;Scheme</i> prints an identifying banner and copyright notice.
The parameter defaults to <tt>#f</tt> but may be set to <tt>#t</tt> for
use in batch processing applications where the banner would be disruptive.

<p>
To have any effect, this parameter must be set within a boot file.
(See Chapter&nbsp;<a href="./use.html#g5">2</a>.)


<p>

<h3><a name="g120"></a><a name="./system:h9"></a>Section 12.9. Transcript Files<a name="SECTMISCTRANSCRIPTS"></a></h3>



<p>
A <a name="./system:s198"></a>transcript file is a record of an interactive session.
It is also useful as a "quick-and-dirty" alternative to opening an
output file and using explicit output operations.


<p>
<a name="./system:s199"></a><a name="desc:transcript-on"></a>
<span class=formdef><b>procedure</b>: <tt>(transcript-on&nbsp;<i>path</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.

<p>
<tt>transcript-on</tt> opens the file named by <tt><i>path</i></tt> for output,
and it copies to this file all input from the current input port and
all output to the current output port.
An exception is raised with condition-type <tt>i/o-filename</tt> if the
file cannot be opened for output.


<p>
<a name="./system:s200"></a><span class=formdef><b>procedure</b>: <tt>(transcript-off)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>transcript-off</tt> ends transcription and closes the transcript file.


<p>
<a name="./system:s201"></a><span class=formdef><b>procedure</b>: <tt>(transcript-cafe&nbsp;<i>path</i>)</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt>transcript-cafe</tt> opens a transcript file as with
<tt>transcript-on</tt> and
enters a new caf&eacute;; exiting
from this caf&eacute; (see <tt>exit</tt>) also ends transcription and closes the
transcript file.
Invoking <tt>transcript-off</tt> while in a transcript caf&eacute; ends transcription
and closes the transcript file but does not cause an exit from the
caf&eacute;.


<p>

<h3><a name="g121"></a><a name="./system:h10"></a>Section 12.10. Times and Dates<a name="SECTSYSTEMTIMESNDATES"></a></h3>



<p>
This section documents procedures for handling times and dates.  Most of
the procedures described here are proposed in
<a  href=http://srfi.schemers.org/srfi-19/srfi-19.html>SRFI&nbsp;19</a>:
Time Data Types and Procedures, by Will Fitzgerald.

<p>
Times are represented by time objects.
Time objects record the nanosecond and second of a particular time
or duration, along with a <i>time type</i> that identifies the nature
of the time object.
The time type is one of the following symbols:

<p>
<dl compact>
<dt><tt>time-utc</tt>:<dd>
The time elapsed since the "epoch:" 00:00:00 UTC, January 1, 1970,
subject to adjustment, e.g., to correct for leap seconds.

<p>
<dt><tt>time-monotonic</tt>:<dd>
The time elapsed since some arbitrary point in the past, ideally
not subject to adjustment.

<p>
<dt><tt>time-duration</tt>:<dd>
The time elapsed between two times.
When used as an argument to <tt>current-time</tt>, it behaves like
<tt>time-monotonic</tt>, but may also used to represent the result
of subtracting two time objects.

<p>
<dt><tt>time-process</tt>:<dd>
The amount of CPU time used by the current process.

<p>
<dt><tt>time-thread</tt>:<dd>
The amount of CPU time used by the current thread.
It is the same as <tt>time-process</tt> if
not running threaded or if the system does not allow individual
thread times to be determined.

<p>
<dt><tt>time-collector-cpu</tt>:<dd>
The portion of the current process's CPU time consumed by the
garbage collector.

<p>
<dt><tt>time-collector-real</tt>:<dd>
The portion of the current process's real time consumed by the
garbage collector.
</dl>

<p>
A time-object second is an exact integer (possibly negative),
and a nanosecond is an exact nonnegative integer less than 10<sup>9</sup>.
The second and nanosecond of a time object may be converted to
an aggregate nanosecond value by scaling the
seconds by 10<sup>9</sup> and adding the nanoseconds.
Thus, if the second and nanosecond of a time object are 5 and 10,
the time object represents 5000000010 nanoseconds (5.000000010 seconds).
If the second and nanosecond are -5 and 10, the time object
represents -4999999990 nanoseconds (-4.999999990 seconds).

<p>
Dates are represented by date objects.
A date object records the nanosecond, second, minute, hour, day, month,
and year of a particular date, along with an offset that identifies the
time zone.

<p>
As for time objects, a nanosecond is an exact integer less than 10<sup>9</sup>.
A date-object second is, however, an exact nonnegative integer
less than 62.
(The values 61 and 62 allow for leap seconds.)
A minute is an exact nonnegative integer less than 60, and
an hour is an exact nonnegative integer less than 24.
A day is an exact nonnegative integer in ranging from 1 representing
the first day of the month to <i>n</i>, where <i>n</i> is the number of
days in the date's month and year.
A month is an exact nonnegative integer ranging from 1 through 12,
where 1 represents January, 2 represents February, and so on.
A year must be an exact integer.
Years less than 1970 or greater than 2038 may not be supported
depending on limitations of the underlying implementation.
A time-zone offset represents the time-zone offset, in seconds, from UTC.
It is an exact integer in the range -86400 to +86400, inclusive.
For example, Eastern Standard Time (EST), which is 5 hours east, has
offset 5 &times; 3600 = -18000.
The offset for Eastern Daylight Time (EDT) is -14400.
UTC is represented by offset zero.

<p>
<a name="./system:s202"></a><span class=formdef><b>procedure</b>: <tt>(current-time)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(current-time&nbsp;<i>time-type</i>)</tt></span>
<br>
<b>returns: </b>a time object representing the current time
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>time-type</i></tt> must be one of the time-type symbols listed above
and defaults to <tt>time-utc</tt>.

<p>

<p><tt>(current-time)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;time-utc&nbsp;1198815722.473668000&gt;<br>

(current-time&nbsp;'time-process)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;time-process&nbsp;0.120534264&gt;</tt>
<p><a name="./system:s203"></a><span class=formdef><b>procedure</b>: <tt>(make-time&nbsp;<i>type</i>&nbsp;<i>nsec</i>&nbsp;<i>sec</i>)</tt></span>
<br>
<b>returns: </b>a time object
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>type</i></tt> must be one of the time-type symbols listed above.
<tt><i>nsec</i></tt> represents nanoseconds and must be an exact nonnegative
integer less than 10<sup>9</sup>.
<tt><i>sec</i></tt> represents seconds and must be an exact integer.

<p>

<p><tt>(make-time&nbsp;'time-utc&nbsp;787511000&nbsp;1198783214)<br>

(make-time&nbsp;'time-duration&nbsp;10&nbsp;5)<br>

(make-time&nbsp;'time-duration&nbsp;10&nbsp;-5)</tt>
<p><a name="./system:s204"></a><span class=formdef><b>procedure</b>: <tt>(time?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a time object, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(time?&nbsp;(current-time))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(time?&nbsp;(make-time&nbsp;'time-utc&nbsp;0&nbsp;0))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(time?&nbsp;"1400&nbsp;hours")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./system:s205"></a><span class=formdef><b>procedure</b>: <tt>(time-type&nbsp;<i>time</i>)</tt></span>
<br>
<b>returns: </b>the time type of <tt><i>time</i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(time-nanosecond&nbsp;<i>time</i>)</tt></span>
<br>
<b>returns: </b>the nanosecond of <tt><i>time</i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(time-second&nbsp;<i>time</i>)</tt></span>
<br>
<b>returns: </b>the second of <tt><i>time</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>time</i></tt> must be a time object.

<p>

<p><tt>(time-type&nbsp;(current-time))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;time-utc<br>

(time-type&nbsp;(current-time&nbsp;'time-process))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;time-process<br>

(time-type&nbsp;(make-time&nbsp;'time-duration&nbsp;0&nbsp;50))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;time-duration<br>

(time-second&nbsp;(current-time))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1198816497<br>

(time-nanosecond&nbsp;(current-time))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2399000<br>

(time-second&nbsp;(make-time&nbsp;'time-duration&nbsp;10&nbsp;-5))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-5<br>

(time-nanosecond&nbsp;(make-time&nbsp;'time-duration&nbsp;10&nbsp;-5))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;10</tt>
<p><a name="./system:s206"></a><span class=formdef><b>procedure</b>: <tt>(set-time-type!&nbsp;<i>time</i>&nbsp;<i>type</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br><span class=formdef><b>procedure</b>: <tt>(set-time-nanosecond!&nbsp;<i>time</i>&nbsp;<i>nsec</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br><span class=formdef><b>procedure</b>: <tt>(set-time-second!&nbsp;<i>time</i>&nbsp;<i>sec</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>time</i></tt> must be a time object.
<tt><i>type</i></tt> must be one of the time-type symbols listed above.
<tt><i>nsec</i></tt> represents nanoseconds and must be an exact nonnegative
integer less than 10<sup>9</sup>.
<tt><i>sec</i></tt> represents seconds and must be an exact integer.

<p>
Each of these procedures modifies the time object, changing one aspect
while leaving the others unaffected.
For example, <tt>set-time-nanosecond!</tt> changes the nanosecond of
<tt><i>time</i></tt> without changing the second or type.
In particular, no conversion of values is performed when the type of a time
object is changed.

<p>
<a name="./system:s207"></a><span class=formdef><b>procedure</b>: <tt>(time=?&nbsp;<i>time<sub>1</sub></i>&nbsp;<i>time<sub>2</sub></i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(time&lt;?&nbsp;<i>time<sub>1</sub></i>&nbsp;<i>time<sub>2</sub></i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(time&lt;=?&nbsp;<i>time<sub>1</sub></i>&nbsp;<i>time<sub>2</sub></i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(time&gt;=?&nbsp;<i>time<sub>1</sub></i>&nbsp;<i>time<sub>2</sub></i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(time&gt;?&nbsp;<i>time<sub>1</sub></i>&nbsp;<i>time<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the relation holds, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>time<sub>1</sub></i></tt> and <tt><i>time<sub>2</sub></i></tt> must be time objects and must have
the same type.

<p>

<p><tt>(let&nbsp;([t&nbsp;(current-time)])<br>

&nbsp;&nbsp;(time=?&nbsp;t&nbsp;t))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([t&nbsp;(current-time)])<br>

&nbsp;&nbsp;(let&nbsp;loop&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;(time=?&nbsp;(current-time)&nbsp;t))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop))<br>

&nbsp;&nbsp;(time&gt;?&nbsp;(current-time)&nbsp;t))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./system:s208"></a><span class=formdef><b>procedure</b>: <tt>(copy-time&nbsp;<i>time</i>)</tt></span>
<br>
<b>returns: </b>a copy of <tt><i>time</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>(define&nbsp;t1&nbsp;(current-time))<br>

(define&nbsp;t2&nbsp;(copy-time&nbsp;t1))<br>

(eq?&nbsp;t2&nbsp;t1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(eqv?&nbsp;(time-second&nbsp;t2)&nbsp;(time-second&nbsp;t1))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;(time-nanosecond&nbsp;t2)&nbsp;(time-nanosecond&nbsp;t1))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./system:s209"></a><span class=formdef><b>procedure</b>: <tt>(time-difference&nbsp;<i>time<sub>1</sub></i>&nbsp;<i>time<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the result of subtracting <tt><i>time<sub>2</sub></i></tt> from <tt><i>time<sub>1</sub></i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(time-difference!&nbsp;<i>time<sub>1</sub></i>&nbsp;<i>time<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the result of subtracting <tt><i>time<sub>2</sub></i></tt> from <tt><i>time<sub>1</sub></i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(add-duration&nbsp;<i>time</i>&nbsp;<i>time<sub>d</sub></i>)</tt></span>
<br>
<b>returns: </b>the result of adding <tt><i>time<sub>d</sub></i></tt> to <tt>time</tt>
<br><span class=formdef><b>procedure</b>: <tt>(add-duration!&nbsp;<i>time</i>&nbsp;<i>time<sub>d</sub></i>)</tt></span>
<br>
<b>returns: </b>the result of adding <tt><i>time<sub>d</sub></i></tt> to <tt>time</tt>
<br><span class=formdef><b>procedure</b>: <tt>(subtract-duration&nbsp;<i>time</i>&nbsp;<i>time<sub>d</sub></i>)</tt></span>
<br>
<b>returns: </b>the result of subtracting <tt><i>time<sub>d</sub></i></tt> from <tt>time</tt>
<br><span class=formdef><b>procedure</b>: <tt>(subtract-duration!&nbsp;<i>time</i>&nbsp;<i>time<sub>d</sub></i>)</tt></span>
<br>
<b>returns: </b>the result of subtracting <tt><i>time<sub>d</sub></i></tt> from <tt>time</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>For <tt>time-difference</tt>, <tt><i>time<sub>1</sub></i></tt> and <tt><i>time<sub>2</sub></i></tt> must
have the same time type, and the result is a time object with
time type <tt>time-duration</tt>.
For <tt>add-duration</tt>, <tt>add-duration!</tt>,
<tt>subtract-duration</tt>, and <tt>subtract-duration!</tt>,
<tt><i>time<sub>d</sub></i></tt> must have time type <tt>time-duration</tt>,
and the result is a time object with the same time type as
<tt><i>time</i></tt>.
<tt>time-difference!</tt>, <tt>add-duration!</tt>, and
<tt>subtract-duration!</tt> are potentially destructive, i.e., each
might modify and return its first argument, or it might allocate a
new time object.

<p>

<p><tt>(let&nbsp;([delay&nbsp;(make-time&nbsp;'time-duration&nbsp;0&nbsp;1)])<br>

&nbsp;&nbsp;(let&nbsp;([t1&nbsp;(current-time&nbsp;'time-monotonic)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(sleep&nbsp;delay)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([t2&nbsp;(current-time&nbsp;'time-monotonic)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([t3&nbsp;(time-difference&nbsp;t2&nbsp;t1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eq?&nbsp;(time-type&nbsp;t3)&nbsp;'time-duration)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(time&gt;=?&nbsp;t3&nbsp;delay)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(time=?&nbsp;(add-duration&nbsp;t1&nbsp;t3)&nbsp;t2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(time=?&nbsp;(subtract-duration&nbsp;t2&nbsp;t3)&nbsp;t1))))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./system:s210"></a><span class=formdef><b>procedure</b>: <tt>(current-date)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(current-date&nbsp;<i>offset</i>)</tt></span>
<br>
<b>returns: </b>a date object representing the current date
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>offset</i></tt> represents the time-zone offset in seconds east of UTC,
as described above.
It must be an exact integer in the range -86400 to
+86400, inclusive and defaults to the local time-zone offset.
UTC may be obtained by passing an offset of zero.

<p>
If <tt><i>offset</i></tt> is not provided, then the current time zone's offset
is used, and <tt>date-dst?</tt> and <tt>date-zone-name</tt> report
information about the time zone. If <tt><i>offset</i></tt> is provided, then
<tt>date-dst?</tt> and <tt>date-zone-name</tt> on the resulting date
object produce <tt>#f</tt>.

<p>
The following examples assume the local time zone is EST.

<p>

<p><tt>(current-date)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;date&nbsp;Thu&nbsp;Dec&nbsp;27&nbsp;23:23:20&nbsp;2007&gt;<br>

(current-date&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;date&nbsp;Fri&nbsp;Dec&nbsp;28&nbsp;04:23:20&nbsp;2007&gt;
<br>
<br>
(date-zone-name&nbsp;(current-date))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"EST"&nbsp;<i>or&nbsp;other&nbsp;system-provided&nbsp;string</i><br>

(date-zone-name&nbsp;(current-date&nbsp;0))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./system:s211"></a><span class=formdef><b>procedure</b>: <tt>(make-date&nbsp;<i>nsec</i>&nbsp;<i>sec</i>&nbsp;<i>min</i>&nbsp;<i>hour</i>&nbsp;<i>day</i>&nbsp;<i>mon</i>&nbsp;<i>year</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-date&nbsp;<i>nsec</i>&nbsp;<i>sec</i>&nbsp;<i>min</i>&nbsp;<i>hour</i>&nbsp;<i>day</i>&nbsp;<i>mon</i>&nbsp;<i>year</i>&nbsp;<i>offset</i>)</tt></span>
<br>
<b>returns: </b>a date object
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>nsec</i></tt> represents nanoseconds and must be an exact nonnegative integer
less than 10<sup>9</sup>.
<tt><i>sec</i></tt> represents seconds and must be an exact nonnegative integer
less than 62.
<tt><i>min</i></tt> represents minutes and must be an exact nonnegative integer
less than 60.
<tt><i>hour</i></tt> must be an exact nonnegative integer less than 24.
<tt><i>day</i></tt> must be an exact integer, 1 &le; <i>day</i> &le; 31.
(The actual upper limit may be less depending on the month and year.)
<tt><i>mon</i></tt> represents the month must be an exact integer, 1 &le; <i>mon</i> &le; 12.
<tt><i>year</i></tt> must be an exact integer.
It should be at least 1970.
<tt><i>offset</i></tt> represents the time-zone offset in seconds east of UTC,
as described above.
It must be an exact integer in the range -86400 to +86400, inclusive.
UTC may be specified by passing an offset of zero.

<p>
If <tt><i>offset</i></tt> is not provided, then the current time zone's offset
is used, and <tt>date-dst?</tt> and <tt>date-zone-name</tt> report
information about the time zone. If <tt><i>offset</i></tt> is provided, then
<tt>date-dst?</tt> and <tt>date-zone-name</tt> on the resulting date
object produce <tt>#f</tt>.

<p>

<p><tt>(make-date&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;1&nbsp;1&nbsp;1970&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;date&nbsp;Thu&nbsp;Jan&nbsp;&nbsp;1&nbsp;00:00:00&nbsp;1970&gt;<br>

(make-date&nbsp;0&nbsp;30&nbsp;7&nbsp;9&nbsp;23&nbsp;9&nbsp;2007&nbsp;-14400)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;date&nbsp;Sun&nbsp;Sep&nbsp;23&nbsp;09:07:30&nbsp;2007&gt;
<br>
<br>
(date-zone-name&nbsp;(make-date&nbsp;0&nbsp;30&nbsp;7&nbsp;9&nbsp;23&nbsp;9&nbsp;2007&nbsp;-14400))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(string?&nbsp;(date-zone-name&nbsp;(make-date&nbsp;0&nbsp;30&nbsp;7&nbsp;9&nbsp;23&nbsp;9&nbsp;2007)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./system:s212"></a><span class=formdef><b>procedure</b>: <tt>(date?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a date object, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(date?&nbsp;(current-date))<br>

(date?&nbsp;(make-date&nbsp;0&nbsp;30&nbsp;7&nbsp;9&nbsp;23&nbsp;9&nbsp;2007&nbsp;-14400))<br>

(date?&nbsp;"Sun&nbsp;Sep&nbsp;23&nbsp;09:07:30&nbsp;2007")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./system:s213"></a><span class=formdef><b>procedure</b>: <tt>(date-nanosecond&nbsp;<i>date</i>)</tt></span>
<br>
<b>returns: </b>the nanosecond of <tt><i>date</i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(date-second&nbsp;<i>date</i>)</tt></span>
<br>
<b>returns: </b>the second of <tt><i>date</i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(date-minute&nbsp;<i>date</i>)</tt></span>
<br>
<b>returns: </b>the minute of <tt><i>date</i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(date-hour&nbsp;<i>date</i>)</tt></span>
<br>
<b>returns: </b>the hour of <tt><i>date</i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(date-day&nbsp;<i>date</i>)</tt></span>
<br>
<b>returns: </b>the day of <tt><i>date</i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(date-month&nbsp;<i>date</i>)</tt></span>
<br>
<b>returns: </b>the month of <tt><i>date</i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(date-year&nbsp;<i>date</i>)</tt></span>
<br>
<b>returns: </b>the year of <tt><i>date</i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(date-zone-offset&nbsp;<i>date</i>)</tt></span>
<br>
<b>returns: </b>the time-zone offset of <tt><i>date</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>date</i></tt> must be a date object.

<p>

<p><tt>(define&nbsp;d&nbsp;(make-date&nbsp;0&nbsp;30&nbsp;7&nbsp;9&nbsp;23&nbsp;9&nbsp;2007&nbsp;-14400))<br>

(date-nanosecond&nbsp;d)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(date-second&nbsp;d)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;30<br>

(date-minute&nbsp;d)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;7<br>

(date-hour&nbsp;d)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;9<br>

(date-day&nbsp;d)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;23<br>

(date-month&nbsp;d)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;9<br>

(date-year&nbsp;d)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2007<br>

(date-zone-offset&nbsp;d)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-14400</tt>
<p><a name="./system:s214"></a><span class=formdef><b>procedure</b>: <tt>(date-week-day&nbsp;<i>date</i>)</tt></span>
<br>
<b>returns: </b>the week-day of <tt><i>date</i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(date-year-day&nbsp;<i>date</i>)</tt></span>
<br>
<b>returns: </b>the year-day of <tt><i>date</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These procedures allow the day-of-week or day-of-year to be determined for
the date represented by <tt><i>date</i></tt>.
A week-day is an exact nonnegative integer less than 7, where
0 represents Sunday, 1 represents Monday, and so on.
A year-day is an exact nonnegative integer less than 367, where
0 represents the first day of the year (January 1), 1 the
second day, 2 the third, and so on.

<p>

<p><tt>(define&nbsp;d1&nbsp;(make-date&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;1&nbsp;1&nbsp;1970&nbsp;-18000))<br>

d1&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;date&nbsp;Thu&nbsp;Jan&nbsp;&nbsp;1&nbsp;00:00:00&nbsp;1970&gt;<br>

(date-week-day&nbsp;d1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4<br>

(date-year-day&nbsp;d1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0
<br>
<br>
(define&nbsp;d2&nbsp;(make-date&nbsp;0&nbsp;30&nbsp;7&nbsp;9&nbsp;23&nbsp;9&nbsp;2007&nbsp;-14400))<br>

d2&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;date&nbsp;Sun&nbsp;Sep&nbsp;23&nbsp;09:07:30&nbsp;2007&gt;<br>

(date-week-day&nbsp;d2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(date-year-day&nbsp;d2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;265</tt>
<p><a name="./system:s215"></a><span class=formdef><b>procedure</b>: <tt>(date-dst?&nbsp;<i>date</i>)</tt></span>
<br>
<b>returns: </b>whether <tt><i>date</i></tt> is in Daylight Saving Time
<br><span class=formdef><b>procedure</b>: <tt>(date-zone-name&nbsp;<i>date</i>)</tt></span>
<br>
<b>returns: </b><tt>#f</tt> or a string naming the time zone of <tt><i>date</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These procedures report time-zone information for
the date represented by <tt><i>date</i></tt> for a date object that
is constructed without an explicit time-zone offset. When
a date object is created instead with explicit time-zone offset,
these procedures produce <tt>#f</tt>.

<p>
Daylight Saving Time status for the current time zone and a name
string for the time zone are computed using platform-specific routines.
In particular, the format of the zone name is platform-specific.

<p>

<p><tt>(define&nbsp;d&nbsp;(make-date&nbsp;0&nbsp;30&nbsp;7&nbsp;9&nbsp;23&nbsp;9&nbsp;2007))<br>

(date-zone-offset&nbsp;d)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-14400&nbsp;<i>assuming&nbsp;Eastern&nbsp;U.S.&nbsp;time&nbsp;zone</i><br>

(date-dst?&nbsp;d)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(date-zone-name&nbsp;d)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"EDT"&nbsp;<i>or&nbsp;some&nbsp;system-provided&nbsp;string</i></tt>
<p><a name="./system:s216"></a><span class=formdef><b>procedure</b>: <tt>(time-utc-&gt;date&nbsp;<i>time</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(time-utc-&gt;date&nbsp;<i>time</i>&nbsp;<i>offset</i>)</tt></span>
<br>
<b>returns: </b>a date object corresponding to <tt><i>time</i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(date-&gt;time-utc&nbsp;<i>date</i>)</tt></span>
<br>
<b>returns: </b>a time object corresponding to <tt><i>date</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These procedures are used to convert between time and date objects.
The <tt><i>time</i></tt> argument to <tt>time-utc-&gt;date</tt> must have time-type
<tt>utc</tt>, and <tt>date-&gt;time-utc</tt> always returns a time
object with time-type <tt>utc</tt>.

<p>
For <tt>time-utc-&gt;date</tt>,
<tt><i>offset</i></tt> represents the time-zone offset in seconds east of UTC,
as described at the beginning of this section.
It must be an exact integer in the range -86400 to
+86400, inclusive and defaults to the local time-zone offset.
UTC may be obtained by passing an offset of zero.

<p>
If <tt><i>offset</i></tt> is not provided to <tt>time-utc-&gt;date</tt>, then the current time zone's offset
is used, and <tt>date-dst?</tt> and <tt>date-zone-name</tt> report
information about the time zone. If <tt><i>offset</i></tt> is provided, then
<tt>date-dst?</tt> and <tt>date-zone-name</tt> on the resulting date
object produce <tt>#f</tt>.

<p>

<p><tt>(define&nbsp;d&nbsp;(make-date&nbsp;0&nbsp;30&nbsp;7&nbsp;9&nbsp;23&nbsp;9&nbsp;2007&nbsp;-14400))<br>

(date-&gt;time-utc&nbsp;d)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;time-utc&nbsp;1190552850.000000000&gt;<br>

(define&nbsp;t&nbsp;(make-time&nbsp;'time-utc&nbsp;0&nbsp;1190552850))<br>

(time-utc-&gt;date&nbsp;t)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;date&nbsp;Sun&nbsp;Sep&nbsp;23&nbsp;09:07:30&nbsp;2007&gt;<br>

(time-utc-&gt;date&nbsp;t&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;date&nbsp;Sun&nbsp;Sep&nbsp;23&nbsp;13:07:30&nbsp;2007&gt;</tt>
<p><a name="./system:s217"></a><span class=formdef><b>procedure</b>: <tt>(date-and-time)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(date-and-time&nbsp;<i>date</i>)</tt></span>
<br>
<b>returns: </b>a string giving the current date and time
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The string is always in the format illustrated by the examples below and
always has length 24.

<p>

<p><tt>(date-and-time)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"Fri&nbsp;Jul&nbsp;13&nbsp;13:13:13&nbsp;2001"<br>

(define&nbsp;d&nbsp;(make-date&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;1&nbsp;1&nbsp;2007&nbsp;0))<br>

(date-and-time&nbsp;d)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"Mon&nbsp;Jan&nbsp;01&nbsp;00:00:00&nbsp;2007"</tt>
<p><a name="./system:s218"></a><span class=formdef><b>procedure</b>: <tt>(sleep&nbsp;<i>time</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>time</i></tt> must be a time object with type <tt>time-duration</tt>.
<tt><i>sleep</i></tt> causes the invoking thread to suspend operation for
approximately the amount of time indicated by the time object, unless
the process receives a signal that interrupts the sleep operation.
The actual time slept depends on the granularity of the system clock
and how busy the system is running other threads and processes.


<p>

<h3><a name="g122"></a><a name="./system:h11"></a>Section 12.11. Timing and Statistics<a name="SECTMISCSTATISTICS"></a></h3>



<p>
This section documents procedures for timing computations.
The <tt>current-time</tt> procedure described in
Section&nbsp;<a href="./system.html#g121">12.10</a> may also be used to
time computations.

<p>
<a name="./system:s219"></a><span class=formdef><b>syntax</b>: <tt>(time&nbsp;<i>expr</i>)</tt></span>
<br>
<b>returns: </b>the values of <tt><i>expr</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>time</tt> evaluates <tt><i>expr</i></tt> and, as a side-effect, prints (to the
console-output port) the amount of cpu time, the amount of real time,
the number of bytes allocated, and the amount of collection overhead
associated with evaluating <tt><i>expr</i></tt>.

<p>

<p><tt>&gt;&nbsp;(time&nbsp;(collect))<br>

(time&nbsp;(collect))<br>

&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;collection<br>

&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;ms&nbsp;elapsed&nbsp;cpu&nbsp;time,&nbsp;including&nbsp;1&nbsp;ms&nbsp;collecting<br>

&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;ms&nbsp;elapsed&nbsp;real&nbsp;time,&nbsp;including&nbsp;1&nbsp;ms&nbsp;collecting<br>

&nbsp;&nbsp;&nbsp;&nbsp;160&nbsp;bytes&nbsp;allocated,&nbsp;including&nbsp;8184&nbsp;bytes&nbsp;reclaimed</tt>
<p><a name="./system:s220"></a><span class=formdef><b>procedure</b>: <tt>(display-statistics)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(display-statistics&nbsp;<i>textual-output-port</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure displays a running total of the amount of
cpu time, real time, bytes allocated, and collection overhead.
If <tt><i>textual-output-port</i></tt> is not supplied, it defaults to the current output port.


<p>
<a name="./system:s221"></a><span class=formdef><b>procedure</b>: <tt>(cpu-time)</tt></span>
<br>
<b>returns: </b>the amount of cpu time consumed since system start-up
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The amount is in milliseconds.
The amount includes "system" as well as "user" time, i.e., time
spent in the kernel on behalf of the process as well as time spent in
the process itself.

<p>
See also <tt>current-time</tt>, which returns more precise information.


<p>
<a name="./system:s222"></a><span class=formdef><b>procedure</b>: <tt>(real-time)</tt></span>
<br>
<b>returns: </b>the amount of real time that has elapsed since system start-up
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The amount is in milliseconds.

<p>
See also <tt>current-time</tt>, which returns more precise information.


<p>
<a name="./system:s223"></a><span class=formdef><b>procedure</b>: <tt>(bytes-allocated)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(bytes-allocated&nbsp;<i>g</i>)</tt></span>
<br>
<b>returns: </b>the number of bytes currently allocated
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>g</i></tt> is supplied, <tt>bytes-allocated</tt> returns the number of
bytes currently allocated for Scheme objects in the specified generation.
<tt><i>g</i></tt> must be a nonnegative exact integer no greater than the
maximum nonstatic generation, i.e., the
value returned by <tt>collect-maximum-generation</tt>, or the symbol
<tt>static</tt>.
If <tt><i>g</i></tt> is not supplied, <tt>bytes-allocated</tt> returns the total
number of bytes allocated in all generations.


<p>
<a name="./system:s224"></a><span class=formdef><b>procedure</b>: <tt>(initial-bytes-allocated)</tt></span>
<br>
<b>returns: </b>the total number of bytes allocated after loading boot files
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./system:s225"></a><span class=formdef><b>procedure</b>: <tt>(bytes-deallocated)</tt></span>
<br>
<b>returns: </b>the total number of bytes deallocated by the garbage collector
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The total number of bytes allocated by the current process, whether
still in use or not, can be obtained by summing
<tt>(bytes-deallocated)</tt> and <tt>(bytes-allocated)</tt>
and possibly subtracting <tt>(initial-bytes-allocated)</tt>.

<p>
<a name="./system:s226"></a><span class=formdef><b>procedure</b>: <tt>(current-memory-bytes)</tt></span>
<br>
<b>returns: </b>the total number of bytes currently allocated, including overhead
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>current-memory-bytes</tt> returns the total size of the heap
in bytes, including not only the bytes occupied for Scheme objects
but also various forms of overhead, including fragmentation and
reserved but not currently occupied memory, and is thus an accurate
measure of the amount of heap memory currently reserved from the
operating system for the current process.

<p>
<a name="./system:s227"></a><span class=formdef><b>procedure</b>: <tt>(maximum-memory-bytes)</tt></span>
<br>
<b>returns: </b>the maximum number of bytes ever allocated, including overhead
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>maximum-memory-bytes</tt> returns the maximum size of the heap
in bytes, i.e., the maximum value that <tt>current-memory-bytes</tt>
returned or could have returned, since the last call to
<tt>reset-maximum-memory-bytes!</tt> or, if there has been no such
call, since the process started.

<p>
<a name="./system:s228"></a><span class=formdef><b>procedure</b>: <tt>(reset-maximum-memory-bytes!)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>reset-maximum-memory-bytes!</tt> resets the maximum recorded size
of the heap to the current size of the heap.

<p>
<a name="./system:s229"></a><span class=formdef><b>procedure</b>: <tt>(collections)</tt></span>
<br>
<b>returns: </b>the number garbage collections so far
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./system:s230"></a><span class=formdef><b>procedure</b>: <tt>(statistics)</tt></span>
<br>
<b>returns: </b>a sstats record containing current statistics
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>statistics</tt> packages together various timing and allocation
statistics into a single <tt>sstats</tt> record.
A <tt>sstats</tt> record has the following fields:

<p>
<dl compact>
<dt><tt>cpu</tt>,<dd> the cpu time consumed,
<dt><tt>real</tt>,<dd> the elapsed real time,
<dt><tt>bytes</tt>,<dd> the number of bytes allocated,
<dt><tt>gc-count</tt>,<dd> the number of collections,
<dt><tt>gc-cpu</tt>,<dd> the cpu time consumed during collections,
<dt><tt>gc-real</tt>,<dd> the elapsed real time during collections, and
<dt><tt>gc-bytes</tt>,<dd> the number of bytes reclaimed by the collector.
</dl>

<p>
All values are computed since system start-up.
The time values are time objects (Section&nbsp;<a href="./system.html#g121">12.10</a>),
and the bytes and count values are exact integers.

<p>
<tt>statistics</tt> might be defined as follows:

<p>

<p><tt>(define&nbsp;statistics<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(make-sstats<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(current-time&nbsp;'time-thread)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(current-time&nbsp;'time-monotonic)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;(+&nbsp;(bytes-allocated)&nbsp;(bytes-deallocated))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(initial-bytes-allocated))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(collections)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(current-time&nbsp;'time-collector-cpu)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(current-time&nbsp;'time-collector-real)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bytes-deallocated))))</tt>
<p><a name="./system:s231"></a><span class=formdef><b>procedure</b>: <tt>(make-sstats&nbsp;<i>cpu</i>&nbsp;<i>real</i>&nbsp;<i>bytes</i>&nbsp;<i>gc-count</i>&nbsp;<i>gc-cpu</i>&nbsp;<i>gc-real</i>&nbsp;<i>gc-bytes</i>)</tt></span>
<br>
<b>returns: </b>a sstats record
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The time arguments (<tt><i>cpu</i></tt>, <tt><i>real</i></tt>, <tt><i>gc-cpu</i></tt>, and <tt><i>gc-real</i></tt>) must be time objects.
The other arguments must be exact integers.


<p>
<a name="./system:s232"></a><span class=formdef><b>procedure</b>: <tt>(sstats?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a sstats record, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./system:s233"></a><span class=formdef><b>procedure</b>: <tt>(sstats-cpu&nbsp;<i>s</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(sstats-real&nbsp;<i>s</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(sstats-bytes&nbsp;<i>s</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(sstats-gc-count&nbsp;<i>s</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(sstats-gc-cpu&nbsp;<i>s</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(sstats-gc-real&nbsp;<i>s</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(sstats-gc-bytes&nbsp;<i>s</i>)</tt></span>
<br>
<b>returns: </b>the value of the corresponding field of <tt><i>s</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>s</i></tt> must be a sstats record.

<p>
<a name="./system:s234"></a><span class=formdef><b>procedure</b>: <tt>(set-sstats-cpu!&nbsp;<i>s</i>&nbsp;<i>new-value</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-sstats-real!&nbsp;<i>s</i>&nbsp;<i>new-value</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-sstats-bytes!&nbsp;<i>s</i>&nbsp;<i>new-value</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-sstats-gc-count!&nbsp;<i>s</i>&nbsp;<i>new-value</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-sstats-gc-cpu!&nbsp;<i>s</i>&nbsp;<i>new-value</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-sstats-gc-real!&nbsp;<i>s</i>&nbsp;<i>new-value</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-sstats-gc-bytes!&nbsp;<i>s</i>&nbsp;<i>new-value</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>s</i></tt> must be a sstats record, the <tt><i>new-value</i></tt> arguments for the time fields
(<tt><i>cpu</i></tt>, <tt><i>real</i></tt>, <tt><i>gc-cpu</i></tt>, and <tt><i>gc-real</i></tt>)
must be time objects, and
the other <tt><i>new-value</i></tt> arguments must be exact integers.
Each procedure sets the value of the corresponding field of <tt><i>s</i></tt> to
<tt><i>new-value</i></tt>.


<p>
<a name="./system:s235"></a><span class=formdef><b>procedure</b>: <tt>(sstats-difference&nbsp;<i>s<sub>1</sub></i>&nbsp;<i>s<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>a sstats record representing the difference between <tt><i>s<sub>1</sub></i></tt> and <tt><i>s<sub>2</sub></i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>s<sub>1</sub></i></tt> and <tt><i>s<sub>2</sub></i></tt> must be sstats records.
<tt>sstats-difference</tt> subtracts each field of <tt><i>s<sub>2</sub></i></tt> from the
corresponding field of <tt><i>s<sub>1</sub></i></tt> to produce the resulting <tt>sstats</tt>
record.

<p>
<a name="./system:s236"></a><span class=formdef><b>procedure</b>: <tt>(sstats-print&nbsp;<i>s</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(sstats-print&nbsp;<i>s</i>&nbsp;<i>textual-output-port</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>s</i></tt> must be a <tt>sstats</tt> record.
If <tt><i>textual-output-port</i></tt> is not supplied, it defaults to the current output port.
<tt>sstats-print</tt> displays the fields of <tt>s</tt> in a manner similar
to <tt>display-statistics</tt> and <tt>time</tt>.


<p>
<a name="./system:s237"></a><span class=formdef><b>global parameter</b>: <tt>enable-object-counts</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of <tt>enable-object-counts</tt> is a boolean value that
determines whether the collector records object counts as it runs and
hence whether the object counts returned by the procedure
<tt>object-counts</tt> are accurate.
The parameter is set to <tt>#f</tt> by default, since enabling object
counts adds overhead to collection.

<p>
Counts for the static generation are always correct.
Counts for a nonstatic generation <i>n</i> are correct immediately after a
collection of generation <i>m</i> &ge; <i>n</i> (regardless of whether the target
generation is <i>m</i> or <i>m</i> + 1) if <tt>enable-object-counts</tt>
was set to <tt>#t</tt> during the collection.

<p>
One strategy for collecting object counts with minimal overhead is
to enable object counts only while collecting the maximum nonstatic
generation and to obtain the object counts immediately after that
collection.

<p>
<a name="./system:s238"></a><span class=formdef><b>procedure</b>: <tt>(object-counts)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The procedure <tt>object-counts</tt> returns a nested association list
representing object counts and bytes allocated for each heap-allocated
primitive type and record type with at least one live instance in one
or more generations.
(Heap-allocated primitive types include, e.g., pairs and vectors, but
not, e.g., fixnums or characters.)
Object counts are gathered by the collector only when
<tt>enable-object-counts</tt> is <tt>#t</tt>.
The description of <tt>enable-object-counts</tt> details the
circumstances under which the counts are accurate.

<p>
The association list returned by <tt>object-counts</tt> has the following
structure:

<p>

<p><tt>((<i>type</i>&nbsp;(<i>generation</i>&nbsp;<i>count</i>&nbsp;.&nbsp;<i>bytes</i>)&nbsp;...)&nbsp;...)</tt>
<p><tt><i>type</i></tt> is either the name of a primitive type, represented as a
symbol, e.g., <tt>pair</tt>, or a record-type descriptor (rtd).
<tt><i>generation</i></tt> is a nonnegative fixnum between 0 and the value
of <tt>(collect-maximum-generation)</tt>, inclusive, or the symbol
<tt>static</tt> representing the static generation.
<tt><i>count</i></tt> and <tt><i>bytes</i></tt> are nonnegative fixnums.

<p>

<p><tt>(collect-request-handler&nbsp;void)<br>

(enable-object-counts&nbsp;#t)<br>

(define-record-type&nbsp;frob&nbsp;(fields&nbsp;x))<br>

(define&nbsp;x&nbsp;(make-frob&nbsp;(make-frob&nbsp;#f)))<br>

(collect&nbsp;3&nbsp;3)<br>

(cdr&nbsp;(assoc&nbsp;3<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;(assoc&nbsp;(record-type-descriptor&nbsp;frob)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(object-counts)))))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(2&nbsp;.&nbsp;16)</tt>
<p>
<h3><a name="g123"></a><a name="./system:h12"></a>Section 12.12. Cost Centers<a name="SECTMISCCOSTCENTERS"></a></h3>



<p>
Cost centers are used to track the bytes allocated, instructions executed,
and/or cpu time elapsed while evaluating selected sections of code.
Cost centers are created via the procedure <tt>make-cost-center</tt>, and
costs are tracked via the procedure <tt>with-cost-center</tt>.

<p>
Allocation and instruction counts are tracked only for code instrumented
for that purpose.
This instrumentation is controlled by two parameters: <tt>generate-allocation-counts</tt>
and <tt>generate-instruction-counts</tt>.
Instrumentation is disabled by default.
Built in procedures are not instrumented, nor is interpreted code or
non-Scheme code.
Elapsed time is tracked only when the optional <tt>timed?</tt> argument to
<tt>with-cost-center</tt> is provided and is not false.

<p>
The <tt>with-cost-center</tt> procedure accurately tracks costs, subject
to the caveats above, even when reentered with the same cost center, used
simultaneously in multiple threads, and exited or reentered one or more
times via continuation invocation.

<p>
<a name="./system:s239"></a><span class=formdef><b>thread parameter</b>: <tt>generate-allocation-counts</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When this parameter has a true value, the compiler inserts a short sequence of
instructions at each allocation point in generated code to track the amount of
allocation that occurs.
This parameter is initially false.

<p>
<a name="./system:s240"></a><span class=formdef><b>thread parameter</b>: <tt>generate-instruction-counts</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When this parameter has a true value, the compiler inserts a short
sequence of instructions in each block of generated code to track the
number of instructions executed by that block.
This parameter is initially false.

<p>
<a name="./system:s241"></a><span class=formdef><b>procedure</b>: <tt>(make-cost-center)</tt></span>
<br>
<b>returns: </b>a new cost center
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The recorded costs of the new cost center are initialized to zero.

<p>
<a name="./system:s242"></a><span class=formdef><b>procedure</b>: <tt>(cost-center?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a cost center, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./system:s243"></a><span class=formdef><b>procedure</b>: <tt>(with-cost-center&nbsp;<i>cost-center</i>&nbsp;<i>thunk</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(with-cost-center&nbsp;<i>timed?</i>&nbsp;<i>cost-center</i>&nbsp;<i>thunk</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>thunk</i></tt> must be a procedure that accepts zero arguments.
<tt>with-cost-center</tt> invokes <tt><i>thunk</i></tt> without arguments and
returns its values.
It also tracks, dynamically, the bytes allocated, instructions executed,
and cpu time elapsed while evaluating the invocation of <tt><i>thunk</i></tt> and
adds the tracked costs to the cost center's running record of these costs.

<p>
As described above, allocation counts are tracked only for code
compiled with the parameter <tt>generate-allocation-counts</tt> set
to true, and instruction counts are tracked only for code compiled
with <tt>generate-instruction-counts</tt> set to true.
Cpu time is tracked only if <tt><i>timed?</i></tt> is provided and not false and
includes cpu time spent in instrumented, uninstrumented, and non-Scheme
code.

<p>
<a name="./system:s244"></a><span class=formdef><b>procedure</b>: <tt>(cost-center-instruction-count&nbsp;<i>cost-center</i>)</tt></span>
<br>
<b>returns: </b>the number of instructions tracked by <tt><i>cost-center</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./system:s245"></a><span class=formdef><b>procedure</b>: <tt>(cost-center-allocation-count&nbsp;<i>cost-center</i>)</tt></span>
<br>
<b>returns: </b>the number of allocated bytes tracked by <tt><i>cost-center</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./system:s246"></a><span class=formdef><b>procedure</b>: <tt>(cost-center-time&nbsp;<i>cost-center</i>)</tt></span>
<br>
<b>returns: </b>the cpu time tracked by <tt><i>cost-center</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The cpu time is returned as a time object with time-type <tt>time-duration</tt>.

<p>
<a name="./system:s247"></a><span class=formdef><b>procedure</b>: <tt>(reset-cost-center!&nbsp;<i>cost-center</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure resets the costs recorded by <tt><i>cost-center</i></tt> to zero.


<p>

<h3><a name="g124"></a><a name="./system:h13"></a>Section 12.13. Parameters<a name="SECTPARAMETERS"></a></h3>



<p>
This section describes mechanisms for creating and manipulating parameters.
New parameters may be created conveniently with <tt>make-parameter</tt>.
Nothing distinguishes parameters from other
procedures, however, except for their behavior.
If more complicated actions must be taken when a parameter is invoked
than can be accommodated easily through the <tt>make-parameter</tt> mechanism,
the parameter may be defined directly with <tt>case-lambda</tt>.


<p>
<a name="./system:s248"></a><span class=formdef><b>procedure</b>: <tt>(make-parameter&nbsp;<i>object</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-parameter&nbsp;<i>object</i>&nbsp;<i>procedure</i>)</tt></span>
<br>
<b>returns: </b>a parameter (procedure)
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>make-parameter</tt> accepts one or two arguments.
The first argument is the initial value of the internal variable, and
the second, if present, is a <i>filter</i> applied to the initial value
and all subsequent values.
The filter should accept one argument.
If the value is not appropriate, the filter should raise an exception or
convert the value into a more appropriate form.

<p>
For example, the default value of <tt>print-length</tt> is defined as
follows:

<p>

<p><tt>(define&nbsp;print-length<br>

&nbsp;&nbsp;(make-parameter<br>

&nbsp;&nbsp;&nbsp;&nbsp;#f<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(or&nbsp;(not&nbsp;x)&nbsp;(and&nbsp;(fixnum?&nbsp;x)&nbsp;(fx&gt;=&nbsp;x&nbsp;0)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violationf&nbsp;'print-length<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"~s&nbsp;is&nbsp;not&nbsp;a&nbsp;positive&nbsp;fixnum&nbsp;or&nbsp;#f"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x)))</tt>
<p>
<p><tt>(print-length)&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(print-length&nbsp;3)<br>

(print-length)&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(format&nbsp;"~s"&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6))&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"(1&nbsp;2&nbsp;3&nbsp;...)"<br>

(print-length&nbsp;#f)<br>

(format&nbsp;"~s"&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6))&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6)"</tt>
<p>The definition of <tt>make-parameter</tt> is straightforward using
<a name="./system:s249"></a><tt>case-lambda</tt>:

<p>

<p><tt>(define&nbsp;make-parameter<br>

&nbsp;&nbsp;(case-lambda<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(init&nbsp;guard)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([v&nbsp;(guard&nbsp;init)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(case-lambda<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[()&nbsp;v]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(u)&nbsp;(set!&nbsp;v&nbsp;(guard&nbsp;u))]))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(init)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-parameter&nbsp;init&nbsp;(lambda&nbsp;(x)&nbsp;x))]))</tt>
<p>In threaded versions of <i>Chez&nbsp;Scheme</i>, <tt>make-parameter</tt> creates
global parameters.
The procedure <tt>make-thread-parameter</tt>, described in
Section&nbsp;<a href="./threads.html#g144">15.7</a>, may be used to make thread
parameters.


<p>
<a name="./system:s250"></a><span class=formdef><b>syntax</b>: <tt>(parameterize&nbsp;((<i>param</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the values of the body <tt><i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Using the syntactic form <tt>parameterize</tt>, the values of parameters can
be changed in a manner analogous to <tt>fluid-let</tt> for ordinary variables.
Each <tt><i>param</i></tt> is set to the value of the corresponding
<tt><i>expr</i></tt> while the body is evaluated.
When control leaves the body by normal return or by the invocation of a
continuation created outside of the body, the parameters are restored to
their original values.
If control returns to the body via a continuation created during the
execution of the body, the parameters are again set to their temporary
values.

<p>

<p><tt>(define&nbsp;test<br>

&nbsp;&nbsp;(make-parameter&nbsp;0))<br>

(test)&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(test&nbsp;1)<br>

(test)&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(parameterize&nbsp;([test&nbsp;2])<br>

&nbsp;&nbsp;(test))&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2<br>

(test)&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(parameterize&nbsp;([test&nbsp;2])<br>

&nbsp;&nbsp;(test&nbsp;3)<br>

&nbsp;&nbsp;(test))&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(test)&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(define&nbsp;k&nbsp;(lambda&nbsp;(x)&nbsp;x))<br>

(begin&nbsp;(set!&nbsp;k&nbsp;(call/cc&nbsp;k))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'k)&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;k<br>

(parameterize&nbsp;([test&nbsp;2])<br>

&nbsp;&nbsp;(test&nbsp;(call/cc&nbsp;k))<br>

&nbsp;&nbsp;(test))&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;k<br>

(test)&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(k&nbsp;3)&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(test)&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1</tt>
<p>The definition of <tt>parameterize</tt> is similar to the definition of
<tt>fluid-let</tt> (page&nbsp;<a href="./binding.html#defn:fluid-let">117</a>):

<p>

<p><tt>(define-syntax&nbsp;parameterize<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;()&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;#'(begin&nbsp;b1&nbsp;b2&nbsp;...)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((x&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([(p&nbsp;...)&nbsp;(generate-temporaries&nbsp;#'(x&nbsp;...))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(y&nbsp;...)&nbsp;(generate-temporaries&nbsp;#'(x&nbsp;...))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(let&nbsp;([p&nbsp;x]&nbsp;...&nbsp;[y&nbsp;e]&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([swap&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([t&nbsp;(p)])&nbsp;(p&nbsp;y)&nbsp;(set!&nbsp;y&nbsp;t))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dynamic-wind&nbsp;swap&nbsp;(lambda&nbsp;()&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;swap))))])))</tt>
<p>
<h3><a name="g125"></a><a name="./system:h14"></a>Section 12.14. Virtual registers<a name="SECTVIRTUALREGISTERS"></a></h3>



<p>
A limited set of <i>virtual registers</i> is supported by the compiler
for use by programs that require high-speed, global, and mutable storage
locations.
Referencing or assigning a virtual register is potentially faster and
never slower than accessing an assignable local or global variable,
and the code sequences for doing so are generally smaller.
Assignment is potentially significantly faster because there is no need
to track pointers from the virtual registers to young objects, as there
is for variable locations that might reside in older generations.
On threaded versions of the system, virtual registers are "per thread"
and thus serve as thread-local storage in a manner that is less expensive
than thread parameters.

<p>
The interface consists of three procedures: <tt>virtual-register-count</tt>,
which returns the number of virtual registers, <tt>set-virtual-register!</tt>,
which sets the value of a specified virtual register, and
<tt>virtual-register</tt>, which retrieves the value of a specified
virtual register.

<p>
A virtual register is specified by a nonnegative fixnum index less than
the number of virtual registers.
To get optimal performance for <tt>set-virtual-register!</tt>
and <tt>virtual-register</tt>, the index should be a constant
embedded right in the call (or propagatable via optimization to the
call).
To avoid putting these constants in the source code, programmers should
consider using identifier macros to give names to virtual registers, e.g.:

<p>

<p><tt>(define-syntax&nbsp;current-state<br>

&nbsp;&nbsp;(identifier-syntax<br>

&nbsp;&nbsp;&nbsp;&nbsp;[id&nbsp;(virtual-register&nbsp;0)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(set!&nbsp;id&nbsp;e)&nbsp;(set-virtual-register!&nbsp;0&nbsp;e)]))<br>

(set!&nbsp;current-state&nbsp;'start)<br>

current-state&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;start</tt>
<p>A more elaborate macro could dole out indices at compile time and complain
when no more indices are available.

<p>
Virtual-registers must be treated as an application-level resource, i.e.,
libraries intended to be used by multiple applications should generally
not use virtual registers to avoid conflicts with an application's use of
the registers.


<p>
<a name="./system:s251"></a><span class=formdef><b>procedure</b>: <tt>(virtual-register-count)</tt></span>
<br>
<b>returns: </b>the number of virtual registers
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>As of Version&nbsp;9.0, the number of virtual registers is set at 16.
It cannot be changed except by recompiling <i>Chez&nbsp;Scheme</i> from
source.

<p>
<a name="./system:s252"></a><span class=formdef><b>procedure</b>: <tt>(set-virtual-register!&nbsp;<i>k</i>&nbsp;<i>x</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>set-virtual-register!</tt> stores <tt><i>x</i></tt> in virtual register <tt><i>k</i></tt>.
<tt><i>k</i></tt> must be a nonnegative fixnum less than the value of
<tt>(virtual-register-count)</tt>.

<p>
<a name="./system:s253"></a><span class=formdef><b>procedure</b>: <tt>(virtual-register&nbsp;<i>k</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>virtual-register</tt> returns the value most recently
stored in virtual register <tt><i>k</i></tt> (on the current thread, in
threaded versions of the system).


<p>

<h3><a name="g126"></a><a name="./system:h15"></a>Section 12.15. Environmental Queries and Settings<a name="SECTSYSTEMENV"></a></h3>



<p>
<a name="./system:s254"></a><span class=formdef><b>procedure</b>: <tt>(scheme-version)</tt></span>
<br>
<b>returns: </b>a version string
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The version string is in the form

<p>

<p><tt>"Chez&nbsp;Scheme&nbsp;Version&nbsp;<i>version</i>"</tt>
<p>for <i>Chez&nbsp;Scheme</i>, and

<p>

<p><tt>"Petite&nbsp;Chez&nbsp;Scheme&nbsp;Version&nbsp;<i>version</i>"</tt>
<p>for <i>Petite&nbsp;Chez&nbsp;Scheme</i>.

<p>
<a name="./system:s255"></a><span class=formdef><b>procedure</b>: <tt>(scheme-version-number)</tt></span>
<br>
<b>returns: </b>three values: the major, minor, and sub-minor version numbers
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Each of the three return values is a nonnegative fixnum.

<p>
In <i>Chez&nbsp;Scheme</i> Version 7.9.4:

<p>

<p><tt>(scheme-version-number)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;7<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;9<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;4</tt>
<p><a name="./system:s256"></a><span class=formdef><b>procedure</b>: <tt>(petite?)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if called in <i>Petite&nbsp;Chez&nbsp;Scheme</i>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The only difference between <i>Petite&nbsp;Chez&nbsp;Scheme</i> and <i>Chez&nbsp;Scheme</i> is that
the compiler is not available in the former, so this predicate can serve as
a way to determine if the compiler is available.


<p>
<a name="./system:s257"></a><span class=formdef><b>procedure</b>: <tt>(threaded?)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if called in a threaded version of the system, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./system:s258"></a><span class=formdef><b>procedure</b>: <tt>(interactive?)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if system is run interactively, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This predicate returns <tt>#t</tt> if the Scheme process's
stdin and stdout are connected to a tty (Unix-based systems) or console
(Windows).
Otherwise, it returns <tt>#f</tt>.


<p>
<a name="./system:s259"></a><span class=formdef><b>procedure</b>: <tt>(get-process-id)</tt></span>
<br>
<b>returns: </b>the operating system process id of the current process
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./system:s260"></a><span class=formdef><b>procedure</b>: <tt>(getenv&nbsp;<i>key</i>)</tt></span>
<br>
<b>returns: </b>environment value of <tt><i>key</i></tt> or <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>key</i></tt> must be a string.
<tt>getenv</tt> returns the operating system shell's environment value
associated with <tt><i>key</i></tt>, or <tt>#f</tt> if no environment value
is associated with <tt><i>key</i></tt>.

<p>

<p><tt>(getenv&nbsp;"HOME")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"/u/freddy"</tt>
<p><a name="./system:s261"></a><span class=formdef><b>procedure</b>: <tt>(putenv&nbsp;<i>key</i>&nbsp;<i>value</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>key</i></tt> and <tt><i>value</i></tt> must be strings.

<p>
<tt>putenv</tt> stores the <tt><i>key</i></tt>, <tt><i>value</i></tt> pair in the
environment of the process,
where it is available to the current process (e.g., via <tt><i>getenv</i></tt>)
and any spawned processes.

<p>

<p><tt>(putenv&nbsp;"SCHEME"&nbsp;"rocks!")<br>

(getenv&nbsp;"SCHEME")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"rocks!"</tt>
<p><a name="./system:s262"></a><span class=formdef><b>procedure</b>: <tt>(get-registry&nbsp;<i>key</i>)</tt></span>
<br>
<b>returns: </b>registry value of <tt><i>key</i></tt> or <tt>#f</tt>
<br><span class=formdef><b>procedure</b>: <tt>(put-registry!&nbsp;<i>key</i>&nbsp;<i>val</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(remove-registry!&nbsp;<i>key</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>key</i></tt> and <tt><i>val</i></tt> must be strings.

<p>
<tt>get-registry</tt> returns a string containing the registry
value of <tt><i>key</i></tt> if the value exists.
If no registry value for <tt><i>key</i></tt> exists, <tt>get-registry</tt> returns
<tt>#f</tt>.

<p>
<tt>put-registry!</tt> sets the registry
value of <tt><i>key</i></tt> to <tt><i>val</i></tt>.
It raises an exception with condition type <tt>&amp;assertion</tt> if the
value cannot be set, which may happen if
the user has insufficient access.

<p>
<tt>remove-registry!</tt> removes the registry
key or value named by <tt><i>key</i></tt>.
It raises an exception with condition type <tt>&amp;assertion</tt> if the
value cannot be removed.
Reasons for failure include the key not being present, the user having
insufficient access, or <tt><i>key</i></tt> being a key with subkeys.

<p>
These routines are defined for Windows only.

<p>

<p><tt>(get-registry&nbsp;"hkey_local_machine\\Software\\North\\South")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(put-registry!&nbsp;"hkey_local_machine\\Software\\North\\South"&nbsp;"east")<br>

(get-registry&nbsp;"hkey_local_machine\\Software\\North\\South")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"east"<br>

(remove-registry!&nbsp;"hkey_local_machine\\Software\\North")<br>

(get-registry&nbsp;"hkey_local_machine\\Software\\North\\South")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>
<h3><a name="g127"></a><a name="./system:h16"></a>Section 12.16. Subset Modes<a name="SECTMISCSUBSETMODE"></a></h3>



<p>
<a name="./system:s263"></a><span class=formdef><b>thread parameter</b>: <tt>subset-mode</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of this parameter
must be <tt>#f</tt> (the default) or the symbol <tt>system</tt>.
Setting <tt>subset-mode</tt> to <tt>system</tt> allows the manipulation
of various undocumented system variables, data structures, and
settings.
It is typically used only for system debugging.




<hr class=copyright align=left>
<p>
<a class=plain href="index.html">Chez Scheme Version 9 User's Guide</a><br>
Copyright &copy; 2022 Cisco Systems, Inc.<br>
Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License Version 2.0</a>
(<a class=plain href="canned/copyright.html">full copyright notice.</a>).</br>
Revised April 2022 for Chez Scheme Version 9.5.8<br>
<a class=plain href="canned/about.html">about this book</a>
</tr></table>
</body>
</html>
