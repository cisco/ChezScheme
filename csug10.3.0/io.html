<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Input/Output Operations</title>
<link href="csug.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g77"></a>
<a name="./io:h0"></a>

<h1>Chapter 9. Input/Output Operations<a name="CHPTIO"></a></h1>





<p>
This chapter describes <i>Chez&nbsp;Scheme</i>'s generic port facility,
operations on ports, and various <i>Chez&nbsp;Scheme</i> extensions to the
standard set of input/output operations.
See Chapter&nbsp;<a href="http://scheme.com/tspl4/./io.html#g121">7</a> of <i>The Scheme Programming Language, 4th Edition</i> or the Revised<sup>6</sup> Report
on Scheme for a description of standard input/output operations.
Definitions of a few sample generic ports are given in
Section&nbsp;<a href="./io.html#g94">9.17</a>.

<p>
<i>Chez&nbsp;Scheme</i> closes file ports automatically after they become
inaccessible to the program or when the Scheme program exits, but it is
best to close ports explicitly whenever possible.


<p>

<h3><a name="g78"></a><a name="./io:h1"></a>Section 9.1. Generic Ports</h3>



<p>
<i>Chez&nbsp;Scheme</i>'s "<a name="./io:s0"></a>generic port" facility
allows the programmer to add new types of textual ports with
arbitrary input/output semantics.
It may be used, for example, to define any of the built-in
Common Lisp&nbsp;[<a class=citation href="./bibliography.html#g190">30</a>] stream types, i.e.,
<a name="./io:s1"></a>synonym streams,
<a name="./io:s2"></a>broadcast streams,
<a name="./io:s3"></a>concatenated streams,
<a name="./io:s4"></a>two-way streams,
<a name="./io:s5"></a>echo streams, and
<a name="./io:s6"></a>string streams.
It may also be used to define more exotic ports, such as ports that
represent windows on a bit-mapped display or ports that represent
processes connected to the current process via pipes or sockets.

<p>
Each port has an associated <i>port handler</i>.
A port handler is a procedure that accepts messages in an
object-oriented style.
Each message corresponds to one of the low-level Scheme operations
on ports, such as <tt>read-char</tt> and <tt>close-input-port</tt> (but not
<tt>read</tt>, which is defined in terms of the lower-level operations).
Most of these operations simply call the handler immediately with
the corresponding message.

<p>
Standard messages adhere to the following conventions: the message name is
the first argument to the handler.
It is always a symbol, and it is always the name of a primitive
Scheme operation on ports.
The additional arguments are the same as the arguments to the
primitive procedure and occur in the same order.
(The port argument to some of the primitive procedures is optional;
in the case of the messages passed to a handler, the port argument
is always supplied.)
The following messages are defined for built-in ports:

<p>

<p><tt>block-read&nbsp;<i>port</i>&nbsp;<i>string</i>&nbsp;<i>count</i><br>

block-write&nbsp;<i>port</i>&nbsp;<i>string</i>&nbsp;<i>count</i><br>

char-ready?&nbsp;<i>port</i><br>

clear-input-port&nbsp;<i>port</i><br>

clear-output-port&nbsp;<i>port</i><br>

close-port&nbsp;<i>port</i><br>

file-position&nbsp;<i>port</i><br>

file-position&nbsp;<i>port</i>&nbsp;<i>position</i><br>

file-length&nbsp;<i>port</i><br>

flush-output-port&nbsp;<i>port</i><br>

peek-char&nbsp;<i>port</i><br>

port-name&nbsp;<i>port</i><br>

read-char&nbsp;<i>port</i><br>

unread-char&nbsp;<i>char</i>&nbsp;<i>port</i><br>

write-char&nbsp;<i>char</i>&nbsp;<i>port</i></tt>
<p>Additional messages may be accepted by user-defined ports.

<p>
<i>Chez&nbsp;Scheme</i> input and output is normally buffered for efficiency.
To support buffering, each input port contains an input buffer and
each output port contains an output buffer.
Bidirectional ports, ports that are both input ports and output
ports, contain both input and output buffers.
Input is not buffered if the input buffer is the empty string,
and output is not buffered if the output buffer is the empty
string.
In the case of unbuffered input and output, calls to <tt>read-char</tt>,
<tt>write-char</tt>, and similar messages cause the handler to be invoked
immediately with the corresponding message.
For buffered input and output, calls to these procedures cause the
buffer to be updated, and the handler is not called under normal
circumstances until the buffer becomes empty (for input) or full (for
output).
Handlers for buffered ports must <tt><i>not</i></tt> count
on the buffer being empty or full when <tt>read-char</tt>, <tt>write-char</tt>, and
similar messages are received, however, due to the possibility that (a)
the handler is invoked through some other mechanism, or (b) the
call to the handler is interrupted.

<p>
In the presence of keyboard, timer, and other interrupts, it is
possible for a call to a port handler to be interrupted or for the
handler itself to be interrupted.
If the port is accessible outside of the interrupted code, there
is a possibility that the interrupt handler will cause input or
output to be performed on the port.
This is one reason, as stated above, that port handlers must not count
on the input buffer being empty or output buffer being full when a
<tt>read-char</tt>, <tt>write-char</tt>, or similar message is received.
In addition, port handlers may need to manipulate the buffers only
with interrupts disabled (using <tt>with-interrupts-disabled</tt>).

<p>
Generic ports are created via one of the port construction
procedures <tt>make-input-port</tt>, 
<tt>make-output-port</tt>, and <tt>make-input/output-port</tt> defined
later in this chapter.
Ports have seven accessible fields:

<p>
<dl compact>
<dt><tt><i>handler</i></tt>,<dd> accessed with <tt>port-handler</tt>;
<dt><tt><i>output-buffer</i></tt>,<dd> accessed with <tt>port-output-buffer</tt>,
<dt><tt><i>output-size</i></tt>,<dd> accessed with <tt>port-output-size</tt>,
<dt><tt><i>output-index</i></tt>,<dd> accessed with <tt>port-output-index</tt>,
<dt><tt><i>input-buffer</i></tt>,<dd> accessed with <tt>port-input-buffer</tt>,
<dt><tt><i>input-size</i></tt>,<dd> accessed with <tt>port-input-size</tt>, and
<dt><tt><i>input-index</i></tt>,<dd> accessed with <tt>port-input-index</tt>.
</dl>

<p>
The output-size and output-index fields are valid only for output
ports, and the input-size and input-index fields are valid only for
input ports.
The output and input size and index fields may be updated as well
using the corresponding "<tt>set-<i>field</i>!</tt>" procedure.

<p>
A port's output size determines how much of the port's output buffer is
actually available for writing by <tt>write-char</tt>.
The output size is often the same as the string length of the port's
output buffer, but it can be set to less (but no less than zero) at the
discretion of the programmer.
The output index determines to which position in the port's
buffer the next character will be written.
The output index should be between 0 and the output size,
inclusive.
If no output has occurred since the buffer was last flushed, the
output index should be 0.
If the index is less than the size, <tt>write-char</tt>
stores its character argument into the specified character
position within the buffer and increments the index.
If the index is equal to the size, <tt>write-char</tt> leaves the fields of
the port unchanged and invokes the handler.

<p>
A port's input size determines how much of the port's input buffer is
actually available for reading by <tt>read-char</tt>.
A port's input size and input index are constrained in the same manner
as output size and index, i.e., the input size must be between
0 and the string length of the input buffer (inclusive), and the input
index must be between 0 and the input size (inclusive).
Often, the input size is less than the length of the input buffer
because there are fewer characters available to read than would fit
in the buffer.
The input index determines from which position in the input buffer the
next character will be read.
If the index is less than the size, <tt>read-char</tt> extracts the character
in this position, increments the index, and returns the character.
If the index is equal to the size, <tt>read-char</tt> leaves the fields of
the port unchanged and invokes the handler.

<p>
The operation of <tt>peek-char</tt> is similar to that of <tt>read-char</tt>, except
that it does not increment the input index.
<tt>unread-char</tt> decrements the input index if it is greater than 0,
otherwise it invokes the handler.
<tt>char-ready?</tt> returns <tt>#t</tt> if the input index is less than the input
size, otherwise it invokes the handler.

<p>
Although the fields shown and discussed above are logically present in
a port, actual implementation details may differ.
The current <i>Chez&nbsp;Scheme</i> implementation uses a different representation
that allows <tt>read-char</tt>, <tt>write-char</tt>, and similar operations to be
open-coded with minimal overhead.
The access and assignment operators perform the conversion between the
actual representation and the one shown above.

<p>
Port handlers receiving a message must return a value appropriate for
the corresponding operation.
For example, a handler receiving a <tt>read-char</tt> message must return a
character or eof object (if it returns).
For operations that return unspecified values, such as <tt>close-port</tt>,
the handler is not required to return any particular value.

<p>

<h3><a name="g79"></a><a name="./io:h2"></a>Section 9.2. File Options<a name="SECTFILEOPTIONS"></a></h3>



<p>
The Revised<sup>6</sup> Report requires that the universe of a file-options
enumeration set must include <tt>no-create</tt>, <tt>no-fail</tt>,
and <tt>no-truncate</tt>, whose meanings are described within the
description of the <tt>file-options</tt> syntax in
Section&nbsp;<a href="http://scheme.com/tspl4/./io.html#g123">7.2</a> of <i>The Scheme Programming Language, 4th Edition</i>.
<i>Chez&nbsp;Scheme</i> defines a number of additional file options:

<p>
<dl compact>
<dt><tt><i>compressed</i></tt>:<dd>
An output file should be compressed when written; and a compressed input
file should be decompressed when read. The compression format for output
is determined by the <a name="./io:s7"></a><tt>compress-format</tt>
parameter, while the compression format on input is inferred.
The compression level, which is relevant only for output, is determined
by the <a name="./io:s8"></a><tt>compress-level</tt> parameter.

<p>
<dt><tt><i>replace</i></tt>:<dd>
For output files only, replace (remove and recreate) the existing file if
it exists.

<p>
<dt><tt><i>exclusive</i></tt>:<dd>
For output files only, lock the file for exclusive access.
On some systems the lock is advisory, i.e., it inhibits access by 
other processes only if they also attempt to open exclusively.

<p>
<dt><tt><i>append</i></tt>:<dd>
For output files only, position the output port at the end of the file
before each write so that output to the port is always appended to the
file.

<p>
<dt><tt><i>perm-set-user-id</i></tt>:<dd>
For newly created output files under Unix-based systems only, set
user-id bit.

<p>
<dt><tt><i>perm-set-group-id</i></tt>:<dd>
For newly created output files under Unix-based systems only, set
group-id bit.

<p>
<dt><tt><i>perm-sticky</i></tt>:<dd>
For newly created output files under Unix-based systems only, set
sticky bit.

<p>
<dt><tt><i>perm-no-user-read</i></tt>:<dd>
For newly created output files under Unix-based systems only,
do not set user read bit.
(User read bit is set by default, unless masked by the process umask.)

<p>
<dt><tt><i>perm-no-user-write</i></tt>:<dd>
For newly created output files under Unix-based systems only,
do not set user write bit.
(User write bit is set by default, unless masked by the process umask.)

<p>
<dt><tt><i>perm-user-execute</i></tt>:<dd>
For newly created output files under Unix-based systems only,
set user execute bit unless masked by process umask.
(User execute bit is not set by default.)

<p>
<dt><tt><i>perm-no-group-read</i></tt>:<dd>
For newly created output files under Unix-based systems only,
do not set group read bit.
(Group read bit is set by default, unless masked by the process umask.)

<p>
<dt><tt><i>perm-no-group-write</i></tt>:<dd>
For newly created output files under Unix-based systems only,
do not set group write bit.
(Group write bit is set by default, unless masked by the process umask.)

<p>
<dt><tt><i>perm-group-execute</i></tt>:<dd>
For newly created output files under Unix-based systems only,
set group execute bit unless masked by process umask.
(Group execute bit is not set by default.)

<p>
<dt><tt><i>perm-no-other-read</i></tt>:<dd>
For newly created output files under Unix-based systems only,
do not set other read bit.
(Other read bit is set by default, unless masked by the process umask.)

<p>
<dt><tt><i>perm-no-other-write</i></tt>:<dd>
For newly created output files under Unix-based systems only,
do not set other write bit.
(Other write bit is set by default, unless masked by the process umask.)

<p>
<dt><tt><i>perm-other-execute</i></tt>:<dd>
For newly created output files under Unix-based systems only,
set other execute bit unless masked by process umask.
(Other execute bit is not set by default.)
</dl>

<p>

<h3><a name="g80"></a><a name="./io:h3"></a>Section 9.3. Transcoders<a name="SECTTRANSCODERS"></a></h3>



<p>
The language of the Revised<sup>6</sup> Report provides three built-in codecs:
a latin-1 codec, a utf-8 codec, and a utf-16 codec.
<i>Chez&nbsp;Scheme</i> provides three additional codecs: a utf-16le codec,
utf-16be codec, and an "iconv" codec for non-Unicode character sets.
It also provides an alternative to the standard utf-16 codec that
defaults to little-endian format rather than the default big-endian
format.
This section describes these codecs, plus a <tt>current-transcoder</tt>
parameter that allows the programmer to determine the transcoder
used for a textual port whenever the transcoder is implicit, as for
<tt>open-input-file</tt> or <tt>load</tt>, along with the
predicate <tt>transcoder?</tt>, which should be standard but is not.

<p>
<a name="./io:s9"></a><span class=formdef><b>procedure</b>: <tt>(utf-16-codec)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(utf-16-codec&nbsp;<i>endianness</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(utf-16le-codec)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(utf-16be-codec)</tt></span>
<br>
<b>returns: </b>a codec
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>endianness</i></tt> must be the symbol <tt>big</tt> or the symbol
<tt>little</tt>.

<p>
The codec returned by <tt>utf-16-codec</tt> can be used to create and
process data written UTF-16 format.
When called without the <tt><i>endianness</i></tt> argument or with <tt><i>endianness</i></tt>
<tt>big</tt>, <tt>utf-16-codec</tt> returns a codec for standard UTF-16
data, i.e., one that defaults to big-endian format if no byte-order mark
(BOM) is found.

<p>
When output is transcoded with a transcoder based on this codec, a BOM is
emitted just before the first character written, and each character is
written as a UTF-16 character in big-endian format.
For input, a BOM is looked for at the start of the
input and, if present, controls the byte order of the remaining
UTF-16 characters.
If no BOM is present, big-endian order is assumed.
For input-output ports, the BOM is not emitted if the file is
read before written, and a BOM is not looked for if the file is written
before read.

<p>
For textual ports created via <tt>transcoded-port</tt>, a BOM written or
read via the transcoder appears at the beginning of the underlying data
stream or file only if the binary port passed to <tt>transcoded-port</tt>
is positioned at the start of the data stream or file.
When the transcoder can determine this is the case, it sets a flag that
causes <tt>set-port-position!</tt> to position the port beyond the BOM if
an attempt is made to reposition the port to the start of the data stream
or file, so that the BOM is preserved.

<p>
When called with <tt><i>endianness</i></tt> <tt>little</tt>, <tt>utf-16-codec</tt>
returns a codec that defaults to the little-endian format both for reading
and for writing.
For output-only streams or input/output streams that are written before read,
the result is standard UTF-16, with a BOM that specifies little-endian
format followed by characters in little-endian byte order.
For input-only streams or input/output streams that are read before written,
this codec allows programs to read from input streams that either
begin with a BOM or are encoded in UTF-16LE format.
This is particularly useful for handling files that might have been
produced by older Windows applications that claim to produce UTF-16 files
but actually produce UTF-16LE files.

<p>
The Revised<sup>6</sup> Report version of <tt>utf-16-codec</tt> lacks the
optional <tt><i>endianness</i></tt> argument.

<p>
The codecs returned by <tt>utf-16le-codec</tt> and <tt>utf-16be-codec</tt>
are used to read and write data in the UTF-16LE and UTF-16BE formats,
i.e., UTF-16 with little-endian or big-endian byte order and no BOM.
For output, these codecs are useful for controlling whether and where
the BOM is emitted, since no BOM is emitted implicitly and a BOM
can be emitted explicitly as an ordinary character.
For input, these codecs are useful for processing files known to be
in little-endian or big-endian format with no BOM.


<p>
<a name="./io:s10"></a><span class=formdef><b>procedure</b>: <tt>(iconv-codec&nbsp;<i>code-page</i>)</tt></span>
<br>
<b>returns: </b>a codec
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>code-page</i></tt> must be a string and should identify a codec accepted by
the <tt>iconv</tt> library installed on the target machine.
The codec returned by this procedure can be used to convert from the
non-Unicode single- and multiple-byte character sets supported by
<tt>iconv</tt>.
When used in the input direction, the codec converts byte sequences
into Scheme strings, and when used in the output direction, it converts
Scheme strings to byte sequences.

<p>
The set of supported code pages depends on the version of
<tt>iconv</tt> available; consult the <tt>iconv</tt> documentation
or use the shell command <tt>iconv&nbsp;--list</tt> to obtain a list
of supported code pages.

<p>
While the Windows operating system does not supply an <tt>iconv</tt>
library, it is possible to use <tt>iconv-codec</tt> on Windows systems by
supplying an <tt>iconv</tt> dynamic-link library (named <tt>iconv.dll</tt>,
<tt>libiconv.dll</tt>, or <tt>libiconv-2.dll</tt>) that provides
Posix-conformant <tt>iconv_open</tt>, <tt>iconv</tt>, and
<tt>iconv_close</tt> entry points either under those names or under the
alternative names <tt>libiconv_open</tt>, <tt>libiconv</tt>, and
<tt>libiconv_close</tt>.
The dll must be located in a standard location for dlls or in the
current directory of the process the first time <tt>iconv-codec</tt>
is called.

<p>
<a name="./io:s11"></a><span class=formdef><b>thread parameter</b>: <tt>current-transcoder</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The transcoder value of the <tt>current-transcoder</tt> parameter is used
whenever a textual file is opened with an implicit transcoder, e.g., by
<tt>open-input-file</tt> and other convenience I/O procedures,
<tt>compile-file</tt> <tt>include</tt>, <tt>load</tt>, and
<tt>pretty-file</tt>.
Its initial value is the value of the <tt>native-transcoder</tt> procedure.


<p>
<a name="./io:s12"></a><span class=formdef><b>procedure</b>: <tt>(transcoder?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a transcoder, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./io:s13"></a><span class=formdef><b>thread parameter</b>: <tt>transcoded-port-buffer-size</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>transcoded-port-buffer-size</tt> is a parameter that specifies the size
of the string buffer that is allocated when creating a new transcoded port.
The value of this parameter must be a positive fixnum.
When transcoding a binary input port that implements <tt>port-position</tt>,
a transcoded input port maintains an fxvector the same size as
its string buffer to support <tt>port-position</tt> on the transcoded port.

<p>
<a name="./io:s14"></a><span class=formdef><b>thread parameter</b>: <tt>make-codec-buffer</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of <tt>make-codec-buffer</tt> must be a procedure.
The procedure is invoked with the binary port <tt><i>bp</i></tt> when
<tt>transcoded-port</tt> is called with a buffered port <tt><i>bp</i></tt>.
The procedure must return a mutable bytevector of length at least four.
The behavior of <tt>transcoded-port</tt> and its callers is unspecified if a
continuation captured within the <tt>make-codec-buffer</tt> procedure is invoked
multiple times.

<p>

<h3><a name="g81"></a><a name="./io:h4"></a>Section 9.4. Port Operations<a name="SECTPORTOPERATIONS"></a></h3>



<p>
The procedures used to create, access, and alter ports directly
are described in this section.
Also described are several nonstandard operations on ports.

<p>
Unless otherwise specified, procedures requiring either input ports or
output ports as arguments accept input/output ports as well, i.e., an
input/output port is both an input port and an output port.

<p>
<a name="./io:s15"></a><span class=formdef><b>procedure</b>: <tt>(make-input-port&nbsp;<i>handler</i>&nbsp;<i>input-buffer</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-output-port&nbsp;<i>handler</i>&nbsp;<i>output-buffer</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-input/output-port&nbsp;<i>handler</i>&nbsp;<i>input-buffer</i>&nbsp;<i>output-buffer</i>)</tt></span>
<br>
<b>returns: </b>a new textual port
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>handler</i></tt> must be a procedure, and
<tt><i>input-buffer</i></tt> and <tt><i>output-buffer</i></tt> must be strings.
Each procedure creates a <a name="./io:s16"></a>generic port.
The handler associated with the port is <tt><i>handler</i></tt>, the
input buffer is <tt><i>input-buffer</i></tt>, and the
output buffer is <tt><i>output-buffer</i></tt>.
For <tt>make-input-port</tt>, the output buffer is undefined, and for
<tt>make-output-port</tt>, the input buffer is undefined.

<p>
The input size of an input or input/output port is initialized to the
string length of the input buffer, and the input index is set to 0.
The output size and index of an output or input/output port are
initialized similarly.

<p>
The length of an input or output buffer may be zero, in which case
buffering is effectively disabled.

<p>
<a name="./io:s17"></a><span class=formdef><b>procedure</b>: <tt>(port-handler&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b>a procedure
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>For generic ports, <tt>port-handler</tt> returns the handler passed to one
of the generic port creation procedures described above.
For ports created by <tt>open-input-file</tt> and similar procedures,
<tt>port-handler</tt> returns an internal handler that may be invoked in
the same manner as any other handler.

<p>
<a name="./io:s18"></a><span class=formdef><b>procedure</b>: <tt>(port-input-buffer&nbsp;<i>input-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(port-input-size&nbsp;<i>input-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(port-input-index&nbsp;<i>input-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(textual-port-input-buffer&nbsp;<i>textual-input-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(textual-port-input-size&nbsp;<i>textual-input-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(textual-port-input-index&nbsp;<i>textual-input-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(binary-port-input-buffer&nbsp;<i>binary-input-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(binary-port-input-size&nbsp;<i>binary-input-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(binary-port-input-index&nbsp;<i>binary-input-port</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These procedures return the input buffer, size, or index
of the input port.
The variants specialized to textual or binary ports are slightly
more efficient than their generic counterparts.


<p>
<a name="./io:s19"></a><span class=formdef><b>procedure</b>: <tt>(set-port-input-index!&nbsp;<i>input-port</i>&nbsp;<i>n</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-port-input-size!&nbsp;<i>input-port</i>&nbsp;<i>n</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-port-input-buffer!&nbsp;<i>input-port</i>&nbsp;<i>x</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-textual-port-input-index!&nbsp;<i>textual-input-port</i>&nbsp;<i>n</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-textual-port-input-size!&nbsp;<i>textual-input-port</i>&nbsp;<i>n</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-textual-port-input-buffer!&nbsp;<i>textual-input-port</i>&nbsp;<i>string</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-binary-port-input-index!&nbsp;<i>binary-input-port</i>&nbsp;<i>n</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-binary-port-input-size!&nbsp;<i>binary-input-port</i>&nbsp;<i>n</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-binary-port-input-buffer!&nbsp;<i>binary-input-port</i>&nbsp;<i>bytevector</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The procedure <tt>set-port-input-index!</tt> sets the input index field of
<tt><i>input-port</i></tt> to <i>n</i>, which must be a nonnegative integer less than
or equal to the port's input size.

<p>
The procedure <tt>set-port-input-size!</tt> sets the input size field of
<tt><i>input-port</i></tt> to <i>n</i>, which must be a nonnegative integer less than
or equal to the string length of the port's input buffer.
It also sets the input index to 0.

<p>
The procedure <tt>set-port-input-buffer!</tt> sets the input buffer field of
<tt><i>input-port</i></tt> to <i>x</i>, which must be a string for textual ports and a
bytevector for binary ports.
It also sets the input size to the length of the string or bytevector
and the input index to 0.

<p>
The variants specialized to textual or binary ports are slightly
more efficient than their generic counterparts.

<p>
<a name="./io:s20"></a><span class=formdef><b>procedure</b>: <tt>(port-input-count&nbsp;<i>input-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(textual-port-input-count&nbsp;<i>textual-input-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(binary-port-input-count&nbsp;<i>binary-input-port</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These procedures return an exact integer representing the number of
characters or bytes left to be read from the port's input buffer, i.e.,
the difference between the buffer size and index.

<p>
The variants specialized to textual or binary ports are slightly
more efficient than their generic counterpart.

<p>
<a name="./io:s21"></a><span class=formdef><b>procedure</b>: <tt>(port-input-empty?&nbsp;<i>input-port</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the port's input buffer contains no more data, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure determines whether the port's input count is zero without
computing or returning the actual count.

<p>
<a name="./io:s22"></a><span class=formdef><b>procedure</b>: <tt>(port-output-buffer&nbsp;<i>output-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(port-output-size&nbsp;<i>output-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(port-output-index&nbsp;<i>output-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(textual-port-output-buffer&nbsp;<i>output-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(textual-port-output-size&nbsp;<i>output-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(textual-port-output-index&nbsp;<i>output-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(binary-port-output-buffer&nbsp;<i>output-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(binary-port-output-size&nbsp;<i>output-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(binary-port-output-index&nbsp;<i>output-port</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These procedures return the output buffer, size, or index
of the output port.
The variants specialized to textual or binary ports are slightly
more efficient than their generic counterparts.


<p>
<a name="./io:s23"></a><span class=formdef><b>procedure</b>: <tt>(set-port-output-index!&nbsp;<i>output-port</i>&nbsp;<i>n</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-port-output-size!&nbsp;<i>output-port</i>&nbsp;<i>n</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-port-output-buffer!&nbsp;<i>output-port</i>&nbsp;<i>x</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-textual-port-output-index!&nbsp;<i>textual-output-port</i>&nbsp;<i>n</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-textual-port-output-size!&nbsp;<i>textual-output-port</i>&nbsp;<i>n</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-textual-port-output-buffer!&nbsp;<i>textual-output-port</i>&nbsp;<i>string</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-binary-port-output-index!&nbsp;<i>output-port</i>&nbsp;<i>n</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-binary-port-output-size!&nbsp;<i>output-port</i>&nbsp;<i>n</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(set-binary-port-output-buffer!&nbsp;<i>binary-output-port</i>&nbsp;<i>bytevector</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The procedure <tt>set-port-output-index!</tt> sets the output index field of
the output port to <i>n</i>, which must be a nonnegative integer less than
or equal to the port's output size.

<p>
The procedure <tt>set-port-output-size!</tt> sets the output size field of
the output port to <i>n</i>, which must be a nonnegative integer less than
or equal to the string length of the port's output buffer.
It also sets the output index to 0.

<p>
The procedure <tt>set-port-output-buffer!</tt> sets the output buffer field of
<tt><i>output-port</i></tt> to <i>x</i>, which must be a string for textual ports and a
bytevector for binary ports.
It also sets the output size to the length of the string or bytevector
and the output index to 0.

<p>
The variants specialized to textual or binary ports are slightly
more efficient than their generic counterparts.

<p>
<a name="./io:s24"></a><span class=formdef><b>procedure</b>: <tt>(port-output-count&nbsp;<i>output-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(textual-port-output-count&nbsp;<i>textual-output-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(binary-port-output-count&nbsp;<i>binary-output-port</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These procedures return an exact integer representing the amount of
space in characters or bytes available to be written in the
port's output buffer, i.e., the difference between the buffer size
and index.

<p>
The variants specialized to textual or binary ports are slightly
more efficient than their generic counterpart.

<p>
<a name="./io:s25"></a><span class=formdef><b>procedure</b>: <tt>(port-output-full?&nbsp;<i>output-port</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the port's input buffer has no more room, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure determines whether the port's output count is zero without
computing or returning the actual count.

<p>
<a name="./io:s26"></a><span class=formdef><b>procedure</b>: <tt>(mark-port-closed!&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure directly marks the port closed so that no further
input or output operations are allowed on it.
It is typically used by handlers upon receipt of a <tt>close-port</tt>
message.

<p>
<a name="./io:s27"></a><span class=formdef><b>procedure</b>: <tt>(port-closed?&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>port</i></tt> is closed, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>(let&nbsp;([p&nbsp;(open-output-string)])<br>

&nbsp;&nbsp;(port-closed?&nbsp;p))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(let&nbsp;([p&nbsp;(open-output-string)])<br>

&nbsp;&nbsp;(close-port&nbsp;p)<br>

&nbsp;&nbsp;(port-closed?&nbsp;p))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./io:s28"></a><a name="desc:set-port-bol"></a>
<span class=formdef><b>procedure</b>: <tt>(set-port-bol!&nbsp;<i>output-port</i>&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When <tt><i>obj</i></tt> is <tt>#f</tt>, the port's beginning-of-line (BOL)
flag is cleared; otherwise, the port's BOL flag is set.

<p>
The BOL flag is consulted by <tt>fresh-line</tt>
(page&nbsp;<a href="./io.html#desc:fresh-line">274</a>) to determine if it needs to emit a
newline.
This flag is maintained automatically for file output ports, string output
ports, and transcript ports.
The flag is set for newly created file and string output ports, except
for file output ports created with the <tt>append</tt> option, for which
the flag is reset.
The BOL flag is clear for newly created generic ports and never set
automatically, but may be set explicitly using <tt>set-port-bol!</tt>.
The port is always flushed immediately before the flag is consulted, so it
need not be maintained on a per-character basis for buffered ports.

<p>
<a name="./io:s29"></a><span class=formdef><b>procedure</b>: <tt>(port-bol?&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>port</i></tt>'s BOL flag is set, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./io:s30"></a><span class=formdef><b>procedure</b>: <tt>(set-port-eof!&nbsp;<i>input-port</i>&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When <tt><i>obj</i></tt> is not <tt>#f</tt>, <tt>set-port-eof!</tt> marks <tt><i>input-port</i></tt>
so that, once its buffer is empty, the port is treated as if it were at
eof even if more data is available in the underlying byte or character
stream.
Once this artificial eof has been read, the eof mark is cleared, making
any additional data in the stream available beyond the eof.
This feature can be used by a generic port to simulate a stream consisting
of multiple input files.

<p>
When <tt><i>obj</i></tt> is <tt>#f</tt>, the eof mark is cleared.

<p>
The following example assumes /dev/zero provides an infinite stream of
zero bytes.

<p>

<p><tt>(define&nbsp;p<br>

&nbsp;&nbsp;(parameterize&nbsp;([file-buffer-size&nbsp;3])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(open-file-input-port&nbsp;"/dev/zero")))<br>

(set-port-eof!&nbsp;p&nbsp;#t)<br>

(get-u8&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#!eof<br>

(get-u8&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(set-port-eof!&nbsp;p&nbsp;#t)<br>

(get-u8&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(get-u8&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(get-u8&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#!eof<br>

(get-u8&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0</tt>
<p><a name="./io:s31"></a><span class=formdef><b>procedure</b>: <tt>(port-name&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b>the name associated with <tt><i>port</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The name may be any object but is usually a string or <tt>#f</tt>
(denoting no name).
For file ports, the name is typically a string naming the file.

<p>

<p><tt>(let&nbsp;([p&nbsp;(open-input-file&nbsp;"myfile.ss")])<br>

&nbsp;&nbsp;(port-name&nbsp;p))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"myfile.ss"
<br>
<br>
(let&nbsp;([p&nbsp;(open-output-string)])<br>

&nbsp;&nbsp;(port-name&nbsp;p))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"string"</tt>
<p><a name="./io:s32"></a><span class=formdef><b>procedure</b>: <tt>(set-port-name!&nbsp;<i>port</i>&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure sets <tt><i>port</i></tt>'s name to <tt><i>obj</i></tt>, which should be
a string or <tt>#f</tt> (denoting no name).


<p>
<a name="./io:s33"></a><span class=formdef><b>procedure</b>: <tt>(port-length&nbsp;<i>port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(file-length&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b>the length of the file or other object to which <tt><i>port</i></tt> refers
<br><span class=formdef><b>procedure</b>: <tt>(port-has-port-length?&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the port supports <tt>port-length</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A port may allow the length of the underlying stream of characters or bytes
to be determined.
If so, the procedure <tt>port-has-port-length?</tt> returns
<tt>#t</tt> and <tt>port-length</tt> returns the current length.
For binary ports, the length is always an exact nonnegative integer byte
count.
For textual ports, the representation of a length is unspecified; it
may not be an exact nonnegative integer and, even if it is, it may not
represent either a byte or character count.
The length may be used at some later time to reset the length if the
port supports <tt>set-port-length!</tt>.
If <tt>port-length</tt> is called on a port that does not support it,
an exception with condition type <tt>&amp;assertion</tt> is raised.

<p>
File lengths beyond 2<sup>32</sup> might not be reported property
for compressed files on 32-bit versions of the system.

<p>
<tt>file-length</tt> is identical to <tt>port-length</tt>.

<p>
<a name="./io:s34"></a><span class=formdef><b>procedure</b>: <tt>(set-port-length!&nbsp;<i>port</i>&nbsp;<i>len</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br><span class=formdef><b>procedure</b>: <tt>(port-has-set-port-length!?&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the port supports <tt>set-port-length!</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A port may allow the length of the underlying stream of characters or bytes
to be set, i.e., extended or truncated.
If so, the procedure <tt>port-has-set-port-length!?</tt> returns
<tt>#t</tt> and <tt>set-port-length!</tt> changes the length.
For binary ports, the length <tt><i>len</i></tt> must be an exact nonnegative integer byte
count.
For textual ports, the representation of a length is unspecified, as
described in the entry for <tt>port-length</tt> above, but <tt><i>len</i></tt> must be
an appropriate length for the textual port, which is usually guaranteed
to be the case only if it was obtained from a call to <tt>port-length</tt>
on the same port.
If <tt>set-port-length!</tt> is called on a port that does not support it,
an exception with condition type <tt>&amp;assertion</tt> is raised.

<p>
It is not possible to set the length of a port opened with compression
to an arbitrary position, and the result of an attempt to set the length
of a compressed file beyond 2<sup>32</sup> on 32-bit versions of the system is
undefined.


<p>
<a name="./io:s35"></a><span class=formdef><b>procedure</b>: <tt>(port-nonblocking?&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the port is in nonblocking mode, <tt>#f</tt> otherwise
<br><span class=formdef><b>procedure</b>: <tt>(port-has-port-nonblocking??&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the port supports <tt>port-nonblocking?</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A port may allow the nonblocking status of the port to be determined.
If so, the procedure <tt>port-has-port-nonblocking??</tt> returns
<tt>#t</tt> and <tt>port-nonblocking?</tt> returns a boolean value
reflecting whether the port is in nonblocking mode.


<p>
<a name="./io:s36"></a><span class=formdef><b>procedure</b>: <tt>(set-port-nonblocking!&nbsp;<i>port</i>&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br><span class=formdef><b>procedure</b>: <tt>(port-has-set-port-nonblocking!?&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the port supports <tt>set-port-nonblocking!</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A port may allow reads or writes to be performed in a "nonblocking" fashion.
If so, the procedure <tt>port-has-set-port-nonblocking!?</tt> returns
<tt>#t</tt> and <tt>set-port-nonblocking!</tt> sets the port to nonblocking
mode (if <tt><i>obj</i></tt> is a true value) or blocking mode (if <tt><i>obj</i></tt> is <tt>#f</tt>).
If <tt>set-port-nonblocking!</tt> is called on a port that does not support it,
an exception with condition type <tt>&amp;assertion</tt> is raised.

<p>
Ports created by the standard Revised<sup>6</sup> port opening procedures are
initially set in blocking mode by default.
The same is true for most of the procedures described in this document.
A generic port based on a nonblocking source may be nonblocking
initially.
A port returned by <tt>open-fd-input-port</tt>,
<tt>open-fd-output-port</tt>, or <tt>open-fd-input/output-port</tt>
is initially in nonblocking mode if the file-descriptor passed in is in
nonblocking mode.
Similarly, a port returned by <tt>standard-input-port</tt>,
<tt>standard-output-port</tt>, or <tt>standard-error-port</tt> is
initially in nonblocking mode if the underlying stdin, stdout,
or stderr file descriptor is in nonblocking mode.

<p>
Although <tt>get-bytevector-some</tt> and <tt>get-string-some</tt> normally
cannot return an empty bytevector or empty string, they can if the port
is in nonblocking mode and no input is available.
Also, <tt>get-bytevector-some!</tt> and <tt>get-string-some!</tt>
may not read any data if the port is in nonblocking mode and
no data is available.
Similarly, <tt>put-bytevector-some</tt> and <tt>put-string-some</tt>
may not write any data if the port is in nonblocking mode and
no room is available.

<p>
Nonblocking mode is not supported under Windows.

<p>
<a name="./io:s37"></a><span class=formdef><b>procedure</b>: <tt>(file-position&nbsp;<i>port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(file-position&nbsp;<i>port</i>&nbsp;<i>pos</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When the second argument is omitted, this procedure behaves like the R6RS
<tt>port-position</tt> procedure, and when present, like the R6RS
<tt>set-port-position!</tt> procedure.

<p>
For compressed files opened with the <tt>compressed</tt> flag,
<tt>file-position</tt> returns the position in the
uncompressed stream of data.
Changing the position of a compressed input file opened with the
<tt>compressed</tt> flag generally requires rewinding and rereading the
file and might thus be slow.
The position of a compressed output file opened with the
<tt>compressed</tt> flag can be moved forward only; this is
accomplished by writing a (compressed) sequence of zeros.
File positions beyond 2<sup>32</sup> might not be reported property
for compressed files on 32-bit versions of the system.


<p>
<a name="./io:s38"></a><span class=formdef><b>procedure</b>: <tt>(clear-input-port)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(clear-input-port&nbsp;<i>input-port</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>input-port</i></tt> is not supplied, it defaults to the current input port.
This procedure discards any data in the buffer associated
with <tt><i>input-port</i></tt>.
This may be necessary, for example, to clear any type-ahead from the keyboard
in preparation for an urgent query.

<p>
<a name="./io:s39"></a><span class=formdef><b>procedure</b>: <tt>(clear-output-port)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(clear-output-port&nbsp;<i>output-port</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>output-port</i></tt> is not supplied, it defaults to the current output port.
This procedure discards any data in the buffer associated
with <tt><i>output-port</i></tt>.
This may be necessary, for example, to clear any pending output on an
interactive port in preparation for an urgent message.


<p>
<a name="./io:s40"></a><span class=formdef><b>procedure</b>: <tt>(flush-output-port)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(flush-output-port&nbsp;<i>output-port</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>output-port</i></tt> is not supplied, it defaults to the current output port.
This procedure  forces any data in the buffer associated
with <tt><i>output-port</i></tt> to be printed immediately.
The console output port is automatically flushed after a newline and before
input from the console input port; all ports are automatically flushed when
they are closed.
<tt>flush-output-port</tt> may be necessary, however, to force a message
without a newline to be sent to the console output port or to force output
to appear on a file without delay.

<p>
<a name="./io:s41"></a><span class=formdef><b>procedure</b>: <tt>(port-file-compressed!&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>port</i></tt> must be an input or an output port, but not an input/output port.
It must be a file port pointing to a regular file, i.e., a file on disk rather
than, e.g., a socket.
The port can be a binary or textual port.
If the port is an output port, subsequent output sent to the port
will be compressed.
If the port is an input port, subsequent input will be decompressed
if and only if the port is currently pointing at compressed data.
The compression format for output
is determined by the <a name="./io:s42"></a><tt>compress-format</tt>
parameter, while the compression format on input is inferred.
The compression level, which is relevant only for output, is determined
by the <a name="./io:s43"></a><tt>compress-level</tt> parameter.
This procedure has no effect if the port is already set for compression.

<p>
<a name="./io:s44"></a><span class=formdef><b>thread parameter</b>: <tt>compress-format</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>compress-format</tt> determines the
compression algorithm and format used for output. Currently,
the possible values of the parameter are the symbols <tt>lz4</tt> (the default)
and <tt>gzip</tt>.

<p>
The <tt>lz4</tt> format uses the LZ4 compression library developed by
Yann Collet.
It is therefore compatible with the <tt>lz4</tt> program, which
means that <tt>lz4</tt> may be used to uncompress files produced
by <i>Chez&nbsp;Scheme</i> and visa versa.

<p>
The <tt>gzip</tt> format uses the zlib compression library developed by
Jean-loup Gailly and Mark Adler.
It is therefore compatible with the <tt>gzip</tt> program, which
means that <tt>gzip</tt> may be used to uncompress files produced
by <i>Chez&nbsp;Scheme</i> and visa versa.

<p>
Reading <tt>lz4</tt>-compressed data tends to be much faster than reading
<tt>gzip</tt>-compressed data, while <tt>gzip</tt>-compressed data tends to 
be significantly smaller.

<p>
<a name="./io:s45"></a><span class=formdef><b>thread parameter</b>: <tt>compress-level</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>compress-level</tt> determines the amount of effort spent on
compression and is thus relevant only for output.
It can be set to one of the symbols <tt>minimum</tt>, <tt>low</tt>,
<tt>medium</tt>, <tt>high</tt>, or <tt>maximum</tt>, which are
listed in order from shortest to longest expected compression time
and least to greatest expected effectiveness.
Its default value is <tt>medium</tt>.

<p>

<h3><a name="g82"></a><a name="./io:h5"></a>Section 9.5. String Ports<a name="SECTIOSTRINGPORTS"></a></h3>



<p>
String ports allow the creation and manipulation of strings via port
operations.
The procedure
<tt>open-input-string</tt> converts a string into a textual input port,
allowing the characters in the string to be read in sequence via input
operations such as <tt>read-char</tt> or <tt>read</tt>.
The procedure
<tt>open-output-string</tt> allows new strings to be built up with
output operations such as <tt>write-char</tt> and <tt>write</tt>.

<p>
While string ports could be defined as generic ports, they are instead
supported as primitive by the implementation.


<p>
<a name="./io:s46"></a><span class=formdef><b>procedure</b>: <tt>(open-input-string&nbsp;<i>string</i>)</tt></span>
<br>
<b>returns: </b>a new string input port
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A <a name="./io:s47"></a>string input port is similar to a file input port, except that
characters and objects drawn from the port come from <tt><i>string</i></tt>
rather than from a file.

<p>
A string port is at "end of file" when the port reaches the end of the
string.
It is not necessary to close a string port, although it is okay to do so.

<p>

<p><tt>(let&nbsp;([p&nbsp;(open-input-string&nbsp;"hi&nbsp;mom!")])<br>

&nbsp;&nbsp;(let&nbsp;([x&nbsp;(read&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;x&nbsp;(read&nbsp;p))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(hi&nbsp;mom!)</tt>
<p><a name="./io:s48"></a><span class=formdef><b>procedure</b>: <tt>(with-input-from-string&nbsp;<i>string</i>&nbsp;<i>thunk</i>)</tt></span>
<br>
<b>returns: </b>the values returned by <tt><i>thunk</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>thunk</i></tt> must be a procedure and should accept zero arguments.
<tt>with-input-from-string</tt> parameterizes the current input port to be the
result of opening <tt><i>string</i></tt> for input during the
application of <tt><i>thunk</i></tt>.

<p>

<p><tt>(with-input-from-string&nbsp;"(cons&nbsp;3&nbsp;4)"<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(eval&nbsp;(read))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(3&nbsp;.&nbsp;4)</tt>
<p><a name="./io:s49"></a><span class=formdef><b>procedure</b>: <tt>(open-output-string)</tt></span>
<br>
<b>returns: </b>a new string output port
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A <a name="./io:s50"></a>string output port is similar to a file output port, except that
characters and objects written to the port are placed in a string
(which grows as needed) rather than to a file.
The string built by writing to a string output port may be obtained
with <tt>get-output-string</tt>.
See the example given for <tt>get-output-string</tt> below.
It is not necessary to close a string port, although it is okay to do so.


<p>
<a name="./io:s51"></a><span class=formdef><b>procedure</b>: <tt>(get-output-string&nbsp;<i>string-output-port</i>)</tt></span>
<br>
<b>returns: </b>the string associated with <tt><i>string-output-port</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>string-output-port</i></tt> must be an port returned by <tt>open-output-string</tt>.

<p>
As a side effect, <tt>get-output-string</tt> resets <tt><i>string-output-port</i></tt>
so that subsequent output to <tt><i>string-output-port</i></tt> is placed
into a fresh string.

<p>

<p><tt>(let&nbsp;([p&nbsp;(open-output-string)])<br>

&nbsp;&nbsp;(write&nbsp;'hi&nbsp;p)<br>

&nbsp;&nbsp;(write-char&nbsp;#\space&nbsp;p)<br>

&nbsp;&nbsp;(write&nbsp;'mom!&nbsp;p)<br>

&nbsp;&nbsp;(get-output-string&nbsp;p))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"hi&nbsp;mom!"</tt>
<p>An implementation of <tt>format</tt> (Section&nbsp;<a href="./io.html#g90">9.13</a>) might be
written using string-output ports to produce string output.


<p>
<a name="./io:s52"></a><span class=formdef><b>procedure</b>: <tt>(with-output-to-string&nbsp;<i>thunk</i>)</tt></span>
<br>
<b>returns: </b>a string containing the output
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>thunk</i></tt> must be a procedure and should accept zero arguments.
<tt>with-output-to-string</tt> parameterizes the current output port to
a new string output port during the
application of <tt><i>thunk</i></tt>.
If <tt><i>thunk</i></tt> returns, the string associated with the new string output
port is returned, as with <tt>get-output-string</tt>.

<p>

<p><tt>(with-output-to-string<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"Once&nbsp;upon&nbsp;a&nbsp;time&nbsp;...")<br>

&nbsp;&nbsp;&nbsp;&nbsp;(newline)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"Once&nbsp;upon&nbsp;a&nbsp;time&nbsp;...\n"</tt>
<p>
<h3><a name="g83"></a><a name="./io:h6"></a>Section 9.6. File Ports<a name="SECTIOFILEPORTS"></a></h3>



<p>
<a name="./io:s53"></a><span class=formdef><b>thread parameter</b>: <tt>file-buffer-size</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>file-buffer-size</tt> is a parameter that determines the size of each
buffer created when the buffer mode is not <tt>none</tt> for a port
created by one of the file open operations, e.g., <tt>open-input-file</tt>
or <tt>open-file-output-port</tt>.
The value of this parameter must be a positive fixnum.

<p>
<a name="./io:s54"></a><span class=formdef><b>procedure</b>: <tt>(file-port?&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>port</i></tt> is a file port, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A file port is any port based directly
on an O/S file descriptor, e.g., one created by <tt>open-file-input-port</tt>,
<tt>open-output-port</tt>, <tt>open-fd-input-port</tt>, etc., but not
a string, bytevector, or custom  port.


<p>
<a name="./io:s55"></a><span class=formdef><b>procedure</b>: <tt>(port-file-descriptor&nbsp;<i>port</i>)</tt></span>
<br>
<b>returns: </b>the file descriptor associated with <tt><i>port</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>port</i></tt> must be a file port, i.e., a port for which <tt><i>file-port?</i></tt>
returns <tt>#t</tt>.


<p>

<h3><a name="g84"></a><a name="./io:h7"></a>Section 9.7. Custom Ports<a name="SECTIOCUSTOMPORTS"></a></h3>



<p>
<a name="./io:s56"></a><span class=formdef><b>thread parameter</b>: <tt>custom-port-buffer-size</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>custom-port-buffer-size</tt> is a parameter that determines the sizes
of the buffers associated with newly created custom ports.
The value of this parameter must be a positive fixnum.

<p>

<h3><a name="g85"></a><a name="./io:h8"></a>Section 9.8. Input Operations<a name="SECTIOINPUT"></a></h3>



<p>
<a name="./io:s57"></a><span class=formdef><b>global parameter</b>: <tt>console-input-port</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>console-input-port</tt> is a parameter that determines the
input port used by the waiter and interactive debugger.
When called with no arguments, it returns the
console input port.
When called with one argument, which must be a textual input port,
it changes the value of the console
input port.
The initial value of this parameter is a port tied to the standard
input (stdin) stream of the Scheme process.

<p>
<a name="./io:s58"></a><span class=formdef><b>thread parameter</b>: <tt>current-input-port</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>current-input-port</tt> is a parameter that determines the
default port argument for most input procedures, including
<tt>read-char</tt>, <tt>peek-char</tt>, and <tt>read</tt>,
When called with no arguments, <tt>current-input-port</tt> returns the
current input port.
When called with one argument, which must be a textual input port,
it changes the value of the current
input port.
The Revised<sup>6</sup> Report version of <tt>current-input-port</tt> accepts
only zero arguments, i.e., it cannot be used to change the current input
port.
The initial value of this parameter is the same port as the initial
value of <tt>console-input-port</tt>.


<p>
<a name="./io:s59"></a><span class=formdef><b>procedure</b>: <tt>(open-input-file&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(open-input-file&nbsp;<i>path</i>&nbsp;<i>options</i>)</tt></span>
<br>
<b>returns: </b>a new input port
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt>open-input-file</tt> opens a textual input port for the file named by
<tt><i>path</i></tt>.
An exception is raised with condition type
<tt>&amp;i/o-filename</tt> if the file does not exist or cannot be
opened for input.

<p>
<tt><i>options</i></tt>, if present, is a symbolic option name or option list.
Possible symbolic option names are 
<tt>compressed</tt>, <tt>uncompressed</tt>, <tt>buffered</tt>,
and <tt>unbuffered</tt>.
An option list is a list containing zero or more symbolic option names.

<p>
The mutually exclusive <tt>compressed</tt> and
<tt>uncompressed</tt> options determine whether the input file
should be decompressed if it is compressed (where the compression
format is inferred).
(See <tt>open-output-file</tt>.)
The default is <tt>uncompressed</tt>, so the <tt>uncompressed</tt>
option is useful only as documentation.

<p>
The mutually exclusive <tt>buffered</tt> and <tt>unbuffered</tt>
options determine whether input is buffered.
When input is buffered, it is read in large blocks and buffered internally
for efficiency to reduce the number of operating system requests.
When the <tt>unbuffered</tt> option is specified, input is unbuffered,
but not fully, since one character of buffering is required to support
<tt>peek-char</tt> and <tt>unread-char</tt>.
Input is buffered by default, so the <tt>buffered</tt> option is useful
only as documentation.


<p>
For example, the call

<p>

<p><tt>(open-input-file&nbsp;"frob"&nbsp;'(compressed))</tt>
<p>opens the file frob with decompression enabled.

<p>
The Revised<sup>6</sup> Report version of <tt>open-input-file</tt> does not
support the optional <tt><i>options</i></tt> argument.

<p>
<a name="./io:s60"></a><span class=formdef><b>procedure</b>: <tt>(call-with-input-file&nbsp;<i>path</i>&nbsp;<i>procedure</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(call-with-input-file&nbsp;<i>path</i>&nbsp;<i>procedure</i>&nbsp;<i>options</i>)</tt></span>
<br>
<b>returns: </b>the values returned by <tt><i>procedure</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt><i>procedure</i></tt> should accept one argument.

<p>
<tt>call-with-input-file</tt> creates a new input port for the file named
by <tt><i>path</i></tt>, as if with <tt>open-input-file</tt>, and passes this port to <tt><i>procedure</i></tt>.
If <tt><i>procedure</i></tt> returns normally, <tt>call-with-input-file</tt> closes the input port
and returns the values returned by <tt><i>procedure</i></tt>.

<p>
<tt>call-with-input-file</tt> does not automatically close the input
port if a continuation created outside of <tt><i>procedure</i></tt> is invoked, since it
is possible that another continuation created inside of <tt><i>procedure</i></tt> will be
invoked at a later time, returning control to <tt><i>procedure</i></tt>.
If <tt><i>procedure</i></tt> does not return, an implementation is free to close the
input port only if it can prove that the input port is no longer accessible.
As shown in Section&nbsp;<a href="http://scheme.com/tspl4/./control.html#g102">5.6</a> of <i>The Scheme Programming Language, 4th Edition</i>, <tt>dynamic-wind</tt> may be used to
ensure that the port is closed if a continuation created outside of
<tt><i>procedure</i></tt> is invoked.

<p>
See <tt>open-input-file</tt> above for a description of the optional
<tt><i>options</i></tt> argument.

<p>
The Revised<sup>6</sup> Report version of <tt>call-with-input-file</tt> does not
support the optional <tt><i>input</i></tt> argument.

<p>
<a name="./io:s61"></a><span class=formdef><b>procedure</b>: <tt>(with-input-from-file&nbsp;<i>path</i>&nbsp;<i>thunk</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(with-input-from-file&nbsp;<i>path</i>&nbsp;<i>thunk</i>&nbsp;<i>options</i>)</tt></span>
<br>
<b>returns: </b>the values returned by <tt><i>thunk</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt><i>thunk</i></tt> must be a procedure and should accept zero arguments.

<p>
<tt>with-input-from-file</tt> temporarily changes the current input port to be the
result of opening the file named by <tt><i>path</i></tt>, as if with <tt>open-input-file</tt>, during the
application of <tt><i>thunk</i></tt>.
If <tt><i>thunk</i></tt> returns, the port is closed and the current input port
is restored to its old value.

<p>
The behavior of <tt>with-input-from-file</tt> is unspecified
if a continuation created outside
of <tt><i>thunk</i></tt> is invoked before <tt><i>thunk</i></tt> returns.
An implementation may close the port and restore the current input
port to its old value---but it may not.

<p>
See <tt>open-input-file</tt> above for a description of the optional
<tt><i>options</i></tt> argument.

<p>
The Revised<sup>6</sup> Report version of <tt>with-input-from-file</tt> does not
support the optional <tt><i>options</i></tt> argument.

<p>
<a name="./io:s62"></a><span class=formdef><b>procedure</b>: <tt>(open-fd-input-port&nbsp;<i>fd</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(open-fd-input-port&nbsp;<i>fd</i>&nbsp;<i>b-mode</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(open-fd-input-port&nbsp;<i>fd</i>&nbsp;<i>b-mode</i>&nbsp;<i>?transcoder</i>)</tt></span>
<br>
<b>returns: </b>a new input port for the file descriptor <tt><i>fd</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>fd</i></tt> must be a nonnegative exact integer and should be a valid
open file descriptor.
If <tt><i>?transcoder</i></tt> is present and not <tt>#f</tt>, it must be a
transcoder, and this procedure returns a textual input port
whose transcoder is <tt><i>?transcoder</i></tt>.
Otherwise, this procedure returns a binary input port.
See the lead-in to Section&nbsp;<a href="http://scheme.com/tspl4/./io.html#g123">7.2</a> of <i>The Scheme Programming Language, 4th Edition</i>
for a description of the constraints on and effects of the other
arguments.

<p>
The file descriptor is closed when the port is closed.

<p>
<a name="./io:s63"></a><span class=formdef><b>procedure</b>: <tt>(standard-input-port)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(standard-input-port&nbsp;<i>b-mode</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(standard-input-port&nbsp;<i>b-mode</i>&nbsp;<i>?transcoder</i>)</tt></span>
<br>
<b>returns: </b>a new input port connected to the process's standard input
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>?transcoder</i></tt> is present and not <tt>#f</tt>, it must be a
transcoder, and this procedure returns a textual input port
whose transcoder is <tt><i>?transcoder</i></tt>.
Otherwise, this procedure returns a binary input port.
The buffer mode <tt><i>b-mode</i></tt> defaults to <tt>block</tt>.

<p>
The Revised<sup>6</sup> Report version of this procedure does not accept the
optional <tt><i>b-mode</i></tt> and <tt><i>?transcoder</i></tt> arguments, which limits
it to an implementation-dependent buffering mode (<tt>block</tt> in
<i>Chez&nbsp;Scheme</i>) and binary output.

<p>
<a name="./io:s64"></a><span class=formdef><b>procedure</b>: <tt>(get-string-some&nbsp;<i>textual-input-port</i>)</tt></span>
<br>
<b>returns: </b>a nonempty string or the eof object
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>textual-input-port</i></tt> is at end of file, the eof object is returned.
Otherwise, <tt>get-string-some</tt> reads (as if with <tt>get-u8</tt>)
at least one character and possibly more, and returns a string containing
these characters.
The port's position is advanced past the characters read.
The maximum number of characters read by this operation is implementation-dependent.

<p>
An exception to the "at least one character" guarantee occurs
if the port is in nonblocking mode (see <tt>set-port-nonblocking!</tt>)
and no input is ready.
In this case, an empty string is returned.


<p>
<a name="./io:s65"></a><span class=formdef><b>procedure</b>: <tt>(get-string-some!&nbsp;<i>textual-input-port</i>&nbsp;<i>string</i>&nbsp;<i>start</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the count of characters read, as an exact nonnegative integer, or the eof object
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>start</i></tt> and <tt><i>n</i></tt> must be exact nonnegative integers, and the sum of
<tt><i>start</i></tt> and <tt><i>n</i></tt> must not exceed the length of <tt><i>string</i></tt>.

<p>
If <tt><i>n</i></tt> is 0, this procedure returns zero without attempting to
read from <tt><i>textual-input-port</i></tt> and without modifying <tt><i>string</i></tt>.

<p>
Otherwise, if <tt><i>textual-input-port</i></tt> is at end of file, this procedure
returns the eof object, except it returns zero when the port is in nonblocking mode
(see <tt>set-port-nonblocking!</tt>) and the port cannot be determined
to be at end of file without blocking.
In either case, <tt><i>string</i></tt> is not modified.

<p>
Otherwise, this procedure reads (as if with <tt>get-char</tt>)
up to <tt><i>n</i></tt> characters from the port, stores the characters in consecutive locations of <tt><i>string</i></tt>
starting at <tt><i>start</i></tt>, advances the port's position just past the characters read, and
returns the count of characters read.

<p>
If the port is in nonblocking mode, this procedure reads no more
than it can without blocking and thus might read zero characters;
otherwise, it reads at least one character but no more than are available
when the first character becomes available.

<p>
<a name="./io:s66"></a><span class=formdef><b>procedure</b>: <tt>(get-bytevector-some!&nbsp;<i>binary-input-port</i>&nbsp;<i>bytevector</i>&nbsp;<i>start</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the count of bytes read, as an exact nonnegative integer, or the eof object
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>start</i></tt> and <tt><i>n</i></tt> must be exact nonnegative integers, and the sum of
<tt><i>start</i></tt> and <tt><i>n</i></tt> must not exceed the length of <tt><i>bytevector</i></tt>.

<p>
If <tt><i>n</i></tt> is 0, this procedure returns zero without attempting to
read from <tt><i>binary-input-port</i></tt> and without modifying <tt><i>bytevector</i></tt>.

<p>
Otherwise, if <tt><i>binary-input-port</i></tt> is at end of file, this procedure
returns the eof object, except it returns zero when the port is in nonblocking mode
(see <tt>set-port-nonblocking!</tt>) and the port cannot be determined
to be at end of file without blocking.
In either case, <tt><i>bytevector</i></tt> is not modified.

<p>
Otherwise, this procedure reads (as if with <tt>get-u8</tt>)
up to <tt><i>n</i></tt> bytes from the port, stores the bytes in consecutive locations of <tt><i>bytevector</i></tt>
starting at <tt><i>start</i></tt>, advances the port's position just past the bytes read, and
returns the count of bytes read.

<p>
If the port is in nonblocking mode, this procedure reads no more
than it can without blocking and thus might read zero bytes;
otherwise, it reads at least one byte but no more than are available
when the first byte becomes available.

<p>
<a name="./io:s67"></a><span class=formdef><b>procedure</b>: <tt>(unread-char&nbsp;<i>char</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(unread-char&nbsp;<i>char</i>&nbsp;<i>textual-input-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(unget-char&nbsp;<i>textual-input-port</i>&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>For <tt>unread-char</tt>, if <tt><i>textual-input-port</i></tt> is not supplied, it
defaults to the current input port.
These procedures "unread" the last character read from
<tt>textual-input-port</tt>.
<tt><i>char</i></tt> may or may not be ignored, depending upon the implementation.
In any case, <tt><i>char</i></tt> should be last character read from the port.
A character should not be unread twice on the same port
without an intervening call to <tt>read-char</tt> or <tt>get-char</tt>.

<p>
<tt>unread-char</tt> and <tt>unget-char</tt> are provided for applications
requiring one character of lookahead and may be used in place of, or even
in combination with, <tt>peek-char</tt> or <tt>lookahead-char</tt>.
One character of lookahead is required in the procedure
<tt>read-word</tt>, which is defined below in terms of <tt>unread-char</tt>.
<tt>read-word</tt> returns the next word from a textual input port as a string, where
a word is defined to be a sequence of alphabetic characters.
Since it does not know until it reads one character too many that it has
read the entire word, <tt>read-word</tt> uses <tt>unread-char</tt> to
return the character to the input port.

<p>

<p><tt>(define&nbsp;read-word<br>

&nbsp;&nbsp;(lambda&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list-&gt;string<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([c&nbsp;(read-char&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eof-object?&nbsp;c)&nbsp;'()]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(char-alphabetic?&nbsp;c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;c&nbsp;(f&nbsp;(read-char&nbsp;p)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unread-char&nbsp;c&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()])))))</tt>
<p>In the alternate version below, <tt>peek-char</tt> is used instead of
<tt>unread-char</tt>.

<p>

<p><tt>(define&nbsp;read-word<br>

&nbsp;&nbsp;(lambda&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list-&gt;string<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([c&nbsp;(peek-char&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eof-object?&nbsp;c)&nbsp;'()]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(char-alphabetic?&nbsp;c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(read-char&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;c&nbsp;(f&nbsp;(peek-char&nbsp;p)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;'()])))))</tt>
<p>The advantage of <tt>unread-char</tt> in this situation is that only
one call to <tt>unread-char</tt> per word is required, whereas one
call to <tt>peek-char</tt> is required for each character in the word
plus the first character beyond.
In many cases, <tt>unread-char</tt> and <tt>unget-char</tt> do not enjoy
this advantage, and <tt>peek-char</tt> or <tt>lookahead-char</tt>
should be used instead.


<p>
<a name="./io:s68"></a><span class=formdef><b>procedure</b>: <tt>(unget-u8&nbsp;<i>binary-input-port</i>&nbsp;<i>octet</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedures "unreads" the last byte read from
<tt>binary-input-port</tt>.
<tt><i>octet</i></tt> may or may not be ignored, depending upon the implementation.
In any case, <tt><i>octet</i></tt> should be last byte read from the port.
A byte should not be unread twice on the same port
without an intervening call to <tt>get-u8</tt>.


<p>
<a name="./io:s69"></a><span class=formdef><b>procedure</b>: <tt>(input-port-ready?&nbsp;<i>input-port</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if data is available on <tt><i>input-port</i></tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>input-port-ready?</tt> allows a program to check to see if input is
available on a textual or binary input port without hanging.
If input is available or the port is at end of file,
<tt>input-port-ready?</tt> returns <tt>#t</tt>.
If it cannot determine from the port whether input is ready, 
<tt>input-port-ready?</tt> raises an exception with condition type
<tt>&amp;i/o-read-error</tt>.
Otherwise, it returns <tt>#f</tt>.

<p>
<a name="./io:s70"></a><span class=formdef><b>procedure</b>: <tt>(char-ready?)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(char-ready?&nbsp;<i>textual-input-port</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if a character is available on <tt><i>textual-input-port</i></tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>textual-input-port</i></tt> is not supplied, it defaults to the current input port.
<tt>char-ready?</tt> is like <tt>input-port-ready?</tt> except it is
restricted to textual input ports.


<p>
<a name="./io:s71"></a><span class=formdef><b>procedure</b>: <tt>(block-read&nbsp;<i>textual-input-port</i>&nbsp;<i>string</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(block-read&nbsp;<i>textual-input-port</i>&nbsp;<i>string</i>&nbsp;<i>count</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>count</i></tt> must be a nonnegative fixnum less than or equal to the
length of <tt><i>string</i></tt>.
If not provided, it defaults to the length of <tt><i>string</i></tt>.

<p>
If <tt><i>textual-input-port</i></tt> is at end-of-file, an eof object is returned.
Otherwise, <tt><i>string</i></tt> is filled with as many characters as are
available for reading from <tt><i>textual-input-port</i></tt> up to <tt><i>count</i></tt>,
and the number of characters placed in the string is returned.

<p>
If <tt><i>textual-input-port</i></tt> is buffered and the buffer is nonempty,
the buffered input or a portion thereof is returned; otherwise
<tt>block-read</tt> bypasses the buffer entirely.

<p>
<a name="./io:s72"></a><span class=formdef><b>procedure</b>: <tt>(read-token)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(read-token&nbsp;<i>textual-input-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(read-token&nbsp;<i>textual-input-port</i>&nbsp;<i>sfd</i>&nbsp;<i>bfp</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>sfd</i></tt> must be a source-file descriptor.
<tt><i>bfp</i></tt> must be an exact nonnegative integer and should be the
character position of the next character to be read from
<tt><i>textual-input-port</i></tt>.

<p>
Parsing of a Scheme datum is conceptually performed in two steps.
First, the sequence of characters that form the datum are grouped into
<tt>tokens</tt>, such as symbols, numbers, left parentheses, and
double quotes.
During this first step, whitespace and comments are discarded.
Second, these tokens are grouped into data.

<p>
<tt>read</tt> performs both of these steps and creates an internal
representation of each datum it parses.
<tt>read-token</tt> may be used to perform the first step only, one
token at a time.
<tt>read-token</tt> is intended to be used by editors and program
formatters that must be able to parse a program or datum without
actually reading it.

<p>
If <tt><i>textual-input-port</i></tt> is not supplied, it defaults to the current input port.
One token is read from the input port and returned as four values:

<p>
<dl compact>
<dt><tt><i>type</i></tt>:<dd> a symbol describing the type of token read,

<p>
<dt><tt><i>value</i></tt>:<dd> the token value,

<p>
<dt><tt><i>start</i></tt>:<dd> the position of the first character of the token,
relative to the starting position of the input port (or <tt>#f</tt>,
if the position cannot be determined), and

<p>
<dt><tt><i>end</i></tt>:<dd> the first position beyond the token,
relative to the starting position of the input port (or <tt>#f</tt>,
if the position cannot be determined).
</dl>

<p>
The input port is left pointing to the first character position beyond
the token.

<p>
When the token type fully specifies the token,
<tt>read-token</tt> returns <tt>#f</tt> for the value.
The token types are listed below with the corresponding <tt><i>value</i></tt>
in parentheses.

<p>
<dl compact>
<dt><tt>atomic</tt><dd> (<tt><i>atom</i></tt>) an atomic value, i.e., 
    a symbol, boolean, number, character, <tt>#!eof</tt>,
    or <tt>#!bwp</tt>
<dt><tt>box</tt><dd> (<tt>#f</tt>) box prefix, i.e.,  <tt>#&amp;</tt>
<dt><tt>dot</tt><dd> (<tt>#f</tt>) dotted pair separator, i.e., <tt>.</tt>
<dt><tt>eof</tt><dd> (<tt>#!eof</tt>) end of file
<dt><tt>fasl</tt><dd> (<tt>#f</tt>) fasl prefix, i.e., <tt>#@</tt>
<dt><tt>insert</tt><dd> (<tt><i>n</i></tt>) graph reference, i.e., <tt>#<i>n</i>#</tt>
<dt><tt>lbrack</tt><dd> (<tt>#f</tt>) open square bracket
<dt><tt>lparen</tt><dd> (<tt>#f</tt>) open parenthesis
<dt><tt>mark</tt><dd> (<tt><i>n</i></tt>) graph mark, i.e., <tt>#<i>n</i>=</tt>
<dt><tt>quote</tt><dd> (<tt>quote</tt>, <tt>quasiquote</tt>,
    <tt>syntax</tt>, <tt>unquote</tt>, <tt>unquote-splicing</tt>,
    or <tt>datum-comment</tt>)
    an abbreviation mark, e.g., <tt>'</tt> or <tt>,@</tt> or
    datum-comment prefix
<dt><tt>rbrack</tt><dd> (<tt>#f</tt>) close square bracket
<dt><tt>record-brack</tt><dd> (<tt>#f</tt>) record open bracket, i.e., <tt>#[</tt>
<dt><tt>rparen</tt><dd> (<tt>#f</tt>) close parenthesis
<dt><tt>vfxnparen</tt><dd> (<tt><i>n</i></tt>) fxvector prefix, i.e., <tt>#<i>n</i>vfx(</tt>
<dt><tt>vfxparen</tt><dd> (<tt>#f</tt>) fxvector prefix, i.e., <tt>#vfx(</tt>
<dt><tt>vnparen</tt><dd> (<tt><i>n</i></tt>) vector prefix, i.e., <tt>#<i>n</i>(</tt>
<dt><tt>vparen</tt><dd> (<tt>#f</tt>) vector prefix, i.e., <tt>#(</tt>
<dt><tt>vu8nparen</tt><dd> (<tt><i>n</i></tt>) bytevector prefix, i.e., <tt>#<i>n</i>vu8(</tt>
<dt><tt>vu8paren</tt><dd> (<tt>#f</tt>) bytevector prefix, i.e., <tt>#vu8(</tt>
</dl>

<p>
The set of token types is likely to change in future releases of the
system; check the release notes for details on such changes.

<p>
Specifying <tt><i>sfd</i></tt> and <tt><i>bfp</i></tt> improves the quality of error messages,
guarantees <tt><i>start</i></tt> and <tt><i>end</i></tt> can be determined,
and eliminates the overhead of asking for a file position on each call
to <tt>read-token</tt>.
In most cases, <tt><i>bfp</i></tt> should be 0 for the first call
to <tt>read-token</tt> at the start of a file,
and it should be the fourth return value (<tt><i>end</i></tt>) of the preceding
call to <tt>read-token</tt> for each subsequent
call.
This protocol is necessary to handle files containing multiple-byte
characters, since file positions do not necessarily correspond
to character positions.

<p>

<p><tt>(define&nbsp;s&nbsp;(open-input-string&nbsp;"(a&nbsp;b&nbsp;c)"))<br>

(read-token&nbsp;s)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;lparen<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#f<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>

(define&nbsp;s&nbsp;(open-input-string&nbsp;"abc&nbsp;123"))<br>

(read-token&nbsp;s)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;atomic<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abc<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3<br>

(define&nbsp;s&nbsp;(open-input-string&nbsp;""))<br>

(read-token&nbsp;s)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;eof<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#!eof<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

(define&nbsp;s&nbsp;(open-input-string&nbsp;"#7=#7#"))<br>

(read-token&nbsp;s)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;mark<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3<br>

(read-token&nbsp;s)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;insert<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6</tt>
<p>The information <tt>read-token</tt> returns is not always
sufficient for reconstituting the exact sequence of characters that
make up a token.
For example, <tt>1.0</tt> and <tt>1e0</tt> both return
<tt><i>type</i></tt> <tt>atomic</tt> with <tt><i>value</i></tt> <tt>1.0</tt>.
The exact sequence of characters may be obtained only by repositioning
the port and reading a block of characters of the appropriate length,
using the relative positions given by <tt><i>start</i></tt> and <tt><i>end</i></tt>.


<p>

<h3><a name="g86"></a><a name="./io:h9"></a>Section 9.9. Output Operations<a name="SECTIOOUTPUT"></a></h3>



<p>
<a name="./io:s73"></a><span class=formdef><b>global parameter</b>: <tt>console-output-port</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>console-output-port</tt> is a parameter that determines the
output port used by the waiter and interactive debugger.
When called with no arguments, it returns the
console output port.
When called with one argument, which must be a textual output port,
it changes the value of the console
output port.
The initial value of this parameter is a port tied to the standard
output (stdout) stream of the Scheme process.


<p>
<a name="./io:s74"></a><span class=formdef><b>thread parameter</b>: <tt>current-output-port</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>current-output-port</tt> is a parameter that determines the
default port argument for most output procedures,
including <tt>write-char</tt>, <tt>newline</tt>, <tt>write</tt>,
<tt>display</tt>, and <tt>pretty-print</tt>.
When called with no arguments, <tt>current-output-port</tt> returns the
current output port.
When called with one argument, which must be a textual output port,
it changes the value of the current
output port.
The Revised<sup>6</sup> Report version of <tt>current-output-port</tt> accepts
only zero arguments, i.e., it cannot be used to change the current output
port.
The initial value of this parameter is the same port as the initial
value of <tt>console-output-port</tt>.


<p>
<a name="./io:s75"></a><span class=formdef><b>thread parameter</b>: <tt>console-error-port</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>console-error-port</tt> is a parameter that can be used to set
or obtain the console error port, which determines the port to which
conditions and other messages are printed by the default exception
handler.
When called with no arguments, <tt>console-error-port</tt> returns the
console error port.
When called with one argument, which must be a textual output port,
it changes the value of the console
error port.

<p>
If the system determines that the standard output (stdout) and standard
error (stderr) streams refer to the same file, socket, pipe, virtual
terminal, device, etc., this parameter is initially set to the same value
as the parameter <tt>console-output-port</tt>.
Otherwise, this parameter is initially set to a different port tied to the
standard error (stderr) stream of the Scheme process.

<p>
<a name="./io:s76"></a><span class=formdef><b>thread parameter</b>: <tt>current-error-port</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>current-error-port</tt> is a parameter that can be used to set
or obtain the current error port.
When called with no arguments, <tt>current-error-port</tt> returns the
current error port.
When called with one argument, which must be a textual output port,
it changes the value of the current error port.
The Revised<sup>6</sup> Report version of <tt>current-error-port</tt> accepts
only zero arguments, i.e., it cannot be used to change the current error
port.
The initial value of this parameter is the same port as the initial
value of <tt>console-error-port</tt>.

<p>
<a name="./io:s77"></a><span class=formdef><b>procedure</b>: <tt>(open-output-file&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(open-output-file&nbsp;<i>path</i>&nbsp;<i>options</i>)</tt></span>
<br>
<b>returns: </b>a new output port
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt>open-output-file</tt> opens a textual output port for the file named by
<tt><i>path</i></tt>.

<p>
<tt><i>options</i></tt>, if present, is a symbolic option name or option list.
Possible symbolic option names are 
<tt>error</tt>, <tt>truncate</tt>, <tt>replace</tt>, <tt>append</tt>,
<tt>compressed</tt>, <tt>uncompressed</tt>, <tt>buffered</tt>,
<tt>unbuffered</tt>, <tt>exclusive</tt>, and <tt>nonexclusive</tt>.
An option list is a list containing zero or more symbolic option names
and possibly the two-element
option <tt>mode&nbsp;<i>mode</i></tt>.

<p>
The mutually exclusive <tt>error</tt>, <tt>truncate</tt>,
<tt>replace</tt>, and <tt>append</tt> options are used to direct what happens when
the file to be opened already exists.
<dl compact>
<dt><tt>error</tt>:<dd> An exception is raised with condition-type <tt>&amp;i/o-filename</tt>.
<dt><tt>replace</tt>:<dd> The existing file is deleted before the new file
is opened.
<dt><tt>truncate</tt>:<dd> The existing file is opened
and truncated to zero length.
<dt><tt>append</tt>:<dd> 
The existing file is opened
and the output port is positioned at the end of the file before each write
so that output to the port is always appended to the file.
</dl>
The default behavior is to raise an exception.

<p>
The mutually exclusive <tt>compressed</tt> and
<tt>uncompressed</tt> options determine whether the output file is to
be compressed.
The compression format and level are determined by the
<a name="./io:s78"></a><tt>compress-format</tt>
and
<a name="./io:s79"></a><tt>compress-level</tt>
parameters.
Files are uncompressed by default, so the <tt>uncompressed</tt>
option is useful only as documentation.

<p>
The mutually exclusive <tt>buffered</tt> and <tt>unbuffered</tt>
options determine whether output is buffered.
Unbuffered output is sent immediately to the file, whereas buffered
output not written until the port's output buffer is filled or the
port is flushed (via <tt>flush-output-port</tt>) or closed (via
<tt>flush-output-port</tt> or by the storage management system when
the port becomes inaccessible).
Output is buffered by default for efficiency, so the
<tt>buffered</tt> option is useful only as documentation.

<p>
The mutually exclusive <tt>exclusive</tt> and <tt>nonexclusive</tt>
options determine whether access to the file is "exclusive."
When the exclusive option is specified, the file is locked until
the port is closed to prevent access by other processes.
On some systems the lock is advisory, i.e., it inhibits access by 
other processes only if they also attempt to open exclusively.
Nonexclusive access is the default, so the <tt>nonexclusive</tt> option
is useful only as documentation.

<p>
The <tt>mode</tt> option determines the permission bits
on Unix systems when the file is created by the operation, subject
to the process umask.
The subsequent element in the options list must be an exact integer
specifying the permissions in the manner of the Unix <tt>open</tt>
function.
The mode option is ignored under Windows.

<p>
For example, the call

<p>

<p><tt>(open-output-file&nbsp;"frob"&nbsp;'(compressed&nbsp;truncate&nbsp;mode&nbsp;#o644))</tt>
<p>opens the file frob with compression enabled.
If frob already exists it is truncated.
On Unix-based systems, if frob does not already exist, the permission
bits on the newly created file are set to logical and of <tt>#o644</tt> and the
process's umask.

<p>
The Revised<sup>6</sup> Report version of <tt>open-output-file</tt> does not
support the optional <tt><i>options</i></tt> argument.

<p>
<a name="./io:s80"></a><span class=formdef><b>procedure</b>: <tt>(call-with-output-file&nbsp;<i>path</i>&nbsp;<i>procedure</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(call-with-output-file&nbsp;<i>path</i>&nbsp;<i>procedure</i>&nbsp;<i>options</i>)</tt></span>
<br>
<b>returns: </b>the values returned by <tt><i>procedure</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt><i>procedure</i></tt> should accept one argument.

<p>
<tt>call-with-output-file</tt> creates a new output port for the file named
by <tt><i>path</i></tt>, as if with <tt>open-output-file</tt>, and passes this port to <tt><i>procedure</i></tt>.
If <tt><i>procedure</i></tt> returns, <tt>call-with-output-file</tt> closes the output port
and returns the values returned by <tt><i>procedure</i></tt>.

<p>
<tt>call-with-output-file</tt> does not automatically close the output
port if a continuation created outside of <tt><i>procedure</i></tt> is invoked, since it
is possible that another continuation created inside of <tt><i>procedure</i></tt> will be
invoked at a later time, returning control to <tt><i>procedure</i></tt>.
If <tt><i>procedure</i></tt> does not return, an implementation is free to close the
output port only if it can prove that the output port is no longer accessible.
As shown in Section&nbsp;<a href="http://scheme.com/tspl4/./control.html#g102">5.6</a> of <i>The Scheme Programming Language, 4th Edition</i>, <tt>dynamic-wind</tt> may be used to
ensure that the port is closed if a continuation created outside of
<tt><i>procedure</i></tt> is invoked.

<p>
See <tt>open-output-file</tt> above for a description of the optional
<tt><i>options</i></tt> argument.

<p>
The Revised<sup>6</sup> Report version of <tt>call-with-output-file</tt> does not
support the optional <tt><i>options</i></tt> argument.


<p>
<a name="./io:s81"></a><span class=formdef><b>procedure</b>: <tt>(with-output-to-file&nbsp;<i>path</i>&nbsp;<i>thunk</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(with-output-to-file&nbsp;<i>path</i>&nbsp;<i>thunk</i>&nbsp;<i>options</i>)</tt></span>
<br>
<b>returns: </b>the value returned by <tt><i>thunk</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt><i>thunk</i></tt> must be a procedure and should accept zero arguments.

<p>
<tt>with-output-to-file</tt> temporarily rebinds the current output port to be the
result of opening the file named by <tt><i>path</i></tt>, as if with <tt>open-output-file</tt>,
during the application of <tt><i>thunk</i></tt>.
If <tt><i>thunk</i></tt> returns, the port is closed and the current output port
is restored to its old value.

<p>
The behavior of <tt>with-output-to-file</tt> is unspecified if a
continuation created outside of <tt><i>thunk</i></tt> is invoked before
<tt><i>thunk</i></tt> returns.
An implementation may close the port and restore the current output
port to its old value---but it may not.

<p>
See <tt>open-output-file</tt> above for a description of the optional
<tt><i>options</i></tt> argument.

<p>
The Revised<sup>6</sup> Report version of <tt>with-output-to-file</tt> does not
support the optional <tt><i>options</i></tt> argument.

<p>
<a name="./io:s82"></a><span class=formdef><b>procedure</b>: <tt>(open-fd-output-port&nbsp;<i>fd</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(open-fd-output-port&nbsp;<i>fd</i>&nbsp;<i>b-mode</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(open-fd-output-port&nbsp;<i>fd</i>&nbsp;<i>b-mode</i>&nbsp;<i>?transcoder</i>)</tt></span>
<br>
<b>returns: </b>a new output port for the file descriptor <tt><i>fd</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>fd</i></tt> must be a nonnegative exact integer and should be a valid
open file descriptor.
If <tt><i>?transcoder</i></tt> is present and not <tt>#f</tt>, it must be a
transcoder, and this procedure returns a textual output port
whose transcoder is <tt><i>?transcoder</i></tt>.
Otherwise, this procedure returns a binary output port.
See the lead-in to Section&nbsp;<a href="http://scheme.com/tspl4/./io.html#g123">7.2</a> of <i>The Scheme Programming Language, 4th Edition</i>
for a description of the constraints on and effects of the other
arguments.

<p>
The file descriptor is closed when the port is closed.

<p>
<a name="./io:s83"></a><span class=formdef><b>procedure</b>: <tt>(standard-output-port)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(standard-output-port&nbsp;<i>b-mode</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(standard-output-port&nbsp;<i>b-mode</i>&nbsp;<i>?transcoder</i>)</tt></span>
<br>
<b>returns: </b>a new output port connected to the process's standard output
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>?transcoder</i></tt> is present and not <tt>#f</tt>, it must be a
transcoder, and this procedure returns a textual output port
whose transcoder is <tt><i>?transcoder</i></tt>.
Otherwise, this procedure returns a binary output port.
The buffer mode <tt><i>b-mode</i></tt> defaults to <tt>line</tt>, which differs from
<tt>block</tt> in <i>Chez&nbsp;Scheme</i> only for textual output ports.

<p>
The Revised<sup>6</sup> Report version of this procedure does not accept the
optional <tt><i>b-mode</i></tt> and <tt><i>?transcoder</i></tt> arguments, which limits
it to an implementation-dependent buffering mode (<tt>line</tt> in
<i>Chez&nbsp;Scheme</i>) and binary output.


<p>
<a name="./io:s84"></a><span class=formdef><b>procedure</b>: <tt>(standard-error-port)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(standard-error-port&nbsp;<i>b-mode</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(standard-error-port&nbsp;<i>b-mode</i>&nbsp;<i>?transcoder</i>)</tt></span>
<br>
<b>returns: </b>a new output port connected to the process's standard error
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>?transcoder</i></tt> is present and not <tt>#f</tt>, it must be a
transcoder, and this procedure returns a textual output port
whose transcoder is <tt><i>?transcoder</i></tt>.
Otherwise, this procedure returns a binary output port.
The buffer mode <tt><i>b-mode</i></tt> defaults to <tt>none</tt>.
See the lead-in to Section&nbsp;<a href="http://scheme.com/tspl4/./io.html#g123">7.2</a> of <i>The Scheme Programming Language, 4th Edition</i>
for a description of the constraints on and effects of the other
arguments.

<p>
The Revised<sup>6</sup> Report version of this procedure does not accept the
optional <tt><i>b-mode</i></tt> and <tt><i>?transcoder</i></tt> arguments, which limits
it to an implementation-dependent buffering mode (<tt>none</tt> in
<i>Chez&nbsp;Scheme</i>) and binary output.


<p>
<a name="./io:s85"></a><span class=formdef><b>procedure</b>: <tt>(put-bytevector-some&nbsp;<i>binary-output-port</i>&nbsp;<i>bytevector</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(put-bytevector-some&nbsp;<i>binary-output-port</i>&nbsp;<i>bytevector</i>&nbsp;<i>start</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(put-bytevector-some&nbsp;<i>binary-output-port</i>&nbsp;<i>bytevector</i>&nbsp;<i>start</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the number of bytes written
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>start</i></tt> and <tt><i>n</i></tt> must be nonnegative exact integers, and the sum of
<tt><i>start</i></tt> and <tt><i>n</i></tt> must not exceed the length of <tt><i>bytevector</i></tt>.
If not supplied, <tt><i>start</i></tt> defaults to zero and <tt><i>n</i></tt> defaults to
the difference between the length of <tt><i>bytevector</i></tt> and <tt><i>start</i></tt>.

<p>
This procedure normally writes the <tt><i>n</i></tt> bytes of <tt><i>bytevector</i></tt>
starting at <tt><i>start</i></tt> to the port and advances the its position past the
end of the bytes written.
If the port is in nonblocking mode (see <tt>set-port-nonblocking!</tt>),
however, the number of bytes written may be less than <tt><i>n</i></tt>, if
the system would have to block to write more bytes.


<p>
<a name="./io:s86"></a><span class=formdef><b>procedure</b>: <tt>(put-string-some&nbsp;<i>textual-output-port</i>&nbsp;<i>string</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(put-string-some&nbsp;<i>textual-output-port</i>&nbsp;<i>string</i>&nbsp;<i>start</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(put-string-some&nbsp;<i>textual-output-port</i>&nbsp;<i>string</i>&nbsp;<i>start</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the number of characters written
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>start</i></tt> and <tt><i>n</i></tt> must be nonnegative exact integers, and the sum of
<tt><i>start</i></tt> and <tt><i>n</i></tt> must not exceed the length of <tt><i>string</i></tt>.
If not supplied, <tt><i>start</i></tt> defaults to zero and <tt><i>n</i></tt> defaults to
the difference between the length of <tt><i>string</i></tt> and <tt><i>start</i></tt>.

<p>
This procedure normally writes the <tt><i>n</i></tt> characters of <tt><i>string</i></tt>
starting at <tt><i>start</i></tt> to the port and advances the its position past the
end of the characters written.
If the port is in nonblocking mode (see <tt>set-port-nonblocking!</tt>),
however, the number of characters written may be less than <tt><i>n</i></tt>, if
the system would have to block to write more characters.


<p>
<a name="./io:s87"></a><span class=formdef><b>procedure</b>: <tt>(display-string&nbsp;<i>string</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(display-string&nbsp;<i>string</i>&nbsp;<i>textual-output-port</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>display-string</tt> writes the characters contained within
<tt><i>string</i></tt> to <tt><i>textual-output-port</i></tt> or to the current-output port 
if <tt>textual-output-port</tt> is not specified.
The enclosing string quotes are not printed, and special characters
within the string are not escaped.
<tt>display-string</tt> is a more efficient alternative to
<tt>display</tt> for displaying strings.

<p>
<a name="./io:s88"></a><span class=formdef><b>procedure</b>: <tt>(block-write&nbsp;<i>textual-output-port</i>&nbsp;<i>string</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(block-write&nbsp;<i>textual-output-port</i>&nbsp;<i>string</i>&nbsp;<i>count</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>count</i></tt> must be a nonnegative fixnum less than or equal to the
length of <tt><i>string</i></tt>.
If not provided, it defaults to the length of <tt><i>string</i></tt>.

<p>
<tt>block-write</tt> writes the first <tt><i>count</i></tt> characters of <tt><i>string</i></tt>
to <tt><i>textual-output-port</i></tt>.
If the port is buffered and the buffer is nonempty, the
buffer is flushed before the contents of <tt><i>string</i></tt> are written.
In any case, the contents of <tt><i>string</i></tt> are written immediately,
without passing through the buffer.

<p>
<a name="./io:s89"></a><span class=formdef><b>procedure</b>: <tt>(truncate-port&nbsp;<i>output-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(truncate-port&nbsp;<i>output-port</i>&nbsp;<i>pos</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(truncate-file&nbsp;<i>output-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(truncate-file&nbsp;<i>output-port</i>&nbsp;<i>pos</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>truncate-port</tt> and <tt>truncate-file</tt> are identical.

<p>
<tt><i>pos</i></tt> must be an exact nonnegative integer.  It defaults to 0.

<p>
These procedures truncate the file or other object associated with
<tt><i>output-port</i></tt> to <tt><i>pos</i></tt> and repositions the port
to that position, i.e., it combines the functionality of
<tt>set-port-length!</tt> and <tt>set-port-position!</tt> and
can be called on a port only if <tt>port-has-set-port-length!?</tt> and
<tt>port-has-set-port-position!?</tt> are both true of the port.


<p>
<a name="./io:s90"></a><a name="desc:fresh-line"></a>
<span class=formdef><b>procedure</b>: <tt>(fresh-line)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fresh-line&nbsp;<i>textual-output-port</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>textual-output-port</i></tt> is not supplied, it defaults to the current output port.

<p>
This procedure behaves like <tt>newline</tt>, i.e., sends a newline
character to <tt><i>textual-output-port</i></tt>, unless it can determine that the port
is already positioned at the start of a line.
It does this by flushing the port and consulting the
"beginning-of-line" (BOL) flag associated with the port.
(See page&nbsp;<a href="./io.html#desc:set-port-bol">253</a>.)


<p>

<h3><a name="g87"></a><a name="./io:h10"></a>Section 9.10. Input/Output Operations<a name="SECTIOINPUTOUTPUT"></a></h3>



<p>
<a name="./io:s91"></a><span class=formdef><b>procedure</b>: <tt>(open-input-output-file&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(open-input-output-file&nbsp;<i>path</i>&nbsp;<i>options</i>)</tt></span>
<br>
<b>returns: </b>a new input-output port
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt>open-input-output-file</tt> opens a textual input-output port for the file named by
<tt><i>path</i></tt>.

<p>
The port may be used to read from or write to the named file.
The file is created if it does not already exist.

<p>
<tt><i>options</i></tt>, if present, is a symbolic option name or option list.
Possible symbolic option names are 
<tt>buffered</tt>,
<tt>unbuffered</tt>, <tt>exclusive</tt>, and <tt>nonexclusive</tt>.
An option list is a list containing zero or more symbolic option names
and possibly the two-element
option <tt>mode&nbsp;<i>mode</i></tt>.
See the description of <tt>open-output-file</tt> for an explanation
of these options.

<p>
Input/output files are usually closed using <tt>close-port</tt>
but may also be closed with either
<tt>close-input-port</tt> or
<tt>close-output-port</tt>.

<p>
<a name="./io:s92"></a><span class=formdef><b>procedure</b>: <tt>(open-fd-input/output-port&nbsp;<i>fd</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(open-fd-input/output-port&nbsp;<i>fd</i>&nbsp;<i>b-mode</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(open-fd-input/output-port&nbsp;<i>fd</i>&nbsp;<i>b-mode</i>&nbsp;<i>?transcoder</i>)</tt></span>
<br>
<b>returns: </b>a new input/output port for the file descriptor <tt><i>fd</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>fd</i></tt> must be a nonnegative exact integer and should be a valid
open file descriptor.
If <tt><i>?transcoder</i></tt> is present and not <tt>#f</tt>, it must be a
transcoder, and this procedure returns a textual input/output port
whose transcoder is <tt><i>?transcoder</i></tt>.
Otherwise, this procedure returns a binary input/output port.
See the lead-in to Section&nbsp;<a href="http://scheme.com/tspl4/./io.html#g123">7.2</a> of <i>The Scheme Programming Language, 4th Edition</i>
for a description of the constraints on and effects of the other
arguments.

<p>
The file descriptor is closed when the port is closed.


<p>

<h3><a name="g88"></a><a name="./io:h11"></a>Section 9.11. Non-Unicode Bytevector/String Conversions<a name="SECTMBCONVS"></a></h3>



<p>
The procedures described in this section convert bytevectors containing
single- and multiple-byte sequences in non-Unicode character sets to and
from Scheme strings.
They are available only under Windows.
Under other operating systems, and when an <tt>iconv</tt> DLL is
available under Windows, <tt>bytevector-&gt;string</tt> and
<tt>string-&gt;bytevector</tt> can be used with a transcoder based
on a codec constructed via
<a name="./io:s93"></a><tt>iconv-codec</tt>
to achieve the same results, with more control over the handling
of invalid characters and line endings.

<p>
<a name="./io:s94"></a><span class=formdef><b>procedure</b>: <tt>(multibyte-&gt;string&nbsp;<i>code-page</i>&nbsp;<i>bytevector</i>)</tt></span>
<br>
<b>returns: </b>a string containing the characters encoded in <tt><i>bytevector</i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(string-&gt;multibyte&nbsp;<i>code-page</i>&nbsp;<i>string</i>)</tt></span>
<br>
<b>returns: </b>a bytevector containing the encodings of the characters in <tt><i>string</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These procedures are available only under Windows.
The procedure <tt>multibyte-&gt;string</tt> is a wrapper for the Windows API
<tt>MultiByteToWideChar</tt> function,
and <tt>string-&gt;multibyte</tt> is a wrapper for the Windows API
<tt>WideCharToMultiByte</tt> function.

<p>
<tt><i>code-page</i></tt> declares the encoding of the byte sequences in the input
or output bytevectors.
It must be an exact nonnegative integer identifying a code page or one of
the symbols <tt>cp-acp</tt>, <tt>cp-maccp</tt>, <tt>cp-oemcp</tt>,
<tt>cp-symbol</tt>, <tt>cp-thread-acp</tt>, <tt>cp-utf7</tt>, or
<tt>cp-utf8</tt>, which have the same meanings as the API function
meanings for the like-named constants.

<p>

<h3><a name="g89"></a><a name="./io:h12"></a>Section 9.12. Pretty Printing<a name="SECTPRETTY"></a></h3>



<p>
The pretty printer is a version of the <tt>write</tt> procedure that
produces more human-readable output via introduced whitespace, i.e.,
line breaks and indentation.
The pretty printer is the default printer used by the read-eval-print
loop (waiter) to print the output(s) of each evaluated form.
The pretty printer may also be invoked explicitly by calling the
procedure <tt>pretty-print</tt>.

<p>
The pretty printer's operation can be controlled via the <tt>pretty-format</tt>
procedure described later in this section, which allows the
programmer to specify how specific forms are to be printed, various
pretty-printer controls, also described later in this section, and also
by the generic input/output controls described in Section&nbsp;<a href="./io.html#g91">9.14</a>.

<p>
<a name="./io:s95"></a><span class=formdef><b>procedure</b>: <tt>(pretty-print&nbsp;<i>obj</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(pretty-print&nbsp;<i>obj</i>&nbsp;<i>textual-output-port</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>textual-output-port</i></tt> is not supplied, it defaults to the current output port.

<p>
<tt>pretty-print</tt> is similar to <tt>write</tt> except that it uses
any number of spaces and newlines in order to print <tt><i>obj</i></tt> in a
style that is pleasing to look at and which shows the nesting level via
indentation.
For example,

<p>

<p><tt>(pretty-print&nbsp;'(define&nbsp;factorial&nbsp;(lambda&nbsp;(n)&nbsp;(let&nbsp;fact&nbsp;((i&nbsp;n)&nbsp;(a&nbsp;1))<br>

&nbsp;&nbsp;(if&nbsp;(=&nbsp;i&nbsp;0)&nbsp;a&nbsp;(fact&nbsp;(-&nbsp;i&nbsp;1)&nbsp;(*&nbsp;a&nbsp;i)))))))</tt>
<p>might produce

<p>

<p><tt>(define&nbsp;factorial<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;fact&nbsp;([i&nbsp;n]&nbsp;[a&nbsp;1])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;i&nbsp;0)&nbsp;a&nbsp;(fact&nbsp;(-&nbsp;i&nbsp;1)&nbsp;(*&nbsp;a&nbsp;i))))))</tt>
<p><a name="./io:s96"></a><span class=formdef><b>procedure</b>: <tt>(pretty-file&nbsp;<i>ifn</i>&nbsp;<i>ofn</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>ifn</i></tt> and <tt><i>ofn</i></tt> must be strings.
<tt>pretty-file</tt> reads each object in turn from the file named by
<tt><i>ifn</i></tt> and pretty prints the object to the file named by <tt><i>ofn</i></tt>.
Comments present in the input are discarded by the reader and so do
not appear in the output file.
If the file named by <tt><i>ofn</i></tt> already exists, it is replaced.

<p>
<a name="./io:s97"></a><span class=formdef><b>procedure</b>: <tt>(pretty-format&nbsp;<i>sym</i>)</tt></span>
<br>
<b>returns: </b>see below
<br><span class=formdef><b>procedure</b>: <tt>(pretty-format&nbsp;<i>sym</i>&nbsp;<i>fmt</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>By default, the pretty printer uses a generic algorithm for printing
each form.
This procedure is used to override this default and guide the
pretty-printers treatment of specific forms.
The symbol <tt><i>sym</i></tt> names a syntactic form or procedure.
With just one argument, <tt>pretty-format</tt> returns the current
format associated with <tt><i>sym</i></tt>, or <tt>#f</tt> if no format is
associated with <tt><i>sym</i></tt>.

<p>
In the two-argument case, the format <tt><i>fmt</i></tt> is associated with
<tt><i>sym</i></tt> for future invocations of the pretty printer.
<tt><i>fmt</i></tt> must be in the formatting language described below.

<p>

  
  
  <table><tr><td nowrap>
&lt;fmt&gt;</td><td align=center><img src="math/csug/2.gif" alt="<graphic>"></td><td nowrap><tt>(quote&nbsp;<i>symbol</i>)</tt></td></tr><tr><td nowrap>
  </td><td align=center>|</td><td nowrap><tt>var</tt></td></tr><tr><td nowrap>
  </td><td align=center>|</td><td nowrap><tt><i>symbol</i></tt></td></tr><tr><td nowrap>
  </td><td align=center>|</td><td nowrap><tt>(read-macro&nbsp;<i>string</i>&nbsp;<i>symbol</i>)</tt></td></tr><tr><td nowrap>
  </td><td align=center>|</td><td nowrap><tt>(meta)</tt></td></tr><tr><td nowrap>
  </td><td align=center>|</td><td nowrap><tt>(bracket&nbsp;.&nbsp;<i>fmt-tail</i>)</tt></td></tr><tr><td nowrap>
  </td><td align=center>|</td><td nowrap><tt>(alt&nbsp;<i>fmt</i>&nbsp;<i>fmt</i>*)</tt></td></tr><tr><td nowrap>
  </td><td align=center>|</td><td nowrap><tt><i>fmt-tail</i></tt></td></tr><tr><td nowrap>
<tt><i>fmt-tail</i></tt></td><td align=center><img src="math/csug/2.gif" alt="<graphic>"></td><td nowrap><tt>()</tt></td></tr><tr><td nowrap>
  </td><td align=center>|</td><td nowrap><tt>(<i>tab</i>&nbsp;<i>fmt</i>&nbsp;...)</tt></td></tr><tr><td nowrap>
  </td><td align=center>|</td><td nowrap><tt>(<i>fmt</i>&nbsp;<i>tab</i>&nbsp;...)</tt></td></tr><tr><td nowrap>
  </td><td align=center>|</td><td nowrap><tt>(<i>tab</i>&nbsp;<i>fmt</i>&nbsp;.&nbsp;<i>fmt-tail</i>)</tt></td></tr><tr><td nowrap>
  </td><td align=center>|</td><td nowrap><tt>(<i>fmt</i>&nbsp;...)</tt></td></tr><tr><td nowrap>
  </td><td align=center>|</td><td nowrap><tt>(<i>fmt</i>&nbsp;.&nbsp;<i>fmt-tail</i>)</tt></td></tr><tr><td nowrap>
  </td><td align=center>|</td><td nowrap><tt>(fill&nbsp;<i>tab</i>&nbsp;<i>fmt</i>&nbsp;...)</tt></td></tr><tr><td nowrap>
<tt><i>tab</i></tt></td><td align=center><img src="math/csug/2.gif" alt="<graphic>"></td><td nowrap><tt><i>int</i></tt></td></tr><tr><td nowrap>
  </td><td align=center>|</td><td nowrap><tt>#f</tt>
</td></tr></table>

<p>
Some of the format forms are used for matching when there are multiple
alternatives, while others are used for matching and control indentation
or printing.
A description of each <tt><i>fmt</i></tt> is given below.

<p>
<dl compact>
<dt><tt>(quote&nbsp;<i>symbol</i>)</tt>:<dd>
This matches only the symbol <tt><i>symbol</i></tt>.

<p>
<dt><tt>var</tt>:<dd>
This matches any symbol.

<p>
<dt><tt><i>symbol</i></tt>:<dd>
This matches any input.

<p>
<dt><tt>(read-macro&nbsp;<i>string</i>&nbsp;<i>symbol</i>)</tt>:<dd>
This is used for read macros like <tt>quote</tt> and <tt><i>syntax</i></tt>.
It matches any input of the form (<tt><i>symbol</i></tt> <tt><i>subform</i></tt>).
For forms that match, the pretty printer prints
<tt><i>string</i></tt> immediately followed by <tt><i>subform</i></tt>.

<p>
<dt><tt>(meta)</tt>:<dd>
This is a special case used for the <tt>meta</tt> keyword
(Section&nbsp;<a href="./syntax.html#g111">11.8</a>) which is used as a keyword prefix of
another form.

<p>
<dt><tt>(alt&nbsp;<i>fmt</i>&nbsp;<i>fmt</i>*)</tt>:<dd>
This compares the input against the specified formats and uses the
one that is the closest match.
Most often, one of the formats will match exactly, but in other
cases, as when input is malformed or appears in abstract form in the
template of a syntactic abstraction, none of the formats will match
exactly.

<p>
<dt><tt>(bracket&nbsp;.&nbsp;<i>fmt-tail</i>)</tt>:<dd>
This matches any list-structured input and prints the input enclosed
in square brackets, i.e.,
<a name="./io:s98"></a><tt>[</tt> and <a name="./io:s99"></a><tt>]</tt>,
rather than parentheses.

<p>
<dt><tt><i>fmt-tail</i></tt>:<dd>
This matches any list-structured input.
</dl>

<p>
Indentation of list-structured forms is determined via the
<tt><i>fmt-tail</i></tt> specifier used to the last two cases above.
A description of each <tt><i>fmt-tail</i></tt> is given below.

<p>
<dl compact>
<dt><tt>()</tt>:<dd>
This matches an empty list tail.

<p>
<dt><tt>(<i>tab</i>&nbsp;<i>fmt</i>&nbsp;...)</tt>:<dd>
This matches the tail of any proper list; if the tail is nonempty
and the list does not fit entirely on the current line, a line break is
inserted before the first subform of the tail and <tt><i>tab</i></tt> (see
below) determines the amount by which this and all subsequent subforms
are indented.

<p>
<dt><tt>(<i>fmt</i>&nbsp;<i>tab</i>&nbsp;...)</tt>:<dd>
This matches the tail of any proper list; if the tail is nonempty
and the list does not fit entirely on the current line, a line break is
inserted after the first subform of the tail and <tt><i>tab</i></tt> (see
below) determines the amount by which all subsequent subforms are
indented.

<p>
<dt><tt>(<i>tab</i>&nbsp;<i>fmt</i>&nbsp;.&nbsp;<i>fmt-tail</i>)</tt>:<dd>
This matches a nonempty tail if the tail of the tail matches <tt><i>fmt-tail</i></tt>.
If the list does not fit entirely on the current line, a line break is
inserted before the first subform of the tail and <tt><i>tab</i></tt> (see
below) determines the amount by which the subform is indented.

<p>
<dt><tt>(<i>fmt</i>&nbsp;...)</tt>:<dd>
This matches the tail of any proper list and specified that no
line breaks are to be inserted before or after the current or
subsequent subforms.

<p>
<dt><tt>(<i>fmt</i>&nbsp;.&nbsp;<i>fmt-tail</i>)</tt>:<dd>
This matches a nonempty tail if the tail of the tail matches <tt><i>fmt-tail</i></tt>
and specifies that no line break is to be inserted before or after
the current subform.

<p>
<dt><tt>(fill&nbsp;<i>tab</i>&nbsp;<i>fmt</i>&nbsp;...)</tt>:<dd>
This matches the tail of any proper list and invokes a fill mode in
which the forms are packed with as many as will fit on each line.
</dl>

<p>
A <tt><i>tab</i></tt> determines the amount by which a list subform is indented.
If <tt><i>tab</i></tt> is a nonnegative exact integer <tt><i>int</i></tt>, the subform
is indented <tt><i>int</i></tt> spaces in from the character position just after
the opening parenthesis or bracket of the parent form.
If <tt><i>tab</i></tt> is <tt>#f</tt>, the standard indentation is used.
The standard indentation can be determined or changed via the parameter
<tt>pretty-standard-indent</tt>, which is described later in this
section.

<p>
In cases where a format is given that doesn't quite match, the pretty
printer tries to use the given format as far as it can.
For example, if a format matches a list-structured form with a specific
number of subforms, but more or fewer subform are given, the pretty
printer will discard or replicate subform formats as necessary.

<p>
Here is an example showing the formatting of <tt><i>let</i></tt> might be specified.

<p>

<p><tt>(pretty-format&nbsp;'let<br>

&nbsp;&nbsp;'(alt&nbsp;(let&nbsp;([bracket&nbsp;var&nbsp;x]&nbsp;0&nbsp;...)&nbsp;#f&nbsp;e&nbsp;#f&nbsp;e&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;var&nbsp;([bracket&nbsp;var&nbsp;x]&nbsp;0&nbsp;...)&nbsp;#f&nbsp;e&nbsp;#f&nbsp;e&nbsp;...)))</tt>
<p>Since <tt>let</tt> comes in two forms, named and unnamed, two alternatives
are specified.
In either case, the <tt>bracket</tt> <tt><i>fmt</i></tt> is used to enclose the
bindings in square brackets, with all bindings after the first appearing
just below the first (and just after the enclosing opening parenthesis),
if they don't all fit on one line.
Each body form is indented by the standard indentation.

<p>
<a name="./io:s100"></a><span class=formdef><b>thread parameter</b>: <tt>pretty-line-length</tt></span>
<br><span class=formdef><b>thread parameter</b>: <tt>pretty-one-line-limit</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of each of these parameters must be a positive fixnum.

<p>
The parameters <tt>pretty-line-length</tt> and
<tt>pretty-one-line-limit</tt> control the output produced by
<a name="./io:s101"></a><tt>pretty-print</tt>.
<tt>pretty-line-length</tt> determines after which character position (starting
from the first) on a line the pretty printer attempts to cut off output.
This is a soft limit only; if necessary, the pretty-printer will go beyond
<tt>pretty-line-length</tt>.

<p>
<tt>pretty-one-line-limit</tt> is similar to
<tt>pretty-line-length</tt>, except that it is relative to the first
nonblank position on each line of output.
It is also a soft limit.


<p>
<a name="./io:s102"></a><span class=formdef><b>thread parameter</b>: <tt>pretty-initial-indent</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of this parameter must be a nonnegative fixnum.

<p>
The parameter <tt>pretty-initial-indent</tt> is used to tell
<a name="./io:s103"></a><tt>pretty-print</tt> where on an output
line it has been called.
If <tt>pretty-initial-indent</tt> is zero (the default), <tt>pretty-print</tt>
assumes that the first line of output it produces will start at the
beginning of the line.
If set to a nonzero value <tt><i>n</i></tt>, <tt>pretty-print</tt> assumes that the first
line will appear at character position <tt><i>n</i></tt> and will adjust its
printing of subsequent lines.


<p>
<a name="./io:s104"></a><span class=formdef><b>thread parameter</b>: <tt>pretty-standard-indent</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of this parameter must be a nonnegative fixnum.

<p>
This determines the amount by which
<tt>pretty-print</tt> indents subexpressions of most forms, such as <tt>let</tt>
expressions, from the form's keyword or first subexpression.


<p>
<a name="./io:s105"></a><span class=formdef><b>thread parameter</b>: <tt>pretty-maximum-lines</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The parameter <tt>pretty-maximum-lines</tt> controls how many lines
<tt>pretty-print</tt> prints when it is called.
If set to <tt>#f</tt> (the default), no limit is imposed; if set to a
nonnegative fixnum <tt><i>n</i></tt>, at most <tt><i>n</i></tt> lines are printed.


<p>

<h3><a name="g90"></a><a name="./io:h13"></a>Section 9.13. Formatted Output<a name="SECTFORMAT"></a></h3>



<p>
<a name="./io:s106"></a><span class=formdef><b>procedure</b>: <tt>(format&nbsp;<i>format-string</i>&nbsp;<i>obj</i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(format&nbsp;#f&nbsp;<i>format-string</i>&nbsp;<i>obj</i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(format&nbsp;#t&nbsp;<i>format-string</i>&nbsp;<i>obj</i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(format&nbsp;<i>textual-output-port</i>&nbsp;<i>format-string</i>&nbsp;<i>obj</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./io:s107"></a>When the first argument to format is a string or <tt>#f</tt> (first and
second forms above),
<tt>format</tt> constructs an output string from <tt><i>format-string</i></tt> and the
objects <tt><i>obj</i>&nbsp;...</tt>.
Characters are copied from <tt><i>format-string</i></tt> to the output string from
left to right, until <tt><i>format-string</i></tt> is exhausted.
The format string may contain one or more <tt><i>format directives</i></tt>, which are
multi-character sequences prefixed by a tilde (&nbsp;<tt>~</tt>&nbsp;).
Each directive is replaced by some other text, often involving one or more
of the <tt><i>obj</i>&nbsp;...</tt> arguments, as determined by the semantics
of the directive.

<p>
When the first argument is <tt>#t</tt>, output is sent to the current output
port instead, as with <tt>printf</tt>.
When the first argument is a port, output is sent to that port, as with
<tt>fprintf</tt>.
<tt>printf</tt> and <tt>fprintf</tt> are described later in this section.

<p>
<i>Chez&nbsp;Scheme</i>'s implementation of <tt>format</tt> supports all of the
Common Lisp&nbsp;[<a class=citation href="./bibliography.html#g190">30</a>] format directives except for those specific
to the Common Lisp pretty printer.
Please consult a Common Lisp reference or the
<a  href=http://www.lispworks.com/documentation/HyperSpec/Front/index.htm>Common Lisp Hyperspec</a>,
for complete documentation.
A few of the most useful directives are described below.


<p>
Absent any format directives, <tt>format</tt> simply displays its string
argument.

<p>

<p><tt>(format&nbsp;"hi&nbsp;there")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"hi&nbsp;there"</tt>
<p>The <tt>~s</tt> directive is replaced by the printed representation of
the next <tt><i>obj</i></tt>, which may be any object, in machine-readable format,
as with <tt>write</tt>.

<p>

<p><tt>(format&nbsp;"hi&nbsp;~s"&nbsp;'mom)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"hi&nbsp;mom"<br>

(format&nbsp;"hi&nbsp;~s"&nbsp;"mom")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"hi&nbsp;\"mom\""<br>

(format&nbsp;"hi&nbsp;~s~s"&nbsp;'mom&nbsp;#\!)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"hi&nbsp;mom#\\!"</tt>
<p>The general form of a <tt>~s</tt> directive is actually
<tt>~<i>mincol</i>,<i>colinc</i>,<i>minpad</i>,<i>padchar</i>s</tt>,
and the <tt>s</tt> can be preceded by an at sign (&nbsp;<tt>@</tt>&nbsp;)
modifier.
These additional parameters are used to control padding in the
output, with at least <tt><i>minpad</i></tt> copies of <tt><i>padchar</i></tt>
plus an integer multiple of <tt><i>colinc</i></tt> copies of <tt><i>padchar</i></tt>
to make the total width, including the written object,
<tt><i>mincol</i></tt> characters wide.
The padding is placed on the left if the <tt><i>@</i></tt> modifier is
present, otherwise on the right.
<tt><i>mincol</i></tt> and <tt><i>minpad</i></tt> default to 0, <tt><i>colinc</i></tt> defaults
to 1, and <tt><i>padchar</i></tt> defaults to space.
If specified, <tt><i>padchar</i></tt> is prefixed by a single quote mark.

<p>

<p><tt>(format&nbsp;"~10s"&nbsp;'hello)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"hello&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"<br>

(format&nbsp;"~10@s"&nbsp;'hello)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hello"<br>

(format&nbsp;"~10,,,'*@s"&nbsp;'hello)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"*****hello"</tt>
<p>The <tt>~a</tt> directive is similar, but prints the object as with
<tt>display</tt>.

<p>

<p><tt>(format&nbsp;"hi&nbsp;~s~s"&nbsp;"mom"&nbsp;#\!)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"hi&nbsp;\"mom\"#\\!"<br>

(format&nbsp;"hi&nbsp;~a~a"&nbsp;"mom"&nbsp;#\!)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"hi&nbsp;mom!"</tt>
<p>A tilde may be inserted into the output with <tt>~~</tt>, and a newline
may be inserted with <tt>~%</tt> (or embedded in the string with
<tt>\n</tt>).

<p>

<p><tt>(format&nbsp;"~~line&nbsp;one,~%line&nbsp;two.~~")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"~line&nbsp;one,\nline&nbsp;two.~"<br>

(format&nbsp;"~~line&nbsp;one,\nline&nbsp;two.~~")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"~line&nbsp;one,\nline&nbsp;two.~"</tt>
<p>Real numbers may be printed in floating-point notation with <tt>~f</tt>.

<p>

<p><tt>(format&nbsp;"~f"&nbsp;3.14159)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3.14159</tt>
<p>Exact numbers may printed as well as inexact numbers in this manner; they
are simply converted to inexact first as if with <tt>exact-&gt;inexact</tt>.

<p>

<p><tt>(format&nbsp;"~f"&nbsp;1/3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"0.3333333333333333"</tt>
<p>The general form is actually <tt>~<i>w</i>,<i>d</i>,<i>k</i>,<i>overflowchar</i>,<i>padchar</i>f</tt>.
If specified, <tt><i>w</i></tt> determines the overall width of the output,
and <tt><i>d</i></tt> the number of digits to the right of the decimal point.
<tt><i>padchar</i></tt>, which defaults to space, is the pad character used
if padding is needed.
Padding is always inserted on the left.
The number is scaled by 10<sup>k</sup> when printed; <tt><i>k</i></tt> defaults to zero.
The entire <tt><i>w</i></tt>-character field is filled with copies of
<tt><i>overflowchar</i></tt> if <tt><i>overflowchar</i></tt> is specified and the number
cannot be printed in <tt><i>w</i></tt> characters.
<tt><i>k</i></tt> defaults to 1
If an <tt>@</tt> modifier is present, a plus sign is printed before the
number for nonnegative inputs; otherwise, a sign is printed only if the
number is negative.

<p>

<p><tt>(format&nbsp;"~,3f"&nbsp;3.14159)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"3.142"<br>

(format&nbsp;"~10f"&nbsp;3.14159)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"&nbsp;&nbsp;&nbsp;3.14159"<br>

(format&nbsp;"~10,,,'#f"&nbsp;1e20)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"##########"</tt>
<p>Real numbers may also be printed with <tt>~e</tt> for scientific
notation or with <tt>~g</tt>, which uses either floating-point or
scientific notation based on the size of the input.

<p>

<p><tt>(format&nbsp;"~e"&nbsp;1e23)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"1.0e+23"<br>

(format&nbsp;"~g"&nbsp;1e23)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"1.0e+23"</tt>
<p>A real number may also be printed with <tt>~$</tt>, which uses
monetary notation defaulting to two digits to the right of the
decimal point.

<p>

<p><tt>(format&nbsp;"$~$"&nbsp;(*&nbsp;39.95&nbsp;1.06))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"$42.35"<br>

(format&nbsp;"~$USD"&nbsp;1/3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"0.33USD"</tt>
<p>Words can be pluralized automatically using <tt>p</tt>.

<p><tt>(format&nbsp;"~s&nbsp;bear~:p&nbsp;in&nbsp;~s&nbsp;den~:p"&nbsp;10&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"10&nbsp;bears&nbsp;in&nbsp;1&nbsp;den"</tt>
<p>Numbers may be printed out in words or roman numerals using variations
on <tt>~r</tt>.

<p>

<p><tt>(format&nbsp;"~r"&nbsp;2599)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;&nbsp;"two&nbsp;thousand&nbsp;five&nbsp;hundred&nbsp;ninety-nine"<br>

(format&nbsp;"~:r"&nbsp;99)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;&nbsp;"ninety-ninth"<br>

(format&nbsp;"~@r"&nbsp;2599)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"MMDXCIX"</tt>
<p>Case conversions can be performed by bracketing a portion of the
format string with the <tt>~@(</tt> and <tt>~)</tt> directives.

<p>

<p><tt>(format&nbsp;"~@(~r~)"&nbsp;2599)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;&nbsp;"Two&nbsp;thousand&nbsp;five&nbsp;hundred&nbsp;ninety-nine"<br>

(format&nbsp;"~@:(~a~)"&nbsp;"Ouch!")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;&nbsp;"OUCH!"</tt>
<p>Some of the directives shown above have more options and parameters, and 
there are other directives as well, including directives for conditionals,
iteration, indirection, and justification.
Again, please consult a Common Lisp reference for complete documentation.

<p>
An implementation of a greatly simplified version of <tt>format</tt>
appears in Section&nbsp;<a href="http://scheme.com/tspl4/./examples.html#g180">12.6</a> of <i>The Scheme Programming Language, 4th Edition</i>.


<p>
<a name="./io:s108"></a><span class=formdef><b>procedure</b>: <tt>(printf&nbsp;<i>format-string</i>&nbsp;<i>obj</i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fprintf&nbsp;<i>textual-output-port</i>&nbsp;<i>format-string</i>&nbsp;<i>obj</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These procedures are simple wrappers for <tt>format</tt>.
<tt>printf</tt> prints the formatted output to the current output,
as with a first-argument of <tt>#t</tt> to <tt>format</tt>, and
<tt>fprintf</tt> prints the formatted output to the <tt><i>textual-output-port</i></tt>,
as when the first argument to <tt>format</tt> is a port.

<p>

<h3><a name="g91"></a><a name="./io:h14"></a>Section 9.14. Input/Output Control Operations<a name="SECTMISCIOCONTROL"></a></h3>



<p>
The I/O control operations described in this section are used to
control how the reader reads and printer writes, displays, or
pretty-prints
characters,
symbols,
gensyms,
numbers,
vectors,
long or deeply nested lists or vectors,
and graph-structured objects.
 

<p>
<a name="./io:s109"></a><a name="desc:char-name"></a>
<span class=formdef><b>procedure</b>: <tt>(char-name&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>see below
<br><span class=formdef><b>procedure</b>: <tt>(char-name&nbsp;<i>name</i>&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>char-name</tt> is used to associate names (symbols) with characters
or to retrieve the most recently associated name or character for a 
given character or name.
A name can map to only one character, but more than one name
can map to the same character.
The name most recently associated with a character determines
how that character prints, and each name associated with a character
may be used after the <tt>#\</tt> character prefix to name that
character on input.

<p>
Character associations created by <tt>char-name</tt> are ignored by the
printer unless the parameter <tt>print-char-name</tt> is set to a true
value.
The reader recognizes character names established by <tt>char-name</tt>
except after <tt>#!r6rs</tt>, which is implied within a library or
R6RS top-level program.

<p>
In the one-argument form, <tt><i>obj</i></tt> must be a symbol or character.
If it is a symbol and a character is associated with the
symbol, <tt>char-name</tt> returns that character.
If it is a symbol and no character is associated with the symbol,
<tt>char-name</tt> returns <tt>#f</tt>.
Similarly, if <tt><i>obj</i></tt> is a character, <tt>char-name</tt> returns the
most recently associated symbol for the character or <tt>#f</tt> if
no name is associated with the character.
For example, with the default set of character names:

<p>

<p><tt>(char-name&nbsp;#\space)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;space<br>

(char-name&nbsp;'space)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#\space<br>

(char-name&nbsp;'nochar)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(char-name&nbsp;#\a)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>When passed two arguments, <tt><i>name</i></tt> is added to the set of names
associated with <tt><i>char</i></tt>, and any other association for <tt><i>name</i></tt>
is dropped.
<tt><i>char</i></tt> may be <tt>#f</tt>, in which case any other association
for <tt><i>name</i></tt> is dropped and no new association is formed.
In either case, any other names associated with <tt><i>char</i></tt> remain
associated with <tt><i>char</i></tt>.

<p>
The following interactive session demonstrates the use of
<tt>char-name</tt> to establish and remove associations between
characters and names, including the association of more than
one name with a character.

<p>

<p><tt>(print-char-name&nbsp;#t)<br>

(char-name&nbsp;'etx)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(char-name&nbsp;'etx&nbsp;#\x3)<br>

(char-name&nbsp;'etx)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#\etx<br>

(char-name&nbsp;#\x3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;etx<br>

#\etx&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#\etx<br>

(eq?&nbsp;#\etx&nbsp;#\x3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

#!r6rs&nbsp;#\etx&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;invalid&nbsp;character&nbsp;name&nbsp;etx</i><br>

#!chezscheme&nbsp;#\etx&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#\etx<br>

(char-name&nbsp;'etx&nbsp;#\space)<br>

(char-name&nbsp;#\x3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(char-name&nbsp;'etx)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#\etx<br>

#\space&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#\etx<br>

(char-name&nbsp;'etx&nbsp;#f)<br>

#\etx&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;invalid&nbsp;character&nbsp;name&nbsp;etx</i><br>

#\space&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#\space</tt>
<p>(When using the expression editor, it is necessary to type Control-J to
force the editor to read the erroneous <tt>#\etx</tt> input on the two
inputs above that result in read errors, since typing Enter
causes the expression editor to read the input only if the input is
well-formed.)

<p>
The reader does not recognize hex scalar value escapes in character names,
as it does in symbols, so <tt>#\new\x6c;ine</tt> is not equivalent
to <tt>#\newline</tt>.
In general, programmers should avoid the use of character name symbols
that cannot be entered without the use of hex scalar value escapes or
other symbol-name escape mechanisms, since such character names will
not be readable.


<p>
<a name="./io:s110"></a><span class=formdef><b>thread parameter</b>: <tt>print-char-name</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When <tt>print-char-name</tt> is set to <tt>#f</tt> (the default), associations
created by <tt>char-name</tt> are ignored by <tt>write</tt>,
<tt>put-datum</tt>, <tt>pretty-print</tt>, and the <tt>format</tt>
"<tt>~s</tt>" directive.
Otherwise, these procedures use the names established by
<tt>char-name</tt> when printing character objects.

<p>

<p><tt>(char-name&nbsp;'etx&nbsp;#\x3)<br>

(format&nbsp;"~s"&nbsp;#\x3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"#\\x3"<br>

(parameterize&nbsp;([print-char-name&nbsp;#t])<br>

&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;#\x3))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"#\\etx"</tt>
<p><a name="./io:s111"></a><span class=formdef><b>thread parameter</b>: <tt>case-sensitive</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The <tt>case-sensitive</tt> parameter determines whether the
reader is case-sensitive with respect to symbol and character names.
When set to true (the default, as required by the Revised<sup>6</sup> Report)
the case of alphabetic characters
within symbol names is significant.
When set to <tt>#f</tt>, case is insignificant.
More precisely, when set to <tt>#f</tt>, symbol and character names are
folded (as if by <tt>string-foldcase</tt>); otherwise, they are left
as they appear in the input.

<p>
The value of the <tt>case-sensitive</tt> matters only
if neither <tt>#!fold-case</tt> nor <tt>#!no-fold-case</tt> has appeared
previously in the same input stream.
That is, symbol and character name are folded if <tt>#!fold-case</tt> has
been seen.
They are not folded if <tt>#!no-fold-case</tt> has been seen.
If neither has been seen, they are folded if and only if
<tt>(case-sensitive)</tt> is <tt>#f</tt>.

<p>

<p><tt>(case-sensitive)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(eq?&nbsp;'abc&nbsp;'ABC)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

'ABC&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;ABC<br>

(case-sensitive&nbsp;#f)<br>

'ABC&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;abc<br>

(eq?&nbsp;'abc&nbsp;'ABC)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./io:s112"></a><span class=formdef><b>thread parameter</b>: <tt>print-graph</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When <tt>print-graph</tt> is set to a true value,
<tt>write</tt> and <tt>pretty-print</tt>
locate and print objects with shared structure, including
cycles, in a notation that may be read subsequently with <tt>read</tt>.
This notation employs the syntax
<a name="./io:s113"></a>"<tt>#<i>n</i>=<i>obj</i></tt>,"
where <tt><i>n</i></tt>
is a nonnegative integer and <tt><i>obj</i></tt> is the printed representation
of an object, to label the first occurrence of <tt><i>obj</i></tt> in the output.
The syntax
<a name="./io:s114"></a>"<tt>#<i>n</i>#</tt>"
is used to refer to the object labeled by
<tt><i>n</i></tt> thereafter in the output.
<tt>print-graph</tt> is set to <tt>#f</tt> by default.

<p>
If graph printing is not enabled,
the settings of <tt>print-length</tt> and <tt>print-level</tt>
are insufficient to force finite output,
and <tt>write</tt> or <tt>pretty-print</tt> detects a cycle in an
object it is given to print,
a warning is issued (an exception with condition type <tt>&amp;warning</tt> is
raised) and the object is printed as if
<tt>print-graph</tt> were enabled.

<p>
Since objects printed through the <tt>~s</tt> option in the format control
strings of <tt>format</tt>, <tt>printf</tt>, and <tt>fprintf</tt> are printed as with
<tt>write</tt>, the printing of such objects is also affected by <tt>print-graph</tt>.

<p>

<p><tt>(parameterize&nbsp;([print-graph&nbsp;#t])<br>

&nbsp;&nbsp;(let&nbsp;([x&nbsp;(list&nbsp;'a&nbsp;'b)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;(list&nbsp;x&nbsp;x))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"(#0=(a&nbsp;b)&nbsp;#0#)"
<br>
<br>
(parameterize&nbsp;([print-graph&nbsp;#t])<br>

&nbsp;&nbsp;(let&nbsp;([x&nbsp;(list&nbsp;'a&nbsp;'b)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set-car!&nbsp;x&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;x&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;x)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"#0=(#0#&nbsp;.&nbsp;#0#)"</tt>
<p>The graph syntax is understood by the procedure
<a name="./io:s115"></a><tt>read</tt>, allowing graph structures
to be printed and read consistently.


<p>
<a name="./io:s116"></a><span class=formdef><b>thread parameter</b>: <tt>print-level</tt></span>
<br><span class=formdef><b>thread parameter</b>: <tt>print-length</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These parameters can be used to limit the extent to which nested
or multiple-element structures are printed.
When called without arguments, <tt>print-level</tt> returns the current
print level and <tt>print-length</tt> returns the current print length.
When called with one argument, which must be a nonnegative fixnum or
<tt>#f</tt>, <tt>print-level</tt> sets the current print level and
<tt>print-length</tt> sets the current print length to the argument.

<p>
When <tt>print-level</tt> is set to a nonnegative integer <tt><i>n</i></tt>,
<tt>write</tt> and <tt>pretty-print</tt>
traverse only <tt><i>n</i></tt> levels deep into nested structures.
If a structure being printed exceeds <tt><i>n</i></tt> levels of nesting,
the substructure beyond that point is replaced in the output by an
<a name="./io:s117"></a><a name="./io:s118"></a>ellipsis
(&nbsp;<tt>...</tt>&nbsp;).
<tt>print-level</tt> is set to <tt>#f</tt> by default, which places
no limit on the number of levels printed.

<p>
When <tt>print-length</tt> is set to a nonnegative integer <tt><i>n</i></tt>, the
procedures <tt>write</tt> and <tt>pretty-print</tt>
print only <tt><i>n</i></tt> elements of a list or vector,
replacing the remainder of the list or vector with an
<a name="./io:s119"></a><a name="./io:s120"></a>ellipsis
(&nbsp;<tt>...</tt>&nbsp;).
<tt>print-length</tt> is set to <tt>#f</tt> by default, which places
no limit on the number of elements printed.

<p>
Since objects printed through the <tt>~s</tt> option in
the format control strings of <tt>format</tt>, <tt>printf</tt>, and <tt>fprintf</tt> are
printed as with <tt>write</tt>,
the printing of such objects is also affected by <tt>print-level</tt>
and <tt>print-length</tt>.

<p>
The parameters <tt>print-level</tt> and <tt>print-length</tt> are useful for
controlling the volume of output in contexts where only a small portion
of the output is needed to identify the object being printed.
They are also useful in situations where circular structures may be
printed (see also <tt>print-graph</tt>).

<p>

<p><tt>(format&nbsp;"~s"&nbsp;'((((a)&nbsp;b)&nbsp;c)&nbsp;d&nbsp;e&nbsp;f&nbsp;g))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"((((a)&nbsp;b)&nbsp;c)&nbsp;d&nbsp;e&nbsp;f&nbsp;g)"
<br>
<br>
(parameterize&nbsp;([print-level&nbsp;2])<br>

&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;'((((a)&nbsp;b)&nbsp;c)&nbsp;d&nbsp;e&nbsp;f&nbsp;g)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"(((...)&nbsp;c)&nbsp;d&nbsp;e&nbsp;f&nbsp;g)"
<br>
<br>
(parameterize&nbsp;([print-length&nbsp;3])<br>

&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;'((((a)&nbsp;b)&nbsp;c)&nbsp;d&nbsp;e&nbsp;f&nbsp;g)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"((((a)&nbsp;b)&nbsp;c)&nbsp;d&nbsp;e&nbsp;...)"
<br>
<br>
(parameterize&nbsp;([print-level&nbsp;2]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[print-length&nbsp;3])<br>

&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;'((((a)&nbsp;b)&nbsp;c)&nbsp;d&nbsp;e&nbsp;f&nbsp;g)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"(((...)&nbsp;c)&nbsp;d&nbsp;e&nbsp;...)"</tt>
<p><a name="./io:s121"></a><span class=formdef><b>thread parameter</b>: <tt>print-radix</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The <tt>print-radix</tt> parameter determines the radix in which
numbers are printed by <tt>write</tt>, <tt>pretty-print</tt>, and
<tt>display</tt>.
Its value should be an integer between 2 and 36, inclusive.
Its default value is 10.

<p>
When the value of <tt>print-radix</tt> is not 10, <tt>write</tt> and
<tt>pretty-print</tt> print a radix prefix before the number
(<tt>#b</tt> for radix 2, <tt>#o</tt> for radix 8, <tt>#x</tt> for
radix 16, and <tt>#<i>n</i>r</tt> for any other radix <tt><i>n</i></tt>).

<p>
Since objects printed through the <tt>~s</tt> and
<tt>~a</tt> options in the format control strings of
<tt>format</tt>, <tt>printf</tt>, and <tt>fprintf</tt> are printed as
with <tt>write</tt> and <tt>display</tt>, the printing of such objects
is also affected by <tt>print-radix</tt>.

<p>

<p><tt>(format&nbsp;"~s"&nbsp;11242957)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"11242957"
<br>
<br>
(parameterize&nbsp;([print-radix&nbsp;16])<br>

&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;11242957))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"#xAB8DCD"
<br>
<br>
(parameterize&nbsp;([print-radix&nbsp;16])<br>

&nbsp;&nbsp;(format&nbsp;"~a"&nbsp;11242957))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"AB8DCD"</tt>
<p><a name="./io:s122"></a><span class=formdef><b>thread parameter</b>: <tt>print-gensym</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./io:s123"></a><a name="./io:s124"></a>When
<tt>print-gensym</tt> is set to <tt>#t</tt> (the default)
gensyms are printed with an
extended symbol syntax that includes both the pretty name and the unique
name of the gensym: 
<a name="./io:s125"></a><tt>#&#123;<i>pretty-name</i>&nbsp;<i>unique-name</i>&#125;</tt>.
When set to <tt>pretty</tt>, the pretty name only is shown, with the
prefix <a name="./io:s126"></a><tt>#:</tt>.
When set to <tt>pretty/suffix</tt>,
the printer prints the gensym's "pretty" name along with a
suffix based on the gensym's "unique" name, separated by a dot (&nbsp;"."&nbsp;).
If the gensym's unique name is generated automatically during the current
session, the suffix is that portion of the unique name that is not common
to all gensyms created during the current session.
Otherwise, the suffix is the entire unique name.
When set to <tt>#f</tt>, the pretty name only is shown, with no
prefix.

<p>
Since objects printed through the <tt>~s</tt> option in the
format control strings of <tt>format</tt>, <tt>printf</tt>,
<tt>errorf</tt>, etc., are printed as with <tt>write</tt>, the printing of
such objects is also affected by <tt>print-gensym</tt>.

<p>
When printing an object that may contain more than one occurrence of a
gensym and <tt>print-graph</tt> is set to <tt>pretty</tt> or <tt>#f</tt>,
it is useful to set <tt>print-graph</tt> to <tt>#t</tt> so that
multiple occurrences of the same gensym are marked as identical in
the output.

<p>

<p><tt>(let&nbsp;([g&nbsp;(gensym)])<br>

&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;g))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"#&#123;g0&nbsp;bdids2xl6v49vgwe-a&#125;"
<br>
<br>
(let&nbsp;([g&nbsp;(gensym)])<br>

&nbsp;&nbsp;(parameterize&nbsp;([print-gensym&nbsp;'pretty])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;g)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"#:g1
<br>
<br>
(let&nbsp;([g&nbsp;(gensym)])<br>

&nbsp;&nbsp;(parameterize&nbsp;([print-gensym&nbsp;#f])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;g)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"g2"
<br>
<br>
(let&nbsp;([g&nbsp;(gensym)])<br>

&nbsp;&nbsp;(parameterize&nbsp;([print-graph&nbsp;#t]&nbsp;[print-gensym&nbsp;'pretty])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;(list&nbsp;g&nbsp;g))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"(#0=#:g3&nbsp;#0#)"
<br>
<br>
(let&nbsp;([g1&nbsp;(gensym&nbsp;"x")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[g2&nbsp;(gensym&nbsp;"x")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[g3&nbsp;(gensym&nbsp;"y")])<br>

&nbsp;&nbsp;(parameterize&nbsp;([print-gensym&nbsp;'pretty/suffix])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(format&nbsp;"~s&nbsp;~s&nbsp;~s"&nbsp;g1&nbsp;g2&nbsp;g3)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"x.1&nbsp;x.2&nbsp;y.3"</tt>
<p><a name="./io:s127"></a><span class=formdef><b>thread parameter</b>: <tt>print-brackets</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When <tt>print-brackets</tt> is set to a true value, the pretty printer
(see <a name="./io:s128"></a><tt>pretty-print</tt>) uses square
brackets rather than parentheses around certain subexpressions of
common control structures, e.g., around <tt>let</tt> bindings and
<tt>cond</tt> clauses.
<tt>print-brackets</tt> is set to <tt>#t</tt> by default.

<p>

<p><tt>(let&nbsp;([p&nbsp;(open-output-string)])<br>

&nbsp;&nbsp;(pretty-print&nbsp;'(let&nbsp;([x&nbsp;3])&nbsp;x)&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"(let&nbsp;([x&nbsp;3])&nbsp;x)<br>

&nbsp;&nbsp;(get-output-string&nbsp;p))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;"
<br>
<br>
(parameterize&nbsp;([print-brackets&nbsp;#f])<br>

&nbsp;&nbsp;(let&nbsp;([p&nbsp;(open-output-string)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(pretty-print&nbsp;'(let&nbsp;([x&nbsp;3])&nbsp;x)&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"(let&nbsp;((x&nbsp;3))&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(get-output-string&nbsp;p)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;"</tt>
<p><a name="./io:s129"></a><span class=formdef><b>thread parameter</b>: <tt>print-extended-identifiers</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Chez Scheme extends the syntax of identifiers as described in
Section&nbsp;<a href="./intro.html#g1">1.1</a>, except within a set of forms prefixed by
<tt>#!r6rs</tt> (which is implied in a library or top-level program).

<p>
When this parameter is set to false (the default), identifiers in the
extended set are printed with hex scalar value escapes as necessary to
conform to the R6RS syntax for identifiers.
When this parameter is set to a true value, identifiers in the
extended set are printed without the escapes.
Identifiers whose names fall outside of both syntaxes are printed with
the escapes regardless of the setting of this parameter.

<p>
For example:

<p>

<p><tt>(parameterize&nbsp;([print-extended-identifiers&nbsp;#f])<br>

&nbsp;&nbsp;(printf&nbsp;"~s\n~s\n"<br>

&nbsp;&nbsp;&nbsp;&nbsp;'(1+&nbsp;---&nbsp;&#123;&nbsp;&#125;&nbsp;.xyz)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;symbol&nbsp;"123")))</tt>
<p>prints

<p>

<p><tt>(\x31;+&nbsp;\x2D;--&nbsp;\x7B;&nbsp;\x7D;&nbsp;\x2E;xyz)<br>

\x31;23</tt>
<p>while

<p>

<p><tt>(parameterize&nbsp;([print-extended-identifiers&nbsp;#t])<br>

&nbsp;&nbsp;(printf&nbsp;"~s\n~s\n"<br>

&nbsp;&nbsp;&nbsp;&nbsp;'(1+&nbsp;---&nbsp;&#123;&nbsp;&#125;&nbsp;.xyz)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;symbol&nbsp;"123")))</tt>
<p>prints

<p>

<p><tt>(1+&nbsp;---&nbsp;&#123;&nbsp;&#125;&nbsp;.xyz)<br>

\x31;23</tt>
<p><a name="./io:s130"></a><span class=formdef><b>thread parameter</b>: <tt>print-vector-length</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When <tt>print-vector-length</tt> is set to a true value,
<tt>write</tt>, <tt>put-datum</tt>, and <tt>pretty-print</tt> include the length
for all vectors, bytevectors, and fxvectors immediately after the "<tt>#</tt>".
This parameter is set to <tt>#f</tt> by default.

<p>
<a name="./io:s131"></a>When <tt>print-vector-length</tt> is set to a
true value, <tt>write</tt>, <tt>put-datum</tt>, and <tt>pretty-print</tt>
also suppress duplicated trailing elements in the vector to
reduce the amount of output.
This form is also recognized by the reader.

<p>
Since objects printed through the <tt>~s</tt> option in the
format control strings of <tt>format</tt>, <tt>printf</tt>, and
<tt>fprintf</tt> are printed as with <tt>write</tt>, the printing of
such objects is also affected by the setting of
<tt>print-vector-length</tt>.

<p>

<p><tt>(format&nbsp;"~s"&nbsp;(vector&nbsp;'a&nbsp;'b&nbsp;'c&nbsp;'c&nbsp;'c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"#(a&nbsp;b&nbsp;c&nbsp;c&nbsp;c)"
<br>
<br>
(parameterize&nbsp;([print-vector-length&nbsp;#t])<br>

&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;(vector&nbsp;'a&nbsp;'b&nbsp;'c&nbsp;'c&nbsp;'c)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"#5(a&nbsp;b&nbsp;c)"
<br>
<br>
(parameterize&nbsp;([print-vector-length&nbsp;#t])<br>

&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;(bytevector&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;4&nbsp;4)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"#6vu8(1&nbsp;2&nbsp;3&nbsp;4)"
<br>
<br>
(parameterize&nbsp;([print-vector-length&nbsp;#t])<br>

&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;(fxvector&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;4&nbsp;4)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"#6vfx(1&nbsp;2&nbsp;3&nbsp;4)"</tt>
<p><a name="./io:s132"></a><span class=formdef><b>thread parameter</b>: <tt>print-precision</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When <tt>print-precision</tt> is set to <tt>#f</tt> (the default),
<tt>write</tt>, <tt>put-datum</tt>, <tt>pretty-print</tt>, and the
<tt>format</tt> "<tt>~s</tt>" directive do not include the
vertical-bar "mantissa-width" syntax after each floating-point
number---except for subnormal floating-point numbers, in which case precision printing
is controlled by <tt>print-subnormal-precision</tt>.
When set to a nonnegative exact integer, the mantissa width is
included, as per the precision argument to
<tt>number-&gt;string</tt>.

<p>

<p><tt>(format&nbsp;"~s"&nbsp;1e-100)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"1e-100"<br>

(parameterize&nbsp;([print-precision&nbsp;32])<br>

&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;1e-100))&nbsp;;&nbsp;=&gt;&nbsp;"1e-100|53"<br>

(format&nbsp;"~s"&nbsp;1e-310)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"1e-310|45"</tt>
<p><a name="./io:s133"></a><span class=formdef><b>thread parameter</b>: <tt>print-subnormal-precision</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When <tt>print-subnormal-precision</tt> is set to a true value (the default),
<tt>write</tt>, <tt>put-datum</tt>, <tt>pretty-print</tt>, and the
<tt>format</tt> "<tt>~s</tt>" directive include the
vertical-bar "mantissa-width" syntax after each floating-point
number whose value is subnormal (roughly 4.94e-324 to 2.225e-308),
regardless of the value of <tt>print-precision</tt>.
When <tt>print-subnormal-precision</tt> and <tt>print-precision</tt> are
both set to <tt>#f</tt>, precision is not printed for a subnormal value.

<p>

<p><tt>(format&nbsp;"~s"&nbsp;1e-310)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"1e-310|45"<br>

(parameterize&nbsp;([print-subnormal-precision&nbsp;#f])<br>

&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;1e-310))&nbsp;;&nbsp;=&gt;&nbsp;"1e-310"<br>

(parameterize&nbsp;([print-precision&nbsp;32]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[print-subnormal-precision&nbsp;#f])<br>

&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;1e-310))&nbsp;;&nbsp;=&gt;&nbsp;"1e-310|45"</tt>
<p><a name="./io:s134"></a><span class=formdef><b>thread parameter</b>: <tt>print-positive-exponent-sign</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When <tt>print-positive-exponent-sign</tt> is set to a true value, then
when a flonum is printed in exponential form and the exponent is positive,
a plus sign is written before the exponent. When
<tt>print-positive-exponent-sign</tt> is set <tt>#f</tt> (the
default), no plus sign is written before a positive exponent.

<p>
<a name="./io:s135"></a><span class=formdef><b>thread parameter</b>: <tt>print-select-flonum-exponential-format</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of <tt>print-select-flonum-exponential-format</tt> must be a
procedure that accepts three arguments: a radix as an integer
between 2 and 36 (inclusive), an exponent as an integer, and
the number of non-zero significant digits in the flonum's printed form
using the matissa (where the first digit is before the "decimal" point).
If the procedure returns a true value, a number is printed in expotential
form, otherwise it is printed in nonexponential form.

<p>

<p><tt>(format&nbsp;"~s&nbsp;~s"&nbsp;1e2&nbsp;1e8)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"100.0&nbsp;100000000.0"<br>

(parameterize&nbsp;([print-select-flonum-exponential-format<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(radix&nbsp;exponent&nbsp;digits)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&gt;&nbsp;exponent&nbsp;3))])<br>

&nbsp;&nbsp;(format&nbsp;"~s&nbsp;~s"&nbsp;1e2&nbsp;1e8))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"100.0&nbsp;1e8"<br>

(parameterize&nbsp;([print-select-flonum-exponential-format<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(radix&nbsp;exponent&nbsp;digits)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&nbsp;digits&nbsp;3))])<br>

&nbsp;&nbsp;(format&nbsp;"~s&nbsp;~s&nbsp;~s"&nbsp;1e2&nbsp;1.5e8&nbsp;3.14159e-8))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"1e2&nbsp;1.5e8&nbsp;0.0000000314159"</tt>
<p><a name="./io:s136"></a><span class=formdef><b>thread parameter</b>: <tt>print-unicode</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When <tt>print-unicode</tt> is set to <tt>#f</tt>,
<tt>write</tt>, <tt>put-datum</tt>, <tt>pretty-print</tt>, and the
<tt>format</tt> "<tt>~s</tt>" directive display Unicode characters
with encodings 80<sub>16</sub> (128) and above that appear 
within character objects, symbols, and strings
using hexadecimal character escapes.
When set to a true value (the default), they are displayed like
other printing characters, as if by <tt>put-char</tt>.

<p>

<p><tt>(format&nbsp;"~s"&nbsp;#\x3bb)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"#\\<img src="math/csug/3.gif" alt="<graphic>">"<br>

(parameterize&nbsp;([print-unicode&nbsp;#f])<br>

&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;#\x3bb))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"#\\x3BB"</tt>
<p>
<h3><a name="g92"></a><a name="./io:h15"></a>Section 9.15. Fasl Output<a name="SECTFASL"></a></h3>



<p>
<a name="./io:s137"></a>The procedures <tt>write</tt> and <tt>pretty-print</tt> print objects in a
human readable format.
For objects with external datum representations, the output produced by
<tt>write</tt> and <tt>pretty-print</tt> is also machine-readable with
<tt>read</tt>.
Objects with external datum representations include pairs, symbols,
vectors, strings, numbers, characters, booleans, and records but not
procedures and ports.

<p>
An alternative <i>fast loading</i>, or <i>fasl</i>, format may be used for
objects with external datum representations.
The fasl format is not human readable, but it is machine readable and both
more compact and more quickly processed by <tt>read</tt>.
This format is always used for compiled code generated by
<tt>compile-file</tt>, but it may also be used for data that needs to be
written and read quickly, such as small databases encoded with Scheme data
structures.

<p>
Objects are printed in fasl format with <tt>fasl-write</tt>.
Because the fasl format is a binary format, fasl output must be written
to a binary port.
For this reason, it is not possible to include data written in fasl
format with textual data in the same file, as was the case in
earlier versions of <i>Chez&nbsp;Scheme</i>.
Similarly, the (textual) reader does not handle objects written in
fasl format; the procedure <tt>fasl-read</tt>, which requires a binary
input port, must be used instead.


<p>
<a name="./io:s138"></a><span class=formdef><b>procedure</b>: <tt>(fasl-write&nbsp;<i>obj</i>&nbsp;<i>binary-output-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fasl-write&nbsp;<i>obj</i>&nbsp;<i>binary-output-port</i>&nbsp;<i>external-pred</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fasl-write&nbsp;<i>obj</i>&nbsp;<i>binary-output-port</i>&nbsp;<i>external-pred</i>&nbsp;<i>omit-rtds?</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>fasl-write</tt> writes the fasl representation of <tt><i>obj</i></tt> to
<tt><i>binary-output-port</i></tt>.
An exception is raised with condition-type <tt>&amp;assertion</tt> if
<tt><i>obj</i></tt> or any portion of <tt><i>obj</i></tt> has no external fasl representation,
e.g., if <tt><i>obj</i></tt> is or contains a procedure.

<p>
If <tt><i>externals-pred</i></tt> is provided and not <tt>#f</tt>, then it must be a
procedure that accepts one argument.  It is applied to each distinct object 
encountered in <tt><i>obj</i></tt>, including symbols, but not necessarily values of
other primitive datatypes for which <tt>equal?</tt> implies <tt>eq?</tt>. If
<tt><i>externals-pred</i></tt> returns true for an object, that object is not
written to the fasl representation. Instead, a placeholder is written
containing a position as the number of preceding calls to
<tt><i>externals-pred</i></tt> that had returned true. Typically, for each
object where it returns true, <tt><i>externals-pred</i></tt> saves the object
through its closure. When the fasl representation is read with
<tt>fasl-read</tt>, a vector with as many items as generated positions
must be provided, and each placeholder is replaced with the
corresponding vector element. Beware that replacing values used for
system-internal data structures (which are always instances of primitive
datatypes) with non-equal values at load time results in undefined
behavior.

<p>
If <tt><i>omit-rtds?</i></tt> is present and true, then any record types
relevant to <tt><i>obj</i></tt> are not written to the fasl representation.
When the fasl representation is read, these record types must already
be declared in the loading context, and the
loading context is assumed to have compatible record-type
registrations using the same unique ID.  Behavior if the loading context
has an <i>incompatible</i> record-type registration using the same
(ostensibly unique) ID is undefined.

<p>
The fasl representation of <tt><i>obj</i></tt> is compressed if the parameter
<tt>fasl-compressed</tt>, described below, is set to <tt>#t</tt>,
its default value.
For this reason, <tt><i>binary-output-port</i></tt> generally should not be opened
with the compressed option.
A warning is issued (an exception with condition type <tt>&amp;warning</tt>
is raised) on the first attempt to write fasl objects to or read
fasl objects from a compressed file.

<p>

<p><tt>(define&nbsp;bop&nbsp;(open-file-output-port&nbsp;"tmp.fsl"))<br>

(fasl-write&nbsp;'(a&nbsp;b&nbsp;c)&nbsp;bop)<br>

(close-port&nbsp;bop)
<br>
<br>
(define&nbsp;bip&nbsp;(open-file-input-port&nbsp;"tmp.fsl"))<br>

(fasl-read&nbsp;bip)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(fasl-read&nbsp;bip)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#!eof<br>

(close-port&nbsp;bip)</tt>
<p><a name="./io:s139"></a><span class=formdef><b>procedure</b>: <tt>(fasl-read&nbsp;<i>binary-input-port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fasl-read&nbsp;<i>binary-input-port <i>situation</i></i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fasl-read&nbsp;<i>binary-input-port <i>situation</i>&nbsp;<i>externals</i></i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If present, <tt><i>situation</i></tt> must be one of the symbols <tt>load</tt>,
<tt>visit</tt>, or <tt>revisit</tt>; it defaults to <tt>load</tt>.
If present, <tt><i>exterrnals</i></tt> must be a vector; it defaults to
<tt>'#()</tt>.

<p>
<tt>fasl-read</tt> reads one object from
<tt><i>binary-input-port</i></tt>, which must be positioned at the
front of an object written in fasl format.
<tt>fasl-read</tt> returns the eof object if the file is positioned
at the end of file.
If the situation is <tt>visit</tt>, <tt>fasl-read</tt> skips over 
any revisit (run-time-only) objects, and
if the situation is <tt>revisit</tt>, <tt>fasl-read</tt> skips over 
any visit (compile-time-only) objects.
It doesn't skip any if the situation is <tt>load</tt>.
Similarly, objects marked as both visit and revisit (e.g., object code
corresponding to source code within an <tt>eval-when</tt> form with
situation <tt>load</tt> or situations <tt>visit</tt> and <tt>revisit</tt>)
are never skipped.

<p>
The <tt><i>externals</i></tt> vector must have the same length as the number
of true-returning calls to <tt><i>external-pred</i></tt> during the
<tt>fasl-write</tt> call that produced the fasl representation.

<p>
<tt>fasl-read</tt> automatically decompresses the representation
of each fasl object written in compressed format by <tt>fasl-write</tt>.
Thus, <tt><i>binary-input-port</i></tt> generally should not be opened with
the compressed option.
A warning is issued (an exception with condition type <tt>&amp;warning</tt>
is raised) on the first attempt to write fasl objects to or read
fasl objects from a compressed file.

<p>

<p><tt>(define&nbsp;bop&nbsp;(open-file-output-port&nbsp;"tmp.fsl"))<br>

(fasl-write&nbsp;'(a&nbsp;b&nbsp;c)&nbsp;bop)<br>

(close-port&nbsp;bop)
<br>
<br>
(define&nbsp;bip&nbsp;(open-file-input-port&nbsp;"tmp.fsl"))<br>

(fasl-read&nbsp;bip)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(fasl-read&nbsp;bip)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#!eof<br>

(close-port&nbsp;bip)</tt>
<p><a name="./io:s140"></a><span class=formdef><b>thread parameter</b>: <tt>fasl-compressed</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When this parameter is set to its default value, <tt>#t</tt>,
<tt>fasl-write</tt> compresses the representation of each object
as it writes it, often resulting in substantially smaller output
but possibly taking more time to write and read.
The compression format and level are determined by the
<a name="./io:s141"></a><tt>compress-format</tt>
and
<a name="./io:s142"></a><tt>compress-level</tt>
parameters.


<p>
<a name="./io:s143"></a><span class=formdef><b>procedure</b>: <tt>(fasl-file&nbsp;<i>ifn</i>&nbsp;<i>ofn</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>ifn</i></tt> and <tt><i>ofn</i></tt> must be strings.
<tt>fasl-file</tt> may be used to convert a file in human-readable
format into an equivalent
file written in fasl format.
<tt>fasl-file</tt> reads each object in turn from the file named by
<tt><i>ifn</i></tt> and writes the fasl format for the object onto the file
named by <tt><i>ofn</i></tt>.
If the file named by <tt><i>ofn</i></tt> already exists, it is replaced.


<p>

<h3><a name="g93"></a><a name="./io:h16"></a>Section 9.16. File System Interface<a name="SECTIOFILESYSTEM"></a></h3>



<p>
This section describes operations on files, directories, and pathnames.

<p>
<a name="./io:s144"></a><span class=formdef><b>global parameter</b>: <tt>current-directory</tt></span>
<br><span class=formdef><b>global parameter</b>: <tt>cd</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When invoked without arguments, <tt>current-directory</tt> returns a string
representing the current working directory.
Otherwise, the current working directory is changed to the directory
specified by the argument, which must be a string representing a valid
directory pathname.

<p>
<tt>cd</tt> is bound to the same parameter.

<p>
<a name="./io:s145"></a><span class=formdef><b>procedure</b>: <tt>(directory-list&nbsp;<i>path</i>)</tt></span>
<br>
<b>returns: </b>a list of file names
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
The return value is a list of strings representing the names of
files found in the directory named by <tt><i>path</i></tt>.
<tt>directory-list</tt> raises an exception with condition
type <tt>&amp;i/o-filename</tt> if <tt><i>path</i></tt> does not name a directory
or if the process cannot list the directory.

<p>
<a name="./io:s146"></a><span class=formdef><b>procedure</b>: <tt>(file-exists?&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(file-exists?&nbsp;<i>path</i>&nbsp;<i>follow?</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the file named by <tt><i>path</i></tt> exists, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
If the optional <tt><i>follow?</i></tt> argument is true (the default),
<tt>file-exists?</tt> follows symbolic links; otherwise it does not.
Thus, <tt>file-exists?</tt> will return <tt>#f</tt> when handed the
pathname of a broken symbolic link unless <tt><i>follow?</i></tt> is provided
and is <tt>#f</tt>.

<p>
The Revised<sup>6</sup> Report <tt>file-exists?</tt> does not accept the
optional <tt><i>follow?</i></tt> argument.
Whether it follows symbolic links is unspecified.

<p>
<a name="./io:s147"></a><span class=formdef><b>procedure</b>: <tt>(file-regular?&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(file-regular?&nbsp;<i>path</i>&nbsp;<i>follow?</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the file named by <tt><i>path</i></tt> is a regular file, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
If the optional <tt><i>follow?</i></tt> argument is true (the default),
<tt>file-regular?</tt> follows symbolic links; otherwise it does not.

<p>
<a name="./io:s148"></a><span class=formdef><b>procedure</b>: <tt>(file-directory?&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(file-directory?&nbsp;<i>path</i>&nbsp;<i>follow?</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the file named by <tt><i>path</i></tt> is a directory, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
If the optional <tt><i>follow?</i></tt> argument is true (the default),
this procedure follows symbolic links; otherwise it does not.

<p>
<a name="./io:s149"></a><span class=formdef><b>procedure</b>: <tt>(file-symbolic-link?&nbsp;<i>path</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the file named by <tt><i>path</i></tt> is a symbolic link, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt>file-symbolic-link?</tt> never follows symbolic links in making its
determination.

<p>
<a name="./io:s150"></a><span class=formdef><b>procedure</b>: <tt>(file-access-time&nbsp;<i>path/port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(file-access-time&nbsp;<i>path/port</i>&nbsp;<i>follow?</i>)</tt></span>
<br>
<b>returns: </b>the access time of the specified file
<br><span class=formdef><b>procedure</b>: <tt>(file-change-time&nbsp;<i>path/port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(file-change-time&nbsp;<i>path/port</i>&nbsp;<i>follow?</i>)</tt></span>
<br>
<b>returns: </b>the change time of the specified file
<br><span class=formdef><b>procedure</b>: <tt>(file-modification-time&nbsp;<i>path/port</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(file-modification-time&nbsp;<i>path/port</i>&nbsp;<i>follow?</i>)</tt></span>
<br>
<b>returns: </b>the modification time of the specified file
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path/port</i></tt> must be a string or port.
If <tt><i>path/port</i></tt> is a string, the time returned is for the file named
by the string, and the optional <tt><i>follow?</i></tt> argument determines whether
symbolic links are followed.
If <tt><i>follow?</i></tt> is true (the default),
this procedure follows symbolic links; otherwise it does not.
If <tt><i>path/port</i></tt> is a port, it must be a file port, and the time returned
is for the associated file.
In this case, <tt><i>follow?</i></tt> is ignored.

<p>
The returned times are represented as time objects
(Section&nbsp;<a href="./system.html#g126">12.10</a>).


<p>
<a name="./io:s151"></a><span class=formdef><b>procedure</b>: <tt>(mkdir&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(mkdir&nbsp;<i>path</i>&nbsp;<i>mode</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt><i>mode</i></tt> must be a fixnum.

<p>
<tt>mkdir</tt> creates a directory with the name given by <tt><i>path</i></tt>.
All <tt><i>path</i></tt> path components leading up to the last must already
exist.
If the optional <tt><i>mode</i></tt> argument is present, it overrides the default
permissions for the new directory.
Under Windows, the <tt><i>mode</i></tt> argument is ignored.

<p>
<tt>mkdir</tt> raises an exception with condition
type <tt>&amp;i/o-filename</tt> if the directory cannot be created.


<p>
<a name="./io:s152"></a><span class=formdef><b>procedure</b>: <tt>(delete-file&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(delete-file&nbsp;<i>path</i>&nbsp;<i>error?</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt>delete-file</tt> removes the file named by <tt><i>path</i></tt>.
If the optional <tt><i>error?</i></tt> argument is <tt>#f</tt> (the default),
<tt>delete-file</tt> returns a boolean value: <tt>#t</tt> if the
operation is successful and <tt>#f</tt> if it is not.
Otherwise, <tt>delete-file</tt> returns an unspecified value if the
operation is successful and raises an exception with condition
type <tt>&amp;i/o-filename</tt> if it is not.

<p>
The Revised<sup>6</sup> Report <tt>delete-file</tt> does not accept the
optional <tt><i>error?</i></tt> argument but behaves as if <tt><i>error?</i></tt>
is true.

<p>
<a name="./io:s153"></a><span class=formdef><b>procedure</b>: <tt>(delete-directory&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(delete-directory&nbsp;<i>path</i>&nbsp;<i>error?</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt>delete-directory</tt> removes the directory named by <tt><i>path</i></tt>.
If the optional <tt><i>error?</i></tt> argument is <tt>#f</tt> (the default),
<tt>delete-directory</tt> returns a boolean value: <tt>#t</tt> if the
operation is successful and <tt>#f</tt> if it is not.
Otherwise, <tt>delete-directory</tt> returns an unspecified value if the
operation is successful and raises an exception with condition
type <tt>&amp;i/o-filename</tt> if it is not.
The behavior is unspecified if the directory is not empty, but on
most systems the operations will not succeed.

<p>
<a name="./io:s154"></a><span class=formdef><b>procedure</b>: <tt>(rename-file&nbsp;<i>old-pathname</i>&nbsp;<i>new-pathname</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>old-pathname</i></tt> and <tt><i>new-pathname</i></tt> must be strings.
<tt>rename-file</tt> changes the name of the file named by <tt><i>old-pathname</i></tt>
to <tt><i>new-pathname</i></tt>.
If the file does not exist or cannot be renamed,
an exception is raised with condition type <tt>&amp;i/o-filename</tt>.

<p>
<a name="./io:s155"></a><span class=formdef><b>procedure</b>: <tt>(chmod&nbsp;<i>path</i>&nbsp;<i>mode</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt><i>mode</i></tt> must be a fixnum.

<p>
<tt>chmod</tt> sets the permissions on the file named by
<tt><i>path</i></tt> to <tt><i>mode</i></tt>.
Bits 0, 1, and&nbsp;2 of <tt><i>mode</i></tt> are the execute, write, and read permission bits
for users other than the file's owner who are not in the file's group.
Bits 3-5 are the execute, write, and read permission bits for users other
than the file's owner but in the file's group.
Bits 6-8 are the execute, write, and read permission bits
for the file's owner.
Bits 7-9 are the Unix sticky, set-group-id, and set-user-id bits.
Under Windows, all but the user "write" bit are ignored.
If the file does not exist or the permissions cannot be changed,
an exception is raised with condition type <tt>&amp;i/o-filename</tt>.

<p>
<a name="./io:s156"></a><span class=formdef><b>procedure</b>: <tt>(get-mode&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(get-mode&nbsp;<i>path</i>&nbsp;<i>follow?</i>)</tt></span>
<br>
<b>returns: </b>the current permissions mode for <tt><i>path</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
<tt>get-mode</tt> retrieves the permissions on the file named by
<tt><i>path</i></tt> and returns them as a fixnum in the same form as the <tt><i>mode</i></tt>
argument to <tt>chmod</tt>.
If the optional <tt><i>follow?</i></tt> argument is true (the default),
this procedure follows symbolic links; otherwise it does not.


<p>
<a name="./io:s157"></a><span class=formdef><b>procedure</b>: <tt>(directory-separator?&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>char</i></tt> is a directory separator, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The character <tt>#\/</tt> is a directory separator on all
current machine types, and <tt>#\\</tt> is a directory separator
under Windows.

<p>
<a name="./io:s158"></a><span class=formdef><b>procedure</b>: <tt>(directory-separator)</tt></span>
<br>
<b>returns: </b>the preferred directory separator
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The preferred directory separator is <tt>#\\</tt> for Windows and
<tt>#\/</tt> for other systems.

<p>
<a name="./io:s159"></a><span class=formdef><b>procedure</b>: <tt>(path-build&nbsp;<i>dir-path</i>&nbsp;<i>path</i>)</tt></span>
<br>
<b>returns: </b>a combined path
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Combines <tt><i>dir-path</i></tt> and <tt><i>path</i></tt>, adding a directory separator
between them if needed.
If <tt><i>dir-path</i></tt> is the empty string, <tt><i>path</i></tt> is returned.

<p>
<a name="./io:s160"></a><span class=formdef><b>procedure</b>: <tt>(path-first&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(path-rest&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(path-last&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(path-parent&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(path-extension&nbsp;<i>path</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(path-root&nbsp;<i>path</i>)</tt></span>
<br>
<b>returns: </b>the specified component of <tt><i>path</i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(path-absolute?&nbsp;<i>path</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>path</i></tt> is absolute, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>path</i></tt> must be a string.
The return value is also a (possibly empty) string.

<p>
The path first component is the first directory in the path, or the
empty string if the path consists only of a single filename.
The path rest component is the portion of the path that does not
include the path first component or the directory separator (if
any) that separates it from the rest of the path.
The path last component is the last (filename) portion of <tt><i>path</i></tt>.
The path parent component is the portion of <tt><i>path</i></tt> that does not
include the path last component, if any, or the directory separator that
separates it from the rest of the path.

<p>
If the first component of the path names a root directory (including drives
and shares under Windows), home directory
(e.g., <tt>~/abc</tt> or <tt>~user/abc</tt>), 
the current directory (<tt>.</tt>), or the parent directory
(<tt>..</tt>), <tt>path-first</tt> returns that component.
For paths that consist only of such a directory,
both <tt>path-first</tt> and <tt>path-parent</tt> act as
identity procedures, while <tt>path-rest</tt> and <tt>path-last</tt>
return the empty string.

<p>
The path extension component is the portion of <tt><i>path</i></tt> that follows
the last dot (period) in the last component of a path name.
The path root component is the portion of <tt><i>path</i></tt> that does not
include the extension, if any, or the dot that precedes it.

<p>
If the first component names a root directory (including drives
and shares under Windows) or home directory,
<tt>path-absolute?</tt> returns <tt>#t</tt>.
Otherwise, <tt>path-absolute?</tt> returns <tt>#f</tt>. 

<p>
The tables below identify the components for several example paths,
with underscores representing empty strings.

<p>
<TABLE><TR><TD nowrap align="left">
path               </TD><TD nowrap align="left"> abs         </TD><TD nowrap align="left"> first              </TD><TD nowrap align="left"> rest               </TD><TD nowrap align="left"> parent             </TD><TD nowrap align="left"> last               </TD><TD nowrap align="left"> root               </TD><TD nowrap align="left"> ext        </TD></TR><TR><TD nowrap align="left">
<tt>a</tt>         </TD><TD nowrap align="left"> <tt>#f</tt> </TD><TD nowrap align="left"> <tt>_</tt>         </TD><TD nowrap align="left"> <tt>a</tt>         </TD><TD nowrap align="left"> <tt>_</tt>         </TD><TD nowrap align="left"> <tt>a</tt>         </TD><TD nowrap align="left"> <tt>a</tt>         </TD><TD nowrap align="left"> <tt>_</tt> </TD></TR><TR><TD nowrap align="left">
<tt>a/</tt>        </TD><TD nowrap align="left"> <tt>#f</tt> </TD><TD nowrap align="left"> <tt>a</tt>         </TD><TD nowrap align="left"> <tt>_</tt>         </TD><TD nowrap align="left"> <tt>a</tt>         </TD><TD nowrap align="left"> <tt>_</tt>         </TD><TD nowrap align="left"> <tt>a/</tt>        </TD><TD nowrap align="left"> <tt>_</tt> </TD></TR><TR><TD nowrap align="left">
<tt>a/b</tt>       </TD><TD nowrap align="left"> <tt>#f</tt> </TD><TD nowrap align="left"> <tt>a</tt>         </TD><TD nowrap align="left"> <tt>b</tt>         </TD><TD nowrap align="left"> <tt>a</tt>         </TD><TD nowrap align="left"> <tt>b</tt>         </TD><TD nowrap align="left"> <tt>a/b</tt>       </TD><TD nowrap align="left"> <tt>_</tt> </TD></TR><TR><TD nowrap align="left">
<tt>a/b.c</tt>     </TD><TD nowrap align="left"> <tt>#f</tt> </TD><TD nowrap align="left"> <tt>a</tt>         </TD><TD nowrap align="left"> <tt>b.c</tt>       </TD><TD nowrap align="left"> <tt>a</tt>         </TD><TD nowrap align="left"> <tt>b.c</tt>       </TD><TD nowrap align="left"> <tt>a/b</tt>       </TD><TD nowrap align="left"> <tt>c</tt> </TD></TR><TR><TD nowrap align="left">
<tt>/</tt>         </TD><TD nowrap align="left"> <tt>#t</tt> </TD><TD nowrap align="left"> <tt>/</tt>         </TD><TD nowrap align="left"> <tt>_</tt>         </TD><TD nowrap align="left"> <tt>/</tt>         </TD><TD nowrap align="left"> <tt>_</tt>         </TD><TD nowrap align="left"> <tt>/</tt>         </TD><TD nowrap align="left"> <tt>_</tt> </TD></TR><TR><TD nowrap align="left">
<tt>/a/b.c</tt>    </TD><TD nowrap align="left"> <tt>#t</tt> </TD><TD nowrap align="left"> <tt>/</tt>         </TD><TD nowrap align="left"> <tt>a/b.c</tt>     </TD><TD nowrap align="left"> <tt>/a</tt>        </TD><TD nowrap align="left"> <tt>b.c</tt>       </TD><TD nowrap align="left"> <tt>/a/b</tt>      </TD><TD nowrap align="left"> <tt>c</tt> </TD></TR><TR><TD nowrap align="left">
<tt>~/a/b.c</tt>   </TD><TD nowrap align="left"> <tt>#t</tt> </TD><TD nowrap align="left"> <tt>~</tt>         </TD><TD nowrap align="left"> <tt>a/b.c</tt>     </TD><TD nowrap align="left"> <tt>~/a</tt>       </TD><TD nowrap align="left"> <tt>b.c</tt>       </TD><TD nowrap align="left"> <tt>~/a/b</tt>     </TD><TD nowrap align="left"> <tt>c</tt> </TD></TR><TR><TD nowrap align="left">
<tt>~u/a/b.c</tt>  </TD><TD nowrap align="left"> <tt>#t</tt> </TD><TD nowrap align="left"> <tt>~u</tt>        </TD><TD nowrap align="left"> <tt>a/b.c</tt>     </TD><TD nowrap align="left"> <tt>~u/a</tt>      </TD><TD nowrap align="left"> <tt>b.c</tt>       </TD><TD nowrap align="left"> <tt>~u/a/b</tt>    </TD><TD nowrap align="left"> <tt>c</tt> </TD></TR><TR><TD nowrap align="left">
<tt>../..</tt>     </TD><TD nowrap align="left"> <tt>#f</tt> </TD><TD nowrap align="left"> <tt>..</tt>        </TD><TD nowrap align="left"> <tt>..</tt>        </TD><TD nowrap align="left"> <tt>..</tt>        </TD><TD nowrap align="left"> <tt>..</tt>        </TD><TD nowrap align="left"> <tt>../..</tt>     </TD><TD nowrap align="left"> <tt>_</tt> </TD></TR><TR><TD nowrap align="left">
</TD></TR></TABLE>

<p>
The second table shows the components when Windows drives and shares
are involved.

<p>
<TABLE><TR><TD nowrap align="left">
path               </TD><TD nowrap align="left"> abs         </TD><TD nowrap align="left"> first              </TD><TD nowrap align="left"> rest               </TD><TD nowrap align="left"> parent             </TD><TD nowrap align="left"> last               </TD><TD nowrap align="left"> root               </TD><TD nowrap align="left"> ext       </TD></TR><TR><TD nowrap align="left">
<tt>c:</tt>        </TD><TD nowrap align="left"> <tt>#f</tt> </TD><TD nowrap align="left"> <tt>c:</tt>        </TD><TD nowrap align="left"> <tt>_</tt>         </TD><TD nowrap align="left"> <tt>c:</tt>        </TD><TD nowrap align="left"> <tt>_</tt>         </TD><TD nowrap align="left"> <tt>c:</tt>        </TD><TD nowrap align="left"> <tt>_</tt> </TD></TR><TR><TD nowrap align="left">
<tt>c:/</tt>       </TD><TD nowrap align="left"> <tt>#t</tt> </TD><TD nowrap align="left"> <tt>c:/</tt>       </TD><TD nowrap align="left"> <tt>_</tt>         </TD><TD nowrap align="left"> <tt>c:/</tt>       </TD><TD nowrap align="left"> <tt>_</tt>         </TD><TD nowrap align="left"> <tt>c:/</tt>       </TD><TD nowrap align="left"> <tt>_</tt> </TD></TR><TR><TD nowrap align="left">
<tt>c:a/b</tt>     </TD><TD nowrap align="left"> <tt>#f</tt> </TD><TD nowrap align="left"> <tt>c:</tt>        </TD><TD nowrap align="left"> <tt>a/b</tt>       </TD><TD nowrap align="left"> <tt>c:a</tt>       </TD><TD nowrap align="left"> <tt>b</tt>         </TD><TD nowrap align="left"> <tt>c:a/b</tt>     </TD><TD nowrap align="left"> <tt>_</tt> </TD></TR><TR><TD nowrap align="left">
<tt>//s/a/b.c</tt> </TD><TD nowrap align="left"> <tt>#t</tt> </TD><TD nowrap align="left"> <tt>//s</tt>       </TD><TD nowrap align="left"> <tt>a/b.c</tt>     </TD><TD nowrap align="left"> <tt>//s/a</tt>     </TD><TD nowrap align="left"> <tt>b.c</tt>       </TD><TD nowrap align="left"> <tt>//s/a/b</tt>   </TD><TD nowrap align="left"> <tt>c</tt> </TD></TR><TR><TD nowrap align="left">
<tt>//s.com</tt>   </TD><TD nowrap align="left"> <tt>#t</tt> </TD><TD nowrap align="left"> <tt>//s.com</tt>   </TD><TD nowrap align="left"> <tt>_</tt>         </TD><TD nowrap align="left"> <tt>//s.com</tt>   </TD><TD nowrap align="left"> <tt>_</tt>         </TD><TD nowrap align="left"> <tt>//s.com</tt>   </TD><TD nowrap align="left"> <tt>_</tt> </TD></TR><TR><TD nowrap align="left">
</TD></TR></TABLE>

<p>
The following procedure can be used to reproduce the tables above.

<p>

<p><tt>(define&nbsp;print-table<br>

&nbsp;&nbsp;(lambda&nbsp;path*<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;print-row<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(abs?&nbsp;path&nbsp;first&nbsp;rest&nbsp;parent&nbsp;last&nbsp;root&nbsp;extension)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(printf&nbsp;"~a~11t~a~17t~a~28t~a~39t~a~50t~a~61t~a~73t~a\n"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abs?&nbsp;path&nbsp;first&nbsp;rest&nbsp;parent&nbsp;last&nbsp;root&nbsp;extension)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(print-row&nbsp;"path"&nbsp;"abs"&nbsp;"first"&nbsp;"rest"&nbsp;"parent"&nbsp;"last"&nbsp;"root"&nbsp;"ext")<br>

&nbsp;&nbsp;&nbsp;&nbsp;(for-each<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(path)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;uscore&nbsp;(lambda&nbsp;(s)&nbsp;(if&nbsp;(eqv?&nbsp;s&nbsp;"")&nbsp;"_"&nbsp;s)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;print-row&nbsp;path<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(s)&nbsp;(if&nbsp;(eqv?&nbsp;s&nbsp;"")&nbsp;"_"&nbsp;s))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(path-absolute?&nbsp;path)&nbsp;(path-first&nbsp;path)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(path-rest&nbsp;path)&nbsp;(path-parent&nbsp;path)&nbsp;(path-last&nbsp;path)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(path-root&nbsp;path)&nbsp;(path-extension&nbsp;path)))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path*)))</tt>
<p>For example, the first table can be produced with:

<p>

<p><tt>(print-table&nbsp;"a"&nbsp;"a/"&nbsp;"a/b"&nbsp;"a/b.c"&nbsp;"/"&nbsp;"/a/b.c"&nbsp;"~/a/b.c"<br>

&nbsp;&nbsp;"~u/a/b.c"&nbsp;"../..")</tt>
<p>while the second can be produced (under Windows) with:

<p>

<p><tt>(print-table&nbsp;"c:"&nbsp;"c:/"&nbsp;"c:a/b"&nbsp;"//s/a/b.c"&nbsp;"//s.com")</tt>
<p>
<h3><a name="g94"></a><a name="./io:h17"></a>Section 9.17. Generic Port Examples<a name="SECTPORTEXAMPLES"></a></h3>



<p>
This section presents the definitions for three types of generic ports:
two-way ports, transcript ports, and process ports.

<p>
<p><b>Two-way ports.</b>&nbsp;&nbsp;<a name="./io:s161"></a>The first example defines <tt>make-two-way-port</tt>, which constructs a
textual input/output port from a given pair of textual input and output ports.
For example:

<p>

<p><tt>(define&nbsp;ip&nbsp;(open-input-string&nbsp;"this&nbsp;is&nbsp;the&nbsp;input"))<br>

(define&nbsp;op&nbsp;(open-output-string))<br>

(define&nbsp;p&nbsp;(make-two-way-port&nbsp;ip&nbsp;op))</tt>
<p>The port returned by <tt>make-two-way-port</tt> is both an input and an output
port, and it is also a textual port:

<p>

<p><tt>(port?&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(input-port?&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(output-port?&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(textual-port?&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p>Items read from a two-way port come from the constituent input port,
and items written to a two-way port go to the constituent output
port:

<p>

<p><tt>(read&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;this<br>

(write&nbsp;'hello&nbsp;p)<br>

(get-output-string&nbsp;op)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;hello</tt>
<p>The definition of <tt>make-two-way-port</tt> is straightforward.
To keep the example simple,
no local buffering is performed,
although it would be more efficient to do so.

<p>

<p><tt>(define&nbsp;make-two-way-port<br>

&nbsp;&nbsp;(lambda&nbsp;(ip&nbsp;op)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;handler<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(msg&nbsp;.&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(record-case&nbsp;(cons&nbsp;msg&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[block-read&nbsp;(p&nbsp;s&nbsp;n)&nbsp;(block-read&nbsp;ip&nbsp;s&nbsp;n)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[block-write&nbsp;(p&nbsp;s&nbsp;n)&nbsp;(block-write&nbsp;op&nbsp;s&nbsp;n)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[char-ready?&nbsp;(p)&nbsp;(char-ready?&nbsp;ip)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[clear-input-port&nbsp;(p)&nbsp;(clear-input-port&nbsp;ip)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[clear-output-port&nbsp;(p)&nbsp;(clear-output-port&nbsp;op)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[close-port&nbsp;(p)&nbsp;(mark-port-closed!&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[flush-output-port&nbsp;(p)&nbsp;(flush-output-port&nbsp;op)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[file-position&nbsp;(p&nbsp;.&nbsp;pos)&nbsp;(apply&nbsp;file-position&nbsp;ip&nbsp;pos)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[file-length&nbsp;(p)&nbsp;(file-length&nbsp;ip)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[peek-char&nbsp;(p)&nbsp;(peek-char&nbsp;ip)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[port-name&nbsp;(p)&nbsp;"two-way"]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[read-char&nbsp;(p)&nbsp;(read-char&nbsp;ip)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[unread-char&nbsp;(c&nbsp;p)&nbsp;(unread-char&nbsp;c&nbsp;ip)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[write-char&nbsp;(c&nbsp;p)&nbsp;(write-char&nbsp;c&nbsp;op)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(assertion-violationf&nbsp;'two-way-port<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"operation&nbsp;~s&nbsp;not&nbsp;handled"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg)])))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(make-input/output-port&nbsp;handler&nbsp;""&nbsp;"")))</tt>
<p>Most of the messages are passed directly to one of the constituent
ports.
Exceptions are <tt>close-port</tt>, which is handled directly by
marking the port closed, <tt>port-name</tt>, which is also handled directly.
<tt>file-position</tt> and <tt>file-length</tt> are rather arbitrarily
passed off to the input port.


<p>
<p><b>Transcript ports.</b>&nbsp;&nbsp;<a name="./io:s162"></a>The next example defines <tt>make-transcript-port</tt>, which constructs a
textual input/output port from three ports:  a textual input port <tt><i>ip</i></tt> and two textual
output ports, <tt><i>op</i></tt> and <tt><i>tp</i></tt>.
Input read from a transcript port comes from <tt><i>ip</i></tt>, and output
written to a transcript port goes to <tt><i>op</i></tt>.
In this manner, transcript ports are similar to two-way ports.
Unlike two-way ports, input from <tt><i>ip</i></tt> and output to <tt><i>op</i></tt> is
also written to <tt><i>tp</i></tt>, so that <tt><i>tp</i></tt> reflects both input from
<tt><i>ip</i></tt> and output to <tt><i>op</i></tt>.

<p>
Transcript ports may be used to define the Scheme procedures
<tt>transcript-on</tt> and <tt>transcript-off</tt>, or the <i>Chez&nbsp;Scheme</i> procedure
<tt>transcript-cafe</tt>.
For example, here is a definition of <tt>transcript-cafe</tt>:

<p>

<p><tt>(define&nbsp;transcript-cafe<br>

&nbsp;&nbsp;(lambda&nbsp;(pathname)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([tp&nbsp;(open-output-file&nbsp;pathname&nbsp;'replace)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([p&nbsp;(make-transcript-port<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(console-input-port)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(console-output-port)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tp)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;set&nbsp;both&nbsp;console&nbsp;and&nbsp;current&nbsp;ports&nbsp;so&nbsp;that<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;the&nbsp;waiter&nbsp;and&nbsp;read/write&nbsp;will&nbsp;be&nbsp;in&nbsp;sync<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(parameterize&nbsp;([console-input-port&nbsp;p]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[console-output-port&nbsp;p]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[current-input-port&nbsp;p]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[current-output-port&nbsp;p])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let-values&nbsp;([vals&nbsp;(new-cafe)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(close-port&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(close-port&nbsp;tp)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;values&nbsp;vals)))))))</tt>
<p>The implementation of transcript ports is significantly more complex
than the implementation of two-way ports defined above, primarily
because it buffers input and output locally.
Local buffering is needed to allow the transcript file to reflect
accurately the actual input and output performed in the presence of
<tt>unread-char</tt>, <tt>clear-output-port</tt>, and <tt>clear-input-port</tt>.
Here is the code:


<p>

<p><tt>(define&nbsp;make-transcript-port<br>

&nbsp;&nbsp;(lambda&nbsp;(ip&nbsp;op&nbsp;tp)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(handler&nbsp;msg&nbsp;.&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(record-case&nbsp;(cons&nbsp;msg&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[block-read&nbsp;(p&nbsp;str&nbsp;cnt)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-interrupts-disabled<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([b&nbsp;(port-input-buffer&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[i&nbsp;(port-input-index&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[s&nbsp;(port-input-size&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;i&nbsp;s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([cnt&nbsp;(fxmin&nbsp;cnt&nbsp;(fx-&nbsp;s&nbsp;i))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([i&nbsp;i&nbsp;(fx+&nbsp;i&nbsp;1)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[j&nbsp;0&nbsp;(fx+&nbsp;j&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((fx=&nbsp;j&nbsp;cnt)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-input-index!&nbsp;p&nbsp;i)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-set!&nbsp;str&nbsp;j&nbsp;(string-ref&nbsp;b&nbsp;i))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([cnt&nbsp;(block-read&nbsp;ip&nbsp;str&nbsp;cnt)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(eof-object?&nbsp;cnt)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(block-write&nbsp;tp&nbsp;str&nbsp;cnt))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[char-ready?&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(&lt;&nbsp;(port-input-index&nbsp;p)&nbsp;(port-input-size&nbsp;p))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(char-ready?&nbsp;ip))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[clear-input-port&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;set&nbsp;size&nbsp;to&nbsp;zero&nbsp;rather&nbsp;than&nbsp;index&nbsp;to&nbsp;size<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;in&nbsp;order&nbsp;to&nbsp;invalidate&nbsp;unread-char<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-input-size!&nbsp;p&nbsp;0)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[clear-output-port&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-output-index!&nbsp;p&nbsp;0)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[close-port&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-interrupts-disabled<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(flush-output-port&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-output-size!&nbsp;p&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-input-size!&nbsp;p&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(mark-port-closed!&nbsp;p))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[file-position&nbsp;(p&nbsp;.&nbsp;pos)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;pos)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(most-negative-fixnum)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violationf&nbsp;'transcript-port&nbsp;"cannot&nbsp;reposition"))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[flush-output-port&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-interrupts-disabled<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([b&nbsp;(port-output-buffer&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[i&nbsp;(port-output-index&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(fx=&nbsp;i&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(block-write&nbsp;op&nbsp;b&nbsp;i)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(block-write&nbsp;tp&nbsp;b&nbsp;i)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-output-index!&nbsp;p&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-bol!&nbsp;p<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(char=?&nbsp;(string-ref&nbsp;b&nbsp;(fx-&nbsp;i&nbsp;1))&nbsp;#\newline))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(flush-output-port&nbsp;op)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(flush-output-port&nbsp;tp))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[peek-char&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-interrupts-disabled<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([b&nbsp;(port-input-buffer&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[i&nbsp;(port-input-index&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[s&nbsp;(port-input-size&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(fx&lt;&nbsp;i&nbsp;s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-ref&nbsp;b&nbsp;i)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(flush-output-port&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([s&nbsp;(block-read&nbsp;ip&nbsp;b)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eof-object?&nbsp;s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(block-write&nbsp;tp&nbsp;b&nbsp;s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-input-size!&nbsp;p&nbsp;s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-ref&nbsp;b&nbsp;0))))))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[port-name&nbsp;(p)&nbsp;"transcript"]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[constituent-ports&nbsp;(p)&nbsp;(values&nbsp;ip&nbsp;op&nbsp;tp)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[read-char&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-interrupts-disabled<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([c&nbsp;(peek-char&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(eof-object?&nbsp;c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-input-index!&nbsp;p<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fx+&nbsp;(port-input-index&nbsp;p)&nbsp;1)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[unread-char&nbsp;(c&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-interrupts-disabled<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([b&nbsp;(port-input-buffer&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[i&nbsp;(port-input-index&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[s&nbsp;(port-input-size&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;(fx=&nbsp;i&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violationf&nbsp;'unread-char<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"tried&nbsp;to&nbsp;unread&nbsp;too&nbsp;far&nbsp;on&nbsp;~s"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-input-index!&nbsp;p&nbsp;(fx-&nbsp;i&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;following&nbsp;could&nbsp;be&nbsp;skipped;&nbsp;it's&nbsp;supposed<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;to&nbsp;be&nbsp;the&nbsp;same&nbsp;character&nbsp;anyway<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-set!&nbsp;b&nbsp;(fx-&nbsp;i&nbsp;1)&nbsp;c)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[write-char&nbsp;(c&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-interrupts-disabled<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([b&nbsp;(port-output-buffer&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[i&nbsp;(port-output-index&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[s&nbsp;(port-output-size&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-set!&nbsp;b&nbsp;i&nbsp;c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;could&nbsp;check&nbsp;here&nbsp;to&nbsp;be&nbsp;sure&nbsp;that&nbsp;we&nbsp;really<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;need&nbsp;to&nbsp;flush;&nbsp;we&nbsp;may&nbsp;end&nbsp;up&nbsp;here&nbsp;even&nbsp;if<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;the&nbsp;buffer&nbsp;isn't&nbsp;full<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(block-write&nbsp;op&nbsp;b&nbsp;(fx+&nbsp;i&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(block-write&nbsp;tp&nbsp;b&nbsp;(fx+&nbsp;i&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-output-index!&nbsp;p&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-bol!&nbsp;p&nbsp;(char=?&nbsp;c&nbsp;#\newline))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[block-write&nbsp;(p&nbsp;str&nbsp;cnt)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-interrupts-disabled<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;flush&nbsp;buffered&nbsp;data<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([b&nbsp;(port-output-buffer&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[i&nbsp;(port-output-index&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(fx=&nbsp;i&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(block-write&nbsp;op&nbsp;b&nbsp;i)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(block-write&nbsp;tp&nbsp;b&nbsp;i)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-output-index!&nbsp;p&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-bol!&nbsp;p&nbsp;(char=?&nbsp;(string-ref&nbsp;b&nbsp;(fx-&nbsp;i&nbsp;1))&nbsp;#\newline))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;write&nbsp;new&nbsp;data<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(fx=&nbsp;cnt&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(block-write&nbsp;op&nbsp;str&nbsp;cnt)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(block-write&nbsp;tp&nbsp;str&nbsp;cnt)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-bol!&nbsp;p<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(char=?&nbsp;(string-ref&nbsp;str&nbsp;(fx-&nbsp;cnt&nbsp;1))&nbsp;#\newline))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(assertion-violationf&nbsp;'transcript-port<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"operation&nbsp;~s&nbsp;not&nbsp;handled"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg)]))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([ib&nbsp;(make-string&nbsp;1024)]&nbsp;[ob&nbsp;(make-string&nbsp;1024)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([p&nbsp;(make-input/output-port&nbsp;handler&nbsp;ib&nbsp;ob)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-input-size!&nbsp;p&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-output-size!&nbsp;p&nbsp;(fx-&nbsp;(string-length&nbsp;ob)&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p))))</tt>
<p>The chosen length of both the input and output ports is the same; this
is not necessary.
They could have different lengths, or one could be buffered locally and
the other not buffered locally.
Local buffering could be disabled effectively by providing zero-length
buffers.

<p>
After we create the port, the input size is set to zero since there
is not yet any data to be read.
The port output size is set to one less than the length of the buffer.
This is done so that <tt>write-char</tt> always has one character position
left over into which to write its character argument.
Although this is not necessary, it does simplify the code somewhat
while allowing the buffer to be flushed as soon as the last character
is available.

<p>
Block reads and writes are performed on the constituent ports for
efficiency and (in the case of writes) to ensure that the operations
are performed immediately.

<p>
The call to <tt>flush-output-port</tt> in the handling of <tt>read-char</tt> insures
that all output written to <tt>op</tt> appears before input is read from
<tt>ip</tt>.
Since <tt>block-read</tt> is typically used to support higher-level operations
that are performing their own buffering, or for direct input and output
in support of I/O-intensive applications, the flush call has been
omitted from that part of the handler.

<p>
Critical sections are used whenever the handler manipulates one of the
buffers, to protect against untimely interrupts that could lead to
reentry into the handler.
The critical sections are unnecessary if no such reentry is possible,
i.e., if only one "thread" of the computation can have access to the
port.

<p>
<p><b>Process ports.</b>&nbsp;&nbsp;<a name="./io:s163"></a><a name="./io:s164"></a>The final example
demonstrates how to incorporate the socket interface
defined in Section&nbsp;<a href="./foreign.html#g38">4.10</a> into a generic port that
allows transparent communication with subprocesses via normal Scheme
input/output operations.

<p>
A process port is created with <tt>open-process</tt>, which accepts a
shell command as a string.
<tt>open-process</tt> sets up a socket, forks a child process, sets up
two-way communication via the socket, and invokes the command in a
subprocess.

<p>
The sample session below demonstrates the use of <tt>open-process</tt>,
running and communicating with another Scheme process started with the
"<tt>-q</tt>" switch to suppress the greeting and prompts.

<p>

<p><tt>&gt;&nbsp;(define&nbsp;p&nbsp;(open-process&nbsp;"exec&nbsp;scheme&nbsp;-q"))<br>

&gt;&nbsp;(define&nbsp;s&nbsp;(make-string&nbsp;1000&nbsp;#\nul))<br>

&gt;&nbsp;(pretty-print&nbsp;'(+&nbsp;3&nbsp;4)&nbsp;p)<br>

&gt;&nbsp;(read&nbsp;p)<br>

7<br>

&gt;&nbsp;(pretty-print&nbsp;'(define&nbsp;(f&nbsp;x)&nbsp;(if&nbsp;(=&nbsp;x&nbsp;0)&nbsp;1&nbsp;(*&nbsp;x&nbsp;(f&nbsp;(-&nbsp;x&nbsp;1)))))&nbsp;p)<br>

&gt;&nbsp;(pretty-print&nbsp;'(f&nbsp;10)&nbsp;p)<br>

&gt;&nbsp;(read&nbsp;p)<br>

3628800<br>

&gt;&nbsp;(pretty-print&nbsp;'(exit)&nbsp;p)<br>

&gt;&nbsp;(read&nbsp;p)<br>

#!eof<br>

&gt;&nbsp;(close-port&nbsp;p)</tt>
<p>Since process ports, like transcript ports, are two-way, the implementation 
is somewhat similar.
The main difference is that a transcript port reads from and writes to its
subordinate ports, whereas a process port reads from and writes to a socket.
When a process port is opened, the socket is created and subprocess
invoked, and when the port is closed, the socket is closed and the
subprocess is terminated.

<p>

<p><tt>(define&nbsp;open-process<br>

&nbsp;&nbsp;(lambda&nbsp;(command)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;handler<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(pid&nbsp;socket)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(flush-output&nbsp;who&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([i&nbsp;(port-output-index&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;(fx&gt;&nbsp;i&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check&nbsp;who&nbsp;(c-write&nbsp;socket&nbsp;(port-output-buffer&nbsp;p)&nbsp;i))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-output-index!&nbsp;p&nbsp;0))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(msg&nbsp;.&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(record-case&nbsp;(cons&nbsp;msg&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[block-read&nbsp;(p&nbsp;str&nbsp;cnt)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-interrupts-disabled<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([b&nbsp;(port-input-buffer&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[i&nbsp;(port-input-index&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[s&nbsp;(port-input-size&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;i&nbsp;s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([cnt&nbsp;(fxmin&nbsp;cnt&nbsp;(fx-&nbsp;s&nbsp;i))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([i&nbsp;i&nbsp;(fx+&nbsp;i&nbsp;1)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[j&nbsp;0&nbsp;(fx+&nbsp;j&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((fx=&nbsp;j&nbsp;cnt)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-input-index!&nbsp;p&nbsp;i)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-set!&nbsp;str&nbsp;j&nbsp;(string-ref&nbsp;b&nbsp;i))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(flush-output&nbsp;'block-read&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([n&nbsp;(check&nbsp;'block-read<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(c-read&nbsp;socket&nbsp;str&nbsp;cnt))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(fx=&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#!eof<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n))))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[char-ready?&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(&lt;&nbsp;(port-input-index&nbsp;p)&nbsp;(port-input-size&nbsp;p))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bytes-ready?&nbsp;socket))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[clear-input-port&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;set&nbsp;size&nbsp;to&nbsp;zero&nbsp;rather&nbsp;than&nbsp;index&nbsp;to&nbsp;size<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;in&nbsp;order&nbsp;to&nbsp;invalidate&nbsp;unread-char<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-input-size!&nbsp;p&nbsp;0)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[clear-output-port&nbsp;(p)&nbsp;(set-port-output-index!&nbsp;p&nbsp;0)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[close-port&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-interrupts-disabled<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(flush-output&nbsp;'close-port&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-output-size!&nbsp;p&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-input-size!&nbsp;p&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(mark-port-closed!&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(terminate-process&nbsp;pid))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[file-length&nbsp;(p)&nbsp;0]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[file-position&nbsp;(p&nbsp;.&nbsp;pos)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;pos)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(most-negative-fixnum)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violationf&nbsp;'process-port&nbsp;"cannot&nbsp;reposition"))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[flush-output-port&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-interrupts-disabled<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(flush-output&nbsp;'flush-output-port&nbsp;p))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[peek-char&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-interrupts-disabled<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([b&nbsp;(port-input-buffer&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[i&nbsp;(port-input-index&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[s&nbsp;(port-input-size&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(fx&lt;&nbsp;i&nbsp;s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-ref&nbsp;b&nbsp;i)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(flush-output&nbsp;'peek-char&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([s&nbsp;(check&nbsp;'peek-char<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(c-read&nbsp;socket&nbsp;b&nbsp;(string-length&nbsp;b)))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(fx=&nbsp;s&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#!eof<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set-port-input-size!&nbsp;p&nbsp;s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-ref&nbsp;b&nbsp;0))))))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[port-name&nbsp;(p)&nbsp;"process"]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[read-char&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-interrupts-disabled<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([b&nbsp;(port-input-buffer&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[i&nbsp;(port-input-index&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[s&nbsp;(port-input-size&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(fx&lt;&nbsp;i&nbsp;s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-input-index!&nbsp;p&nbsp;(fx+&nbsp;i&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-ref&nbsp;b&nbsp;i))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(flush-output&nbsp;'peek-char&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([s&nbsp;(check&nbsp;'read-char<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(c-read&nbsp;socket&nbsp;b&nbsp;(string-length&nbsp;b)))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(fx=&nbsp;s&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#!eof<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set-port-input-size!&nbsp;p&nbsp;s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-input-index!&nbsp;p&nbsp;1)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-ref&nbsp;b&nbsp;0))))))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[unread-char&nbsp;(c&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-interrupts-disabled<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([b&nbsp;(port-input-buffer&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[i&nbsp;(port-input-index&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[s&nbsp;(port-input-size&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;(fx=&nbsp;i&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violationf&nbsp;'unread-char<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"tried&nbsp;to&nbsp;unread&nbsp;too&nbsp;far&nbsp;on&nbsp;~s"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-input-index!&nbsp;p&nbsp;(fx-&nbsp;i&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;following&nbsp;could&nbsp;be&nbsp;skipped;&nbsp;supposed&nbsp;to&nbsp;be<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;same&nbsp;character<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-set!&nbsp;b&nbsp;(fx-&nbsp;i&nbsp;1)&nbsp;c)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[write-char&nbsp;(c&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-interrupts-disabled<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([b&nbsp;(port-output-buffer&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[i&nbsp;(port-output-index&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[s&nbsp;(port-output-size&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-set!&nbsp;b&nbsp;i&nbsp;c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check&nbsp;'write-char&nbsp;(c-write&nbsp;socket&nbsp;b&nbsp;(fx+&nbsp;i&nbsp;1)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-output-index!&nbsp;p&nbsp;0)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[block-write&nbsp;(p&nbsp;str&nbsp;cnt)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-interrupts-disabled<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;flush&nbsp;buffered&nbsp;data<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(flush-output&nbsp;'block-write&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;write&nbsp;new&nbsp;data<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check&nbsp;'block-write&nbsp;(c-write&nbsp;socket&nbsp;str&nbsp;cnt)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violationf&nbsp;'process-port<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"operation&nbsp;~s&nbsp;not&nbsp;handled"<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg)]))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;([server-socket-name&nbsp;(tmpnam&nbsp;0)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[server-socket&nbsp;(setup-server-socket&nbsp;server-socket-name)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dofork&nbsp;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;;&nbsp;child<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check&nbsp;'close&nbsp;(close&nbsp;server-socket))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([sock&nbsp;(setup-client-socket&nbsp;server-socket-name)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dodup&nbsp;0&nbsp;sock)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dodup&nbsp;1&nbsp;sock))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check&nbsp;'execl&nbsp;(execl4&nbsp;"/bin/sh"&nbsp;"/bin/sh"&nbsp;"-c"&nbsp;command))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violationf&nbsp;'open-process&nbsp;"subprocess&nbsp;exec&nbsp;failed"))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(pid)&nbsp;;&nbsp;parent<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([sock&nbsp;(accept-socket&nbsp;server-socket)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check&nbsp;'close&nbsp;(close&nbsp;server-socket))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([ib&nbsp;(make-string&nbsp;1024)]&nbsp;[ob&nbsp;(make-string&nbsp;1024)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([p&nbsp;(make-input/output-port<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(handler&nbsp;pid&nbsp;sock)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ib&nbsp;ob)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-input-size!&nbsp;p&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-port-output-size!&nbsp;p&nbsp;(fx-&nbsp;(string-length&nbsp;ob)&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p))))))))</tt>
<p>



<hr class=copyright align=left>
<p>
<a class=plain href="index.html">Chez Scheme Version 10 User's Guide</a><br>
Copyright &copy; 2025 Cisco Systems, Inc.<br>
Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License Version 2.0</a>
(<a class=plain href="canned/copyright.html">full copyright notice.</a>).</br>
Revised October 2025 for Chez Scheme Version 10.3.0<br>
<a class=plain href="canned/about.html">about this book</a>
</tr></table>
</body>
</html>
