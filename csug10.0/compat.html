<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Compatibility Features</title>
<link href="csug.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g153"></a>
<a name="./compat:h0"></a>

<h1>Chapter 16. Compatibility Features<a name="CHPTCOMPAT"></a></h1>





<p>
This chapter describes several items that are included with current
versions of <i>Chez&nbsp;Scheme</i> primarily for compatibility with older
versions of the system.

<p>
Section&nbsp;<a href="./compat.html#g154">16.1</a> describes a hash-table interface
that has since been replaced by the R6RS hashtable interface.
Section&nbsp;<a href="./compat.html#g155">16.2</a>
describes <tt>extend-syntax</tt> macros.
These features are supported directly by current versions of <i>Chez&nbsp;Scheme</i>,
but support may be dropped in future versions.
New programs should use the standard mechanisms described
in <i>The Scheme Programming Language, 4th Edition</i>&nbsp;[<a class=citation href="./bibliography.html#g168">11</a>]
instead.

<p>
Section&nbsp;<a href="./compat.html#g156">16.3</a> describes a mechanism for defining
record-like structures as vectors instead of new unique types.
New programs should use <tt>define-record</tt>, which is described
in Section&nbsp;<a href="./objects.html#g65">7.17</a>, instead.

<p>
Section&nbsp;<a href="./compat.html#g157">16.4</a>
describes a compatibility file distributed with
<i>Chez&nbsp;Scheme</i> that contains definitions for forms and procedures no
longer supported directly by <i>Chez&nbsp;Scheme</i>.



<p>

<h3><a name="g154"></a><a name="./compat:h1"></a>Section 16.1. Hash Tables<a name="SECTCOMPATHASHTABLES"></a></h3>



<p>
The hash table procedures here are obviated by the new hash table procedures
listed in Section&nbsp;<a href="./objects.html#g62">7.14</a>.

<p>
<a name="./compat:s0"></a><span class=formdef><b>procedure</b>: <tt>(make-hash-table)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-hash-table&nbsp;<i>weak?</i>)</tt></span>
<br>
<b>returns: </b>a new hash table
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If <tt><i>weak?</i></tt> is provided and is non-false, the hash
table is a weak hash table, which means that it does not protect
keys from the garbage collector.
Keys reclaimed by the garbage collector are removed from the table,
and their associated values are dropped the next time the table
is modified, if not sooner.

<p>
<a name="./compat:s1"></a><span class=formdef><b>procedure</b>: <tt>(hash-table?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a hash table, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./compat:s2"></a><span class=formdef><b>procedure</b>: <tt>(put-hash-table!&nbsp;<i>ht</i>&nbsp;<i>k</i>&nbsp;<i>v</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>ht</i></tt> must be a hash table.
<tt><i>k</i></tt> and <tt><i>v</i></tt> may be any Scheme values.

<p>
<tt>put-hash-table!</tt> associates the value
<tt><i>v</i></tt> with the key <tt><i>k</i></tt> in <tt><i>ht</i></tt>.

<p>
<a name="./compat:s3"></a><span class=formdef><b>procedure</b>: <tt>(get-hash-table&nbsp;<i>ht</i>&nbsp;<i>k</i>&nbsp;<i>d</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>get-hash-table</tt> returns the value
associated with <tt><i>k</i></tt> in <tt><i>ht</i></tt>.
If no value is associated with <tt><i>k</i></tt> in <tt><i>ht</i></tt>,
<tt>get-hash-table</tt> returns <tt><i>d</i></tt>.

<p>
Key comparisons are performed with <tt><i>eq?</i></tt>.

<p>
Because objects may be moved by the garbage collector, <tt>get-hash-table</tt>
may need to rehash some objects and therefore cause side effects in the
hash table.
Thus, it is not safe to perform concurrent accesses of the same hash table
from multiple threads using <tt>get-hash-table</tt>.

<p>
<a name="./compat:s4"></a><span class=formdef><b>procedure</b>: <tt>(remove-hash-table!&nbsp;<i>ht</i>&nbsp;<i>k</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>remove-hash-table!</tt> drops any association
for <tt><i>k</i></tt> from <tt><i>ht</i></tt>.

<p>
<a name="./compat:s5"></a><span class=formdef><b>procedure</b>: <tt>(hash-table-map&nbsp;<i>ht</i>&nbsp;<i>p</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>hash-table-map</tt> applies <tt><i>p</i></tt> to each key, value association
in <tt><i>ht</i></tt>, in no particular order, and returns a list of the resulting
values, again in no particular order.
<tt><i>p</i></tt> should accept two arguments, a key and a value.


<p>
<a name="./compat:s6"></a><span class=formdef><b>procedure</b>: <tt>(hash-table-for-each&nbsp;<i>ht</i>&nbsp;<i>p</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>hash-table-for-each</tt> applies <tt><i>p</i></tt> to each key, value
association in <tt><i>ht</i></tt>, in no particular order.
Unlike <tt>hash-table-map</tt>, it does not create a list of the values;
instead, it's value is unspecified.
<tt><i>p</i></tt> should accept two arguments, a key and a value.


<p>

<h3><a name="g155"></a><a name="./compat:h2"></a>Section 16.2. Extend-Syntax Macros<a name="SECTCOMPATEXTENDSYNTAX"></a></h3>



<p>
This section describes <tt>extend-syntax</tt>, a powerful yet easy to use
syntactic extension facility based on
<a name="./compat:s7"></a>pattern matching&nbsp;[<a class=citation href="./bibliography.html#g184">27</a>].
Syntactic transformations written using 
<tt>extend-syntax</tt> are similar to those written using a
<tt>define-syntax</tt> with <tt>syntax-case</tt>, except that the
transformations produced by <tt>extend-syntax</tt> do not automatically
respect lexical scoping.

<p>
It is not typically possible to mix syntactic abstractions written using
<tt>syntax-case</tt> with those written using <tt>extend-syntax</tt>
seamlessly; it is generally preferable to use one or the other wherever
possible.
Support for <tt>extend-syntax</tt> within the <tt>syntax-case</tt> expander
is provided only as an aid to migrating to <tt>syntax-case</tt>.


<p>
<a name="./compat:s8"></a><span class=formdef><b>syntax</b>: <tt>(extend-syntax&nbsp;(<i>name</i>&nbsp;<i>key</i>&nbsp;...)&nbsp;(<i>pat</i>&nbsp;<i>fender</i>&nbsp;<i>template</i>)&nbsp;...)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The identifier <tt><i>name</i></tt> is the name, or syntax keyword, for the
syntactic extension to be defined.
When the system expander processes any list expression whose car is
<tt><i>name</i></tt>, the syntactic transformation procedure generated by
<tt>extend-syntax</tt> is invoked on this expression.
The remaining identifiers <tt><i>key</i>&nbsp;...</tt> are additional keywords to
be recognized within input expressions during expansion (such as
<tt>else</tt> in <tt>cond</tt> or <tt>case</tt>).

<p>
Each clause after the list of keys consists of a pattern <tt><i>pat</i></tt>, an
optional <a name="./compat:s9"></a><tt><i>fender</i></tt>,
and a <tt><i>template</i></tt>.
The optional <tt><i>fender</i></tt> is omitted more often than not.
The <tt><i>pat</i></tt> specifies the syntax the input expression must have
for the clause to be chosen.
Identifiers within the pattern that are not keywords
(<i>pattern variables</i>) are bound to corresponding pieces of the input expression.
If present, the <tt><i>fender</i></tt> is a Scheme expression that specifies
additional constraints on the input expression (accessed through the
pattern variables) that must be satisfied in order for the clause to
be chosen.
The <tt><i>template</i></tt> specifies what form the output takes, usually in
terms of the pattern variables.

<p>
During expansion, the transformation procedure <tt>extend-syntax</tt>
generates attempts to match the input expression against each
pattern in the order the clauses are given.
If the input expression matches the pattern, the pattern variables are
bound to the corresponding pieces of the input expression and the
fender for the clause, if any, is evaluated.
If the fender returns a true value, the given expansion is performed.
If input does not match the pattern or if the fender returns a false
value, the transformation procedure tries the next clause.
An exception is raised with condition type <tt>&amp;assertion</tt> if no clause can be chosen.

<p>
Within the pattern,
<a name="./compat:s10"></a><a name="./compat:s11"></a><i>ellipsis</i>
(<tt>...</tt>) may be
used to specify zero or more occurrences
of the preceding pattern fragment, or prototype.
Similarly, ellipses may be used in the output to specify the construction
of zero or more expansion prototypes.
In this case, the expansion prototype must contain part of an input pattern
prototype.
The use of patterns, templates, ellipses within patterns and templates,
and fenders is illustrated in the following sequence of examples.

<p>
The first example, defining <a name="./compat:s12"></a><tt>rec</tt>, uses a single keyword, a single
clause with no fender, and no ellipses.

<p>

<p><tt>(extend-syntax&nbsp;(rec)<br>

&nbsp;&nbsp;[(rec&nbsp;id&nbsp;val)<br>

&nbsp;&nbsp;&nbsp;(let&nbsp;([id&nbsp;#f])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;id&nbsp;val)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id)])</tt>
<p>The second example, defining <a name="./compat:s13"></a><tt>when</tt>, shows
the use of ellipses.

<p>

<p><tt>(extend-syntax&nbsp;(when)<br>

&nbsp;&nbsp;[(when&nbsp;test&nbsp;exp1&nbsp;exp2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;(if&nbsp;test&nbsp;(begin&nbsp;exp1&nbsp;exp2&nbsp;...)&nbsp;#f)])</tt>
<p>The next example shows the definition of
<a name="./compat:s14"></a><tt>let</tt>.
The definition of <tt>let</tt> shows the use of multiple ellipses, employing
one for the identifier/value pairs and one for the expressions in the body.
It also shows that the prototype need not be a single identifier, and that
pieces of the prototype may be separated from one another in the template.

<p>

<p><tt>(extend-syntax&nbsp;(let)<br>

&nbsp;&nbsp;[(let&nbsp;([x&nbsp;e]&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;((lambda&nbsp;(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;e&nbsp;...)])</tt>
<p>The next example shows <a name="./compat:s15"></a><tt>let*</tt>, whose syntax is the same as for
<tt>let</tt>, but which is defined recursively in terms of <tt>let</tt> with
two clauses (one for the base case, one for the recursion step) since
it must produce a nested structure.

<p>

<p><tt>(extend-syntax&nbsp;(let*)<br>

&nbsp;&nbsp;[(let*&nbsp;()&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;(let&nbsp;()&nbsp;b1&nbsp;b2&nbsp;...)]<br>

&nbsp;&nbsp;[(let*&nbsp;([x&nbsp;e]&nbsp;more&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;(let&nbsp;([x&nbsp;e])&nbsp;(let*&nbsp;(more&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...))])</tt>
<p>The first pattern/template pair matches any <tt>let*</tt> expression with no
identifier/value pairs and maps it into the equivalent <tt>begin</tt> expression.
This is the base case.
The second pattern/template pair matches any <tt>let*</tt> expression with one
or more identifier/value pairs and transforms it into a <tt>let</tt> expression
binding the first pair whose body is a <tt>let*</tt> expression binding the
remaining pairs.
This is the recursion step, which will eventually lead us to the base case
because we remove one identifier/value pair at each step.
Notice that the second pattern uses the pattern variable <tt>more</tt> for the
second and later identifier/value pairs; this makes the pattern and template
less cluttered and makes it clear that only the first identifier/value pair
is dealt with explicitly.

<p>
The definition for <a name="./compat:s16"></a><tt>and</tt> requires three clauses.
The first clause is necessary to recognize <tt>(and)</tt>, and the second
two define all other <tt>and</tt> forms recursively.

<p>

<p><tt>(extend-syntax&nbsp;(and)<br>

&nbsp;&nbsp;[(and)&nbsp;#t]<br>

&nbsp;&nbsp;[(and&nbsp;x)&nbsp;x]<br>

&nbsp;&nbsp;[(and&nbsp;x&nbsp;y&nbsp;...)&nbsp;(if&nbsp;x&nbsp;(and&nbsp;y&nbsp;...)&nbsp;#f)])</tt>
<p>The definition for <a name="./compat:s17"></a><tt>cond</tt> requires four clauses.
As with <tt>let*</tt>, <tt>cond</tt> must be described recursively, partly because
it produces nested <tt>if</tt> expressions, and partly because one
ellipsis prototype would not be sufficient to describe all possible
<tt>cond</tt> clauses.
The definition of <tt>cond</tt> also requires that we specify <tt>else</tt> as a
keyword, in addition to <tt>cond</tt>.
Here is the definition:

<p>

<p><tt>(extend-syntax&nbsp;(cond&nbsp;else)<br>

&nbsp;&nbsp;[(cond)&nbsp;#f]<br>

&nbsp;&nbsp;[(cond&nbsp;(else&nbsp;e1&nbsp;e2&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...)]<br>

&nbsp;&nbsp;[(cond&nbsp;(test)&nbsp;more&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;(or&nbsp;test&nbsp;(cond&nbsp;more&nbsp;...))]<br>

&nbsp;&nbsp;[(cond&nbsp;(test&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;more&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;(if&nbsp;test<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;more&nbsp;...))])</tt>
<p>Two of the clauses are base cases and two are recursion steps.
The first base case is an empty <tt>cond</tt>.
The value of <tt>cond</tt> in this case is unspecified, so the choice of
<tt>#f</tt> is somewhat arbitrary.
The second base case is a <tt>cond</tt> containing only an <tt>else</tt> clause;
this is transformed to the equivalent <tt>begin</tt> expression.
The two recursion steps differ in the number of expressions in the <tt>cond</tt>
clause.
The value of <tt>cond</tt> when the first true clause contains only the test
expression is the value of the test.
This is similar to what <tt>or</tt> does, so we expand the <tt>cond</tt> clause
into an <tt>or</tt> expression.
On the other hand, when there are expressions following the test expression,
the value of the last expression is returned, so we use <tt>if</tt> and
<tt>begin</tt>.

<p>
To be absolutely correct about the syntax of <tt>let</tt>, we actually
must require that the bound identifiers in the input are symbols.
If we typed something like <tt>(let&nbsp;([3&nbsp;x])&nbsp;x)</tt> we would not get an
error from <tt>let</tt> because it does not check to verify that the
objects in the identifier positions are symbols.
Instead, <tt>lambda</tt> may complain, or perhaps the system evaluator
long after expansion is complete. 
This is where <a name="./compat:s18"></a>fenders
are useful.

<p>

<p><tt>(extend-syntax&nbsp;(let)<br>

&nbsp;&nbsp;[(let&nbsp;([x&nbsp;e]&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;(andmap&nbsp;symbol?&nbsp;'(x&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;((lambda&nbsp;(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;e&nbsp;...)])</tt>
<p>The <a name="./compat:s19"></a><tt>andmap</tt> of <tt>symbol?</tt>
over <tt>'(x&nbsp;...)</tt> assures that each
bound identifier is a symbol.
A fender is simply a Scheme expression.
Within that expression, any quoted object is first expanded by the same
rules as the template part of the clause.
In this case, <tt>'(x&nbsp;...)</tt> is expanded to the list of identifiers from
the identifier/value pairs.

<p>
<tt>extend-syntax</tt> typically handles everything you need it for, but
some syntactic extension definitions require the ability to include the
result of evaluating an arbitrary Scheme expression.
This ability is provided by <tt>with</tt>.


<p>
<a name="./compat:s20"></a><span class=formdef><b>syntax</b>: <tt>(with&nbsp;((<i>pat</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>template</i>)</tt></span>
<br>
<b>returns: </b>processed <tt><i>template</i></tt>

<p>

<p><tt>with</tt> is valid only within an template inside of <tt>extend-syntax</tt>.
<tt>with</tt> patterns are the same as <tt>extend-syntax</tt> patterns, <tt>with</tt>
expressions are the same as <tt>extend-syntax</tt> fenders, and <tt>with</tt>
templates are the same as <tt>extend-syntax</tt> templates.

<p>
<tt>with</tt> can be used to introduce new pattern identifiers bound to
expressions produced by arbitrary Scheme expressions within
<tt>extend-syntax</tt> templates.
That is, <tt>with</tt> allows an escape from the declarative style of
<tt>extend-syntax</tt> into the procedural style of full Scheme.

<p>
One common use of <tt>with</tt> is the introduction of a temporary
identifier or list of temporary identifiers into a template.
<tt>with</tt> is also used to perform complex transformations that might
be clumsy or inefficient if performed within the <tt>extend-syntax</tt>
framework.

<p>
For example, <tt>or</tt> requires the use of a temporary identifier.
We could define <tt>or</tt> as follows.

<p>

<p><tt>(extend-syntax&nbsp;(or)<br>

&nbsp;&nbsp;[(or)&nbsp;#f]<br>

&nbsp;&nbsp;[(or&nbsp;x)&nbsp;x]<br>

&nbsp;&nbsp;[(or&nbsp;x&nbsp;y&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;(let&nbsp;([temp&nbsp;x])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;temp&nbsp;temp&nbsp;(or&nbsp;y&nbsp;...)))])</tt>
<p>This would work until we placed an <tt>or</tt> expression within the scope
of an occurrence of <tt>temp</tt>, in which case strange things could happen,
since <tt>extend-syntax</tt> does not respect lexical scoping.
(This is one of the reasons that <tt>define-syntax</tt> is preferable to
<tt>extend-syntax</tt>.)

<p>

<p><tt>(let&nbsp;([temp&nbsp;#t])<br>

&nbsp;&nbsp;(or&nbsp;#f&nbsp;temp))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>One solution is to use
<a name="./compat:s21"></a><tt>gensym</tt> and <tt>with</tt> to
create a temporary identifier, as follows.

<p>

<p><tt>(extend-syntax&nbsp;(or)<br>

&nbsp;&nbsp;[(or)&nbsp;#f]<br>

&nbsp;&nbsp;[(or&nbsp;x)&nbsp;x]<br>

&nbsp;&nbsp;[(or&nbsp;x&nbsp;y&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;(with&nbsp;([temp&nbsp;(gensym)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([temp&nbsp;x])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;temp&nbsp;temp&nbsp;(or&nbsp;y&nbsp;...))))])</tt>
<p>Also, <tt>with</tt> can be used to combine elements of the input pattern
in ways not possible directly with <tt>extend-syntax</tt>, such as the
following <tt>folding-plus</tt> example.

<p>

<p><tt>(extend-syntax&nbsp;(folding-plus)<br>

&nbsp;&nbsp;[(folding-plus&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;(and&nbsp;(number?&nbsp;'x)&nbsp;(number?&nbsp;'y))<br>

&nbsp;&nbsp;&nbsp;(with&nbsp;([val&nbsp;(+&nbsp;'x&nbsp;'y)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val)]<br>

&nbsp;&nbsp;[(folding-plus&nbsp;x&nbsp;y)&nbsp;(+&nbsp;x&nbsp;y)])</tt>
<p><tt>folding-plus</tt> collapses into the value of <tt>(+&nbsp;x&nbsp;y)</tt> if both
<tt>x</tt> and <tt>y</tt> are numeric constants.
Otherwise, <tt>folding-plus</tt> is transformed into <tt>(+&nbsp;x&nbsp;y)</tt> for
later evaluation.
The fender checks that the operands are numbers at expansion time, and
the <tt>with</tt> performs the evaluation.
As with fenders, expansion is performed only within a quoted expressions,
since <tt>quote</tt> sets the data apart from the remainder of the Scheme
expression.

<p>
The example below binds a list of pattern variables to a list of
temporary symbols, taking advantage of the fact that <tt>with</tt> allows
us to bind patterns to expressions.
This list of temporaries helps us to implement the <tt>sigma</tt> syntactic
extension.
<tt>sigma</tt> is similar to <tt>lambda</tt>, except it assigns the identifiers
in the identifier list instead of creating new bindings.
It may be used to perform a series of assignments in parallel.

<p>

<p><tt>(extend-syntax&nbsp;(sigma)<br>

&nbsp;&nbsp;[(sigma&nbsp;(x&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;(with&nbsp;([(t&nbsp;...)&nbsp;(map&nbsp;(lambda&nbsp;(x)&nbsp;(gensym))&nbsp;'(x&nbsp;...))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(t&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;x&nbsp;t)&nbsp;...<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e1&nbsp;e2&nbsp;...))])
<br>
<br>
(let&nbsp;([x&nbsp;'a]&nbsp;[y&nbsp;'b])<br>

&nbsp;&nbsp;((sigma&nbsp;(x&nbsp;y)&nbsp;(list&nbsp;x&nbsp;y))&nbsp;y&nbsp;x))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(b&nbsp;a)</tt>
<p>The final example below uses <tt>extend-syntax</tt> to implement
<tt>define-structure</tt>, following a similar example using
<tt>syntax-case</tt> in Section&nbsp;<a href="http://scheme.com/tspl4/./syntax.html#g137">8.4</a> of
<i>The Scheme Programming Language, 4th Edition</i>.

<p>
The definition of <tt>define-structure</tt> makes use of two pattern/template
clauses.
Two clauses are needed to handle the optionality of the second subexpression.
The first clause matches the form without the second subexpression and
merely converts it into the equivalent form with the second subexpression
present, but empty.

<p>
The definition also makes heavy use of <a name="./compat:s22"></a><tt>with</tt> to evaluate Scheme
expressions at expansion time.
The first four <tt>with</tt> clauses are used to manufacture the identifiers
that name the automatically defined procedures.
(The procedure <a name="./compat:s23"></a><tt>format</tt> is particularly useful here, but it could be
replaced with <tt>string-append!</tt>, using <tt>symbol-&gt;string</tt> as needed.)
The first two clauses yield single identifiers (for the constructor and
predicate), while the next two yield lists of identifiers (for the field
access and assignment procedures).
The fifth <tt>with</tt> clause (the final clause in the outer <tt>with</tt>)
is used to count the total length vector needed for each instance of
the structure, which must include room for the name and all of the fields.
The final <tt>with</tt> clause (the only clause in the inner <tt>with</tt>)
is used to create a list of vector indexes, one for each field (starting at
1, since the structure name occupies position 0).

<p>

<p><tt>(extend-syntax&nbsp;(define-structure)<br>

&nbsp;&nbsp;[(define-structure&nbsp;(name&nbsp;id1&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;(define-structure&nbsp;(name&nbsp;id1&nbsp;...)&nbsp;())]<br>

&nbsp;&nbsp;[(define-structure&nbsp;(name&nbsp;id1&nbsp;...)&nbsp;([id2&nbsp;val]&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;(with&nbsp;([constructor<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;symbol&nbsp;(format&nbsp;"make-~a"&nbsp;'name))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[predicate<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;symbol&nbsp;(format&nbsp;"~a?"&nbsp;'name))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(access&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;symbol<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(format&nbsp;"~a-~a"&nbsp;'name&nbsp;x)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(id1&nbsp;...&nbsp;id2&nbsp;...))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(assign&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;symbol<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(format&nbsp;"set-~a-~a!"&nbsp;'name&nbsp;x)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(id1&nbsp;...&nbsp;id2&nbsp;...))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[count&nbsp;(length&nbsp;'(name&nbsp;id1&nbsp;...&nbsp;id2&nbsp;...))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with&nbsp;([(index&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([i&nbsp;1])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;i&nbsp;'count)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;i&nbsp;(f&nbsp;(+&nbsp;i&nbsp;1)))))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;constructor<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(id1&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;([id2&nbsp;val]&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector&nbsp;'name&nbsp;id1&nbsp;...&nbsp;id2&nbsp;...))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;predicate<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(obj)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(vector?&nbsp;obj)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(=&nbsp;(vector-length&nbsp;obj)&nbsp;count)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eq?&nbsp;(vector-ref&nbsp;obj&nbsp;0)&nbsp;'name))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;access<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(obj)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-ref&nbsp;obj&nbsp;index)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;assign<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(obj&nbsp;newval)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-set!&nbsp;obj&nbsp;index&nbsp;newval)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...)))])</tt>
<p>
<h3><a name="g156"></a><a name="./compat:h3"></a>Section 16.3. Structures<a name="SECTCOMPATSTRUCTURES"></a></h3>



<p>
<a name="./compat:s24"></a>This section describes a mechanism, similar
to the record-defining mechanisms of Section&nbsp;<a href="./objects.html#g65">7.17</a>,
that permits the creation of data structures
with fixed sets of named fields.
Unlike record types, structure types are not unique types, but are
instead implemented as vectors.
Specifically, a structure is implemented as a vector whose length is
one more than the number of fields and whose first element contains
the symbolic name of the structure.

<p>
The representation of structures as vectors
simplifies reading and printing of structures somewhat as well
as extension of the structure definition facility.
It does, however, have some drawbacks.
One is that structures may be treated as ordinary vectors by mistake in
situations where doing so is inappropriate.
When dealing with both structures and vectors in a program, care must
be taken to look for the more specific structure type before checking
for the more generic vector type, e.g., in a series of <tt>cond</tt>
clauses.
A similar drawback is that structure instances are easily "forged," either
intentionally or by accident.
It is also impossible to control how structures are printed and read.

<p>
Structures are created via <tt>define-structure</tt>.
Each structure definition defines a constructor
procedure, a type predicate, an access procedure for each of its fields,
and an assignment procedure for each of its fields.
<tt>define-structure</tt> allows the programmer to control which fields
are arguments to the generated constructor procedure and which fields
are explicitly initialized by the constructor procedure.

<p>
<tt>define-structure</tt> is simple
yet powerful enough for most applications, and it is easily
extended to handle many applications for which it is not sufficient.
The definition of <tt>define-structure</tt> given at the end of
this section can serve as a starting point for more complicated
variants.

<p>
<a name="./compat:s25"></a><span class=formdef><b>syntax</b>: <tt>(define-structure&nbsp;(<i>name</i>&nbsp;<i>id<sub>1</sub></i>&nbsp;...)&nbsp;((<i>id<sub>2</sub></i>&nbsp;<i>expr</i>)&nbsp;...))</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A <tt>define-structure</tt> form is a definition and may appear anywhere
and only where other definitions may appear.

<p>
<tt>define-structure</tt> defines a new data structure, <tt><i>name</i></tt>, and
creates a set of procedures for creating and manipulating instances of
the structure.
The identifiers <tt><i>id<sub>1</sub></i>&nbsp;...</tt> and <tt><i>id<sub>2</sub></i>&nbsp;...</tt>
name the fields of the data structure.

<p>
The following procedures are defined by <tt>define-structure</tt>:

<p>
<ul>
<li>a constructor procedure whose name is <tt>make-<i>name</i></tt>,

<p>
<li>a type predicate whose name is <tt><i>name</i>?</tt>,

<p>
<li>an access procedure whose name is <tt><i>name</i>-<i>field</i></tt>
for each field name <tt><i>id<sub>1</sub></i>&nbsp;...</tt> and
<tt><i>id<sub>2</sub></i>&nbsp;...</tt>, and

<p>
<li>an assignment procedure whose name is
<tt>set-<i>name</i>-<i>field</i>!</tt>
for each field name <tt><i>id<sub>1</sub></i>&nbsp;...</tt> and <tt><i>id<sub>2</sub></i>&nbsp;...</tt>.
</ul>
<p>

<p>
The fields named by the identifiers <tt><i>id<sub>1</sub></i>&nbsp;...</tt> are
initialized by the arguments to the constructor procedure.
The fields named by the identifiers <tt><i>id<sub>2</sub></i>&nbsp;...</tt> are initialized
explicitly to the values of the expressions <tt><i>expr</i>&nbsp;...</tt>.
Each expression is evaluated within the scope of the identifiers
<tt><i>id<sub>1</sub></i>&nbsp;...</tt> (bound to the corresponding field values) and any
of the identifiers <tt><i>id<sub>2</sub></i>&nbsp;...</tt> (bound to the corresponding field
values) appearing before it (as if within a <tt>let*</tt>).

<p>
To clarify, the constructor behaves as if defined as

<p>

<p><tt>(define&nbsp;make-<i>name</i><br>

&nbsp;&nbsp;(lambda&nbsp;(<i>id<sub>1</sub></i>&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;([<i>id<sub>2</sub></i>&nbsp;<i>expr</i>]&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>body</i>)))</tt>
<p>where <tt><i>body</i></tt> builds the structure from the values of the identifiers
<tt><i>id<sub>1</sub></i>&nbsp;...</tt> and <tt><i>id<sub>2</sub></i>&nbsp;...</tt>.

<p>
If no fields other than those initialized by the arguments to the
constructor procedure are needed, the second subexpression,
<tt>((<i>id<sub>2</sub></i>&nbsp;<i>expr</i>)&nbsp;...)</tt>, may be omitted.

<p>
<a name="./compat:s26"></a><a name="./compat:s27"></a>The following simple example
demonstrates how pairs might be defined in Scheme if they did not
already exist.
Both fields are initialized by the arguments to the constructor
procedure.

<p>

<p><tt>(define-structure&nbsp;(pare&nbsp;car&nbsp;cdr))<br>

(define&nbsp;p&nbsp;(make-pare&nbsp;'a&nbsp;'b))
<br>
<br>
(pare?&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(pair?&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(pare?&nbsp;'(a&nbsp;.&nbsp;b))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(pare-car&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;a<br>

(pare-cdr&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;b
<br>
<br>
(set-pare-cdr!&nbsp;p&nbsp;(make-pare&nbsp;'b&nbsp;'c))
<br>
<br>
(pare-car&nbsp;(pare-cdr&nbsp;p))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;b<br>

(pare-cdr&nbsp;(pare-cdr&nbsp;p))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;c</tt>
<p>The following example defines a handy string data structure, called a
<a name="./compat:s28"></a><i>stretch-string</i>, that grows as needed.
This example uses a field explicitly initialized to a value that
depends on the value of the constructor argument fields.

<p>

<p><tt>(define-structure&nbsp;(stretch-string&nbsp;length&nbsp;fill)<br>

&nbsp;&nbsp;([string&nbsp;(make-string&nbsp;length&nbsp;fill)]))
<br>
<br>
(define&nbsp;stretch-string-ref<br>

&nbsp;&nbsp;(lambda&nbsp;(s&nbsp;i)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([n&nbsp;(stretch-string-length&nbsp;s)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;(&gt;=&nbsp;i&nbsp;n)&nbsp;(stretch-stretch-string!&nbsp;s&nbsp;(+&nbsp;i&nbsp;1)&nbsp;n))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-ref&nbsp;(stretch-string-string&nbsp;s)&nbsp;i))))
<br>
<br>
(define&nbsp;stretch-string-set!<br>

&nbsp;&nbsp;(lambda&nbsp;(s&nbsp;i&nbsp;c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([n&nbsp;(stretch-string-length&nbsp;s)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;(&gt;=&nbsp;i&nbsp;n)&nbsp;(stretch-stretch-string!&nbsp;s&nbsp;(+&nbsp;i&nbsp;1)&nbsp;n))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-set!&nbsp;(stretch-string-string&nbsp;s)&nbsp;i&nbsp;c))))
<br>
<br>
(define&nbsp;stretch-string-fill!<br>

&nbsp;&nbsp;(lambda&nbsp;(s&nbsp;c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(string-fill!&nbsp;(stretch-string-string&nbsp;s)&nbsp;c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set-stretch-string-fill!&nbsp;s&nbsp;c)))
<br>
<br>
(define&nbsp;stretch-stretch-string!<br>

&nbsp;&nbsp;(lambda&nbsp;(s&nbsp;i&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set-stretch-string-length!&nbsp;s&nbsp;i)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([str&nbsp;(stretch-string-string&nbsp;s)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[fill&nbsp;(stretch-string-fill&nbsp;s)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([xtra&nbsp;(make-string&nbsp;(-&nbsp;i&nbsp;n)&nbsp;fill)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-stretch-string-string!&nbsp;s<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-append&nbsp;str&nbsp;xtra))))))</tt>
<p>As often happens, most of the procedures defined automatically are
used only to define more specialized procedures, in this case the procedures
<tt>stretch-string-ref</tt> and <tt>stretch-string-set!</tt>.
<tt>stretch-string-length</tt> and <tt>stretch-string-string</tt> are
the only automatically defined procedures that are likely to be
called directly in code that uses stretch strings.

<p>

<p><tt>(define&nbsp;ss&nbsp;(make-stretch-string&nbsp;2&nbsp;#\X))
<br>
<br>
(stretch-string-string&nbsp;ss)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"XX"<br>

(stretch-string-ref&nbsp;ss&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#\X<br>

(stretch-string-length&nbsp;ss)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4<br>

(stretch-string-string&nbsp;ss)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"XXXX"
<br>
<br>
(stretch-string-fill!&nbsp;ss&nbsp;#\@)<br>

(stretch-string-string&nbsp;ss)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"@@@@"<br>

(stretch-string-ref&nbsp;ss&nbsp;5)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#\@<br>

(stretch-string-string&nbsp;ss)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"@@@@@@"
<br>
<br>
(stretch-string-set!&nbsp;ss&nbsp;7&nbsp;#\=)<br>

(stretch-string-length&nbsp;ss)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;8<br>

(stretch-string-string&nbsp;ss)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"@@@@@@@="</tt>
<p>Section&nbsp;<a href="http://scheme.com/tspl4/./syntax.html#g137">8.4</a> of <i>The Scheme Programming Language, 4th Edition</i> defines a simplified
variant of <tt>define-structure</tt> as an example of the use of
<a name="./compat:s29"></a><tt>syntax-case</tt>.
The definition given below implements the complete version.

<p>
<tt>define-structure</tt> expands into a series of definitions for names
generated from the structure name and field names.
The generated identifiers are created with
<a name="./compat:s30"></a><tt>datum-&gt;syntax</tt> to
make the identifiers visible where the <tt>define-structure</tt>
form appears.
Since a <tt>define-structure</tt> form expands into a <tt>begin</tt>
containing definitions, it is itself a definition and can be used
wherever definitions are valid.

<p>

<p><tt>(define-syntax&nbsp;define-structure<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;gen-id<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(template-id&nbsp;.&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(datum-&gt;syntax&nbsp;template-id<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;symbol<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;string-append<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(string?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(symbol-&gt;string<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-&gt;datum&nbsp;x))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((_&nbsp;(name&nbsp;field1&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(andmap&nbsp;identifier?&nbsp;#'(name&nbsp;field1&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(define-structure&nbsp;(name&nbsp;field1&nbsp;...)&nbsp;()))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((_&nbsp;(name&nbsp;field1&nbsp;...)&nbsp;((field2&nbsp;init)&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(andmap&nbsp;identifier?&nbsp;#'(name&nbsp;field1&nbsp;...&nbsp;field2&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((constructor&nbsp;(gen-id&nbsp;#'name&nbsp;"make-"&nbsp;#'name))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(predicate&nbsp;(gen-id&nbsp;#'name&nbsp;#'name&nbsp;"?"))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((access&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(x)&nbsp;(gen-id&nbsp;x&nbsp;#'name&nbsp;"-"&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(field1&nbsp;...&nbsp;field2&nbsp;...)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((assign&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(x)&nbsp;(gen-id&nbsp;x&nbsp;"set-"&nbsp;#'name&nbsp;"-"&nbsp;x&nbsp;"!"))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(field1&nbsp;...&nbsp;field2&nbsp;...)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(structure-length<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(length&nbsp;#'(field1&nbsp;...&nbsp;field2&nbsp;...))&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((index&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([i&nbsp;1]&nbsp;[ids&nbsp;#'(field1&nbsp;...&nbsp;field2&nbsp;...)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ids)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;i&nbsp;(f&nbsp;(+&nbsp;i&nbsp;1)&nbsp;(cdr&nbsp;ids)))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;constructor<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(field1&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;([field2&nbsp;init]&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector&nbsp;'name&nbsp;field1&nbsp;...&nbsp;field2&nbsp;...))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;predicate<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(vector?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(#3%fx=&nbsp;(vector-length&nbsp;x)&nbsp;structure-length)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eq?&nbsp;(vector-ref&nbsp;x&nbsp;0)&nbsp;'name))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;access&nbsp;(lambda&nbsp;(x)&nbsp;(vector-ref&nbsp;x&nbsp;index)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;assign<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;update)&nbsp;(vector-set!&nbsp;x&nbsp;index&nbsp;update)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...))))))</tt>
<p>
<h3><a name="g157"></a><a name="./compat:h4"></a>Section 16.4. Compatibility File<a name="SECTCOMPATOTHER"></a></h3>



<p>
Current versions of <i>Chez&nbsp;Scheme</i> are distributed with a compatibility
file containing definitions of various syntactic forms and procedures
supported by earlier versions of <i>Chez&nbsp;Scheme</i> for which support has
since been dropped.
This file, <tt>compat.ss</tt>, is typically installed in the library
subdirectory of the <i>Chez&nbsp;Scheme</i> installation directory.

<p>
In some cases, the forms and procedures found in <tt>compat.ss</tt>
have been dropped because they were infrequently used and easily
written directly in Scheme.
In other cases, the forms and procedures have been rendered obsolete by
improvements in the system.
In such cases, new code should be written to use the newer features,
and older code should be rewritten if possible to use the newer
features as well.




<hr class=copyright align=left>
<p>
<a class=plain href="index.html">Chez Scheme Version 10 User's Guide</a><br>
Copyright &copy; 2024 Cisco Systems, Inc.<br>
Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License Version 2.0</a>
(<a class=plain href="canned/copyright.html">full copyright notice.</a>).</br>
Revised February 2024 for Chez Scheme Version 10.0.0<br>
<a class=plain href="canned/about.html">about this book</a>
</tr></table>
</body>
</html>
