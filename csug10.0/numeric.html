<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Numeric Operations</title>
<link href="csug.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g67"></a>
<a name="./numeric:h0"></a>

<h1>Chapter 8. Numeric Operations<a name="CHPTNUMERIC"></a></h1>





<p>
This chapter describes <i>Chez&nbsp;Scheme</i> extensions to the standard set of
operations on numbers.
See Chapter&nbsp;<a href="http://scheme.com/tspl4/./objects.html#g106">6</a> of <i>The Scheme Programming Language, 4th Edition</i> or the Revised<sup>6</sup> Report
on Scheme for a description of standard operations on numbers.

<p>
<i>Chez&nbsp;Scheme</i> supports the full set of Scheme numeric datatypes, including
exact and inexact integer, rational, real, and complex numbers.
A variety of representations are used to support these datatypes:

<p>
<dl compact>
<dt><a name="./numeric:s0"></a><i>Fixnums</i><dd> represent exact integers in the
fixnum range (see <tt>most-negative-fixnum</tt> and
<tt>most-positive-fixnum</tt>).
The length of a string, vector, or fxvector is constrained to be a fixnum.

<p>
<dt><a name="./numeric:s1"></a><i>Bignums</i><dd> represent arbitrary-precision
exact integers outside of the fixnum range.

<p>
<dt><a name="./numeric:s2"></a><i>Ratnums</i><dd> represent arbitrary-precision
exact rational numbers.
Each ratnum contains an exact integer (fixnum
or bignum) numerator and an exact integer denominator.
Ratios are always reduced to lowest terms and never have a denominator
of one or a numerator of zero.

<p>
<dt><a name="./numeric:s3"></a><i>Flonums</i><dd> represent inexact real numbers.
Flonums are IEEE 64-bit floating-point numbers.
(Since flonums cannot represent irrational numbers, all inexact real
numbers are actually rational, although they may approximate irrational
quantities.)

<p>
<dt><a name="./numeric:s4"></a><i>Exact complexnums</i><dd>
represent exact complex numbers.
Each exact complexnum contains an exact rational (fixnum, bignum, or
ratnum) real part and an exact rational imaginary part.

<p>
<dt><a name="./numeric:s5"></a><i>Inexact complexnums</i><dd>
represent inexact complex numbers.
Each inexact complexnum contains a flonum real part and a flonum imaginary part.
</dl>

<p>
Most numbers can be represented in only one way; however, real numbers
are sometimes represented as inexact complex numbers with imaginary
component equal to zero.

<p>
<i>Chez&nbsp;Scheme</i> extends the syntax of numbers with arbitrary radixes from
two through 36, nondecimal floating-point and scientific notation,
and printed representations for
IEEE infinities and NANs. (NAN stands for "not-a-number.")

<p>
Arbitrary radixes are specified with the prefix <tt>#<i>n</i>r</tt>, where
<tt><i>n</i></tt> ranges from 2 through 36.
Digits beyond 9 are specified with the letters (in either
upper or lower case) <tt>a</tt> through <tt>z</tt>.
For example, <tt>#2r101</tt> is 5<sub>10</sub>, and
<tt>#36rZ</tt> is 35<sub>10</sub>.

<p>
For higher radixes, an ambiguity arises between the interpretation of
certain letters, e.g., <tt>e</tt>, as digits or exponent specifiers; in
such cases, the letter is assumed to be a digit.
For example, the <tt>e</tt> in <tt>#x3.2e5</tt> is interpreted as a
digit, not as an exponent marker, whereas in <tt>3.2e5</tt> it is
treated as an exponent marker.

<p>
IEEE infinities are printed as <tt>+inf.0</tt> and <tt>-inf.0</tt>,
while IEEE NANs are printed as <tt>+nan.0</tt> or <tt>-nan.0</tt>.
(+nan.0 is used on output for all NANs.)

<p>

<p><tt>(/&nbsp;1.0&nbsp;0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;+inf.0<br>

(/&nbsp;1.0&nbsp;-0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-inf.0<br>

(/&nbsp;0.0&nbsp;0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;+nan.0<br>

(/&nbsp;+inf.0&nbsp;-inf.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;+nan.0</tt>
<p>The first section of this chapter describes type-specific numeric type
predicates.
Sections&nbsp;<a href="./numeric.html#g69">8.2</a> through&nbsp;<a href="./numeric.html#g71">8.4</a>
describe fast, type-specific
numeric operations on fixnums, flonums, and inexact complex numbers
(flonums and/or inexact complexnums).
The fixnum-specific versions should be used only when the programmer
is certain that the operands and results (where appropriate) will be
fixnums, i.e., integers in the range <tt>(most-negative-fixnum)</tt> to
<tt>(most-positive-fixnum)</tt>, inclusive.
The flonum-specific versions should be used only when the
inputs and outputs (where appropriate) are certain to be flonums.
The mixed flonum/complexnum versions should be used only when the
inputs are certain to be either flonums or inexact complexnums.
Section&nbsp;<a href="./numeric.html#g72">8.5</a> describes operations, both
arbitrary precision and fixnum-specific, that allow
exact integers to be treated as sets or sequences of bits.
Random number generation is covered Section&nbsp;<a href="./numeric.html#g73">8.6</a>,
and miscellaneous numeric operations are covered in the
Section&nbsp;<a href="./numeric.html#g74">8.7</a>.


<p>

<h3><a name="g68"></a><a name="./numeric:h1"></a>Section 8.1. Numeric Type Predicates</h3>



<p>
<a name="./numeric:s6"></a><a name="./numeric:s7"></a><a name="./numeric:s8"></a><a name="./numeric:s9"></a><a name="./numeric:s10"></a>The Revised<sup>6</sup> Report distinguishes two types of special numeric objects:
fixnums and flonums.
<i>Chez&nbsp;Scheme</i> additionally distinguishes <i>bignums</i> (exact integers outside
of the fixnum range) and <i>ratnums</i> (ratios of exact integers).
It also provides a predicate for recognizing <i>cflonums</i>, which are
flonums or inexact complex numbers.

<p>
<a name="./numeric:s11"></a><span class=formdef><b>procedure</b>: <tt>(bignum?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a bignum, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(bignum?&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(bignum?&nbsp;(most-positive-fixnum))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(bignum?&nbsp;(most-negative-fixnum))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(bignum?&nbsp;(*&nbsp;(most-positive-fixnum)&nbsp;2))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(bignum?&nbsp;3/4)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(bignum?&nbsp;'a)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./numeric:s12"></a><span class=formdef><b>procedure</b>: <tt>(ratnum?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a ratnum, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(ratnum?&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(ratnum?&nbsp;(*&nbsp;(most-positive-fixnum)&nbsp;2))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(ratnum?&nbsp;3/4)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(ratnum?&nbsp;-10/2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(ratnum?&nbsp;-11/2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(ratnum?&nbsp;'a)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./numeric:s13"></a><span class=formdef><b>procedure</b>: <tt>(cflonum?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an inexact complexnum or flonum, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(cflonum?&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(cflonum?&nbsp;0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(cflonum?&nbsp;3+4i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(cflonum?&nbsp;3.0+4i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(cflonum?&nbsp;+i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(cflonum?&nbsp;+1.0i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p>
<h3><a name="g69"></a><a name="./numeric:h2"></a>Section 8.2. Fixnum Operations<a name="SECTNUMERICFIXNUM"></a></h3>



<p>
Fixnum-specific procedures normally check their inputs and outputs (where
appropriate), but at optimization level 3 the compiler generates, in most
cases, code that does not perform these checks.

<p>
<a name="./numeric:s14"></a><span class=formdef><b>procedure</b>: <tt>(most-positive-fixnum)</tt></span>
<br>
<b>returns: </b>the most positive fixnum supported by the system
<br><span class=formdef><b>procedure</b>: <tt>(most-negative-fixnum)</tt></span>
<br>
<b>returns: </b>the most negative fixnum supported by the system
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These procedures are identical to the Revised<sup>6</sup> Report
<tt>greatest-fixnum</tt> and <tt>least-fixnum</tt> procedures.


<p>
<a name="./numeric:s15"></a><span class=formdef><b>procedure</b>: <tt>(fx=&nbsp;<i>fixnum<sub>1</sub></i>&nbsp;<i>fixnum<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fx&lt;&nbsp;<i>fixnum<sub>1</sub></i>&nbsp;<i>fixnum<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fx&gt;&nbsp;<i>fixnum<sub>1</sub></i>&nbsp;<i>fixnum<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fx&lt;=&nbsp;<i>fixnum<sub>1</sub></i>&nbsp;<i>fixnum<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fx&gt;=&nbsp;<i>fixnum<sub>1</sub></i>&nbsp;<i>fixnum<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the relation holds, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The predicate <tt>fx=</tt> returns <tt>#t</tt> if its arguments are equal.
The predicate <tt>fx&lt;</tt> returns <tt>#t</tt> if its arguments are monotonically
increasing, i.e., each argument is greater than the preceding ones,
while <tt>fx&gt;</tt> returns <tt>#t</tt> if its arguments are monotonically decreasing.
The predicate <tt>fx&lt;=</tt> returns <tt>#t</tt> if its arguments are monotonically
nondecreasing, i.e., each argument is not less than the preceding ones,
while <tt>fx&gt;=</tt> returns <tt>#t</tt> if its arguments are monotonically nonincreasing.
When passed only one argument, each of these predicates returns <tt>#t</tt>.

<p>
These procedures are similar to the Revised<sup>6</sup> Report procedures
<tt>fx=?</tt>, <tt>fx&lt;?</tt>, <tt>fx&gt;?</tt>, <tt>fx&lt;=?</tt>,
and <tt>fx&gt;=?</tt> except that the Revised<sup>6</sup> Report procedures
require two or more arguments, and their names have the "<tt>?</tt>"
suffix.

<p>

<p><tt>(fx=&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fx=&nbsp;0&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fx&lt;&nbsp;(most-negative-fixnum)&nbsp;0&nbsp;(most-positive-fixnum))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;3])&nbsp;(fx&lt;=&nbsp;0&nbsp;x&nbsp;9))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fx&lt;=&nbsp;0&nbsp;3&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fx&gt;=&nbsp;0&nbsp;0&nbsp;(most-negative-fixnum))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./numeric:s16"></a><span class=formdef><b>procedure</b>: <tt>(fxnonpositive?&nbsp;<i>fixnum</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fixnum</i></tt> is not greater than zero, <tt>#f</tt> otherwise
<br><span class=formdef><b>procedure</b>: <tt>(fxnonnegative?&nbsp;<i>fixnum</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fixnum</i></tt> is not less than zero, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>fxnonpositive?</tt> is equivalent to <tt>(lambda&nbsp;(x)&nbsp;(fx&lt;=&nbsp;x&nbsp;0))</tt>,
and
<tt>fxnonnegative?</tt> is equivalent to <tt>(lambda&nbsp;(x)&nbsp;(fx&gt;=&nbsp;x&nbsp;0))</tt>.

<p>

<p><tt>(fxnonpositive?&nbsp;128)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(fxnonpositive?&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxnonpositive?&nbsp;-1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(fxnonnegative?&nbsp;-65)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(fxnonnegative?&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxnonnegative?&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./numeric:s17"></a><span class=formdef><b>procedure</b>: <tt>(fx+&nbsp;<i>fixnum</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the sum of the arguments <tt><i>fixnum</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When called with no arguments, <tt>fx+</tt> returns <tt>0</tt>.

<p>

<p><tt>(fx+)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(fx+&nbsp;1&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(fx+&nbsp;3&nbsp;4&nbsp;5)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;12<br>

(apply&nbsp;fx+&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;15</tt>
<p><a name="./numeric:s18"></a><span class=formdef><b>procedure</b>: <tt>(fx-&nbsp;<i>fixnum<sub>1</sub></i>&nbsp;<i>fixnum<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>a fixnum
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When called with one argument, <tt>fx-</tt> returns the negative of <tt><i>fixnum<sub>1</sub></i></tt>.
Thus, <tt>(fx-&nbsp;<i>fixnum<sub>1</sub></i>)</tt> is an idiom for <tt>(fx-&nbsp;0&nbsp;<i>fixnum<sub>1</sub></i>)</tt>.

<p>
When called with two or more arguments, <tt>fx-</tt> returns the result of
subtracting the sum of the numbers <tt><i>fixnum<sub>2</sub></i>&nbsp;...</tt> from
<tt><i>fixnum<sub>1</sub></i></tt>.

<p>

<p><tt>(fx-&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-3<br>

(fx-&nbsp;4&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(fx-&nbsp;4&nbsp;3&nbsp;2&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-2</tt>
<p><a name="./numeric:s19"></a><span class=formdef><b>procedure</b>: <tt>(fx*&nbsp;<i>fixnum</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the product of the arguments <tt><i>fixnum</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When called with no arguments, <tt>fx*</tt> returns <tt>1</tt>.

<p>

<p><tt>(fx*)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(fx*&nbsp;1&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2<br>

(fx*&nbsp;3&nbsp;-4&nbsp;5)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-60<br>

(apply&nbsp;fx*&nbsp;'(1&nbsp;-2&nbsp;3&nbsp;-4&nbsp;5))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;120</tt>
<p><a name="./numeric:s20"></a><span class=formdef><b>procedure</b>: <tt>(fx/&nbsp;<i>fixnum<sub>1</sub></i>&nbsp;<i>fixnum<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see explanation
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When called with one argument, <tt>fx/</tt> returns the reciprocal
of <tt><i>fixnum<sub>1</sub></i></tt>.
That is, <tt>(fx/&nbsp;<i>fixnum<sub>1</sub></i>)</tt> is an idiom for
<tt>(fx/&nbsp;1&nbsp;<i>fixnum<sub>1</sub></i>)</tt>.

<p>
When called with two or more arguments, <tt>fx/</tt> returns
the result of
dividing <tt><i>fixnum<sub>1</sub></i></tt> by the product of the remaining arguments
<tt><i>fixnum<sub>2</sub></i>&nbsp;...</tt>.

<p>

<p><tt>(fx/&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(fx/&nbsp;-17)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(fx/&nbsp;8&nbsp;-2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-4<br>

(fx/&nbsp;-9&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-4<br>

(fx/&nbsp;60&nbsp;5&nbsp;3&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2</tt>
<p><a name="./numeric:s21"></a><span class=formdef><b>procedure</b>: <tt>(fx+/wraparound&nbsp;<i>fixnum</i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fx-/wraparound&nbsp;<i>fixnum</i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fx*/wraparound&nbsp;<i>fixnum</i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fxsll/wraparound&nbsp;<i>fixnum</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the arithmetic result, wrapping on overflow
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These functions are like <tt>fx+</tt>, <tt>fx-</tt>, <tt>fx*</tt>, and
<tt>fxsll</tt>, but when the result is too large to fit in a fixnum,
as many high bits of the result as necessary are discarded to make the result representable
as a fixnum.

<p>
<a name="./numeric:s22"></a><span class=formdef><b>procedure</b>: <tt>(fx1+&nbsp;<i>fixnum</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fx1-&nbsp;<i>fixnum</i>)</tt></span>
<br>
<b>returns: </b><tt><i>fixnum</i></tt> plus 1 or <tt><i>fixnum</i></tt> minus 1
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>(define&nbsp;fxplus<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(fxzero?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fxplus&nbsp;(fx1-&nbsp;x)&nbsp;(fx1+&nbsp;y)))))
<br>
<br>
(fxplus&nbsp;7&nbsp;8)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;15</tt>
<p><tt>fx1+</tt> and <tt>fx1-</tt> can be defined as follows:

<p>

<p><tt>(define&nbsp;fx1+&nbsp;(lambda&nbsp;(x)&nbsp;(fx+&nbsp;x&nbsp;1)))<br>

(define&nbsp;fx1-&nbsp;(lambda&nbsp;(x)&nbsp;(fx-&nbsp;x&nbsp;1)))</tt>
<p><a name="./numeric:s23"></a><span class=formdef><b>procedure</b>: <tt>(fxquotient&nbsp;<i>fixnum<sub>1</sub></i>&nbsp;<i>fixnum<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see explanation
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>fxquotient</tt> is identical to <tt>fx/</tt>.
See the description of <tt>fx/</tt> above.


<p>
<a name="./numeric:s24"></a><span class=formdef><b>procedure</b>: <tt>(fxremainder&nbsp;<i>fixnum<sub>1</sub></i>&nbsp;<i>fixnum<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the fixnum remainder of <tt><i>fixnum<sub>1</sub></i></tt> divided by <tt><i>fixnum<sub>2</sub></i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The result of <tt>fxremainder</tt> has the same sign as <tt><i>fixnum<sub>1</sub></i></tt>.

<p>

<p><tt>(fxremainder&nbsp;16&nbsp;4)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(fxremainder&nbsp;5&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(fxremainder&nbsp;-45&nbsp;7)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-3<br>

(fxremainder&nbsp;10&nbsp;-3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(fxremainder&nbsp;-17&nbsp;-9)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-8</tt>
<p><a name="./numeric:s25"></a><span class=formdef><b>procedure</b>: <tt>(fxmodulo&nbsp;<i>fixnum<sub>1</sub></i>&nbsp;<i>fixnum<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the fixnum modulus of <tt><i>fixnum<sub>1</sub></i></tt> and <tt><i>fixnum<sub>2</sub></i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The result of <tt>fxmodulo</tt> has the same sign as <tt><i>fixnum<sub>2</sub></i></tt>.

<p>

<p><tt>(fxmodulo&nbsp;16&nbsp;4)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(fxmodulo&nbsp;5&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(fxmodulo&nbsp;-45&nbsp;7)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4<br>

(fxmodulo&nbsp;10&nbsp;-3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-2<br>

(fxmodulo&nbsp;-17&nbsp;-9)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-8</tt>
<p><a name="./numeric:s26"></a><span class=formdef><b>procedure</b>: <tt>(fxabs&nbsp;<i>fixnum</i>)</tt></span>
<br>
<b>returns: </b>the absolute value of <tt><i>fixnum</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(fxabs&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(fxabs&nbsp;-1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(fxabs&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0</tt>
<p>
<h3><a name="g70"></a><a name="./numeric:h3"></a>Section 8.3. Flonum Operations<a name="SECTNUMERICFLONUM"></a></h3>



<p>
Inexact real numbers are normally represented by <tt><i>flonums</i></tt>.
A flonum is a single 64-bit double-precision floating point
number.
This section describes operations on flonums, most of which accept
flonum arguments and return flonum values.
In most cases, the operations are inline-coded or coded as machine
language subroutines at optimize-level&nbsp;3 with
no argument type checking; full type checking is performed at lower
optimize levels.
Flonum-specific procedure names begin with the prefix "<tt>fl</tt>" to
set them apart from their generic counterparts.

<p>
Inexact real numbers may also be represented by inexact complexnums
with imaginary parts equal to zero, which cannot be used as input
to the flonum-specific operators.
Such numbers are produced, however, only from operations involving
complex numbers with nonzero imaginary parts, by explicit calls
to <tt>fl-make-rectangular</tt>, <tt>make-rectangular</tt>, or
<tt>make-polar</tt>, or by numeric input in either polar or rectangular
format.

<p>
<a name="./numeric:s27"></a><span class=formdef><b>procedure</b>: <tt>(flonum-&gt;fixnum&nbsp;<i>flonum</i>)</tt></span>
<br>
<b>returns: </b>the fixnum representation of <tt><i>flonum</i></tt>, truncated
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The truncated value of <tt><i>flonum</i></tt> must fall within the fixnum range.
<tt>flonum-&gt;fixnum</tt> is a restricted version of
<a name="./numeric:s28"></a><tt>exact</tt>,
which converts any numeric representation
to its exact equivalent.

<p>

<p><tt>(flonum-&gt;fixnum&nbsp;0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(flonum-&gt;fixnum&nbsp;3.9)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(flonum-&gt;fixnum&nbsp;-2.2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-2</tt>
<p><a name="./numeric:s29"></a><span class=formdef><b>procedure</b>: <tt>(fl=&nbsp;<i>flonum<sub>1</sub></i>&nbsp;<i>flonum<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fl&lt;&nbsp;<i>flonum<sub>1</sub></i>&nbsp;<i>flonum<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fl&gt;&nbsp;<i>flonum<sub>1</sub></i>&nbsp;<i>flonum<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fl&lt;=&nbsp;<i>flonum<sub>1</sub></i>&nbsp;<i>flonum<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fl&gt;=&nbsp;<i>flonum<sub>1</sub></i>&nbsp;<i>flonum<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the relation holds, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The predicate <tt>fl=</tt> returns <tt>#t</tt> if its arguments are equal.
The predicate <tt>fl&lt;</tt> returns <tt>#t</tt> if its arguments are monotonically
increasing, i.e., each argument is greater than the preceding ones,
while <tt>fl&gt;</tt> returns <tt>#t</tt> if its arguments are monotonically decreasing.
The predicate <tt>fl&lt;=</tt> returns <tt>#t</tt> if its arguments are monotonically
nondecreasing, i.e., each argument is not less than the preceding ones,
while <tt>fl&gt;=</tt> returns <tt>#t</tt> if its arguments are monotonically nonincreasing.
When passed only one argument, each of these predicates returns <tt>#t</tt>.

<p>
IEEE NANs are not comparable, i.e., comparisons involving NANs always return
<tt>#f</tt>.

<p>
These procedures are similar to the Revised<sup>6</sup> Report procedures
<tt>fl=?</tt>, <tt>fl&lt;?</tt>, <tt>fl&gt;?</tt>, <tt>fl&lt;=?</tt>,
and <tt>fl&gt;=?</tt> except that the Revised<sup>6</sup> Report procedures
require two or more arguments, and their names have the "<tt>?</tt>"
suffix.

<p>

<p><tt>(fl=&nbsp;0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fl=&nbsp;0.0&nbsp;0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fl&lt;&nbsp;-1.0&nbsp;0.0&nbsp;1.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fl&gt;&nbsp;-1.0&nbsp;0.0&nbsp;1.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(fl&lt;=&nbsp;0.0&nbsp;3.0&nbsp;3.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fl&gt;=&nbsp;4.0&nbsp;3.0&nbsp;3.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fl&lt;&nbsp;7.0&nbsp;+inf.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fl=&nbsp;+nan.0&nbsp;0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(fl=&nbsp;+nan.0&nbsp;+nan.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(fl&lt;&nbsp;+nan.0&nbsp;+nan.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(fl&gt;&nbsp;+nan.0&nbsp;+nan.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./numeric:s30"></a><span class=formdef><b>procedure</b>: <tt>(flnonpositive?&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fl</i></tt> is not greater than zero, <tt>#f</tt> otherwise
<br><span class=formdef><b>procedure</b>: <tt>(flnonnegative?&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fl</i></tt> is not less than zero, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>flnonpositive?</tt> is equivalent to <tt>(lambda&nbsp;(x)&nbsp;(fl&lt;=&nbsp;x&nbsp;0.0))</tt>,
and
<tt>flnonnegative?</tt> is equivalent to <tt>(lambda&nbsp;(x)&nbsp;(fl&gt;=&nbsp;x&nbsp;0.0))</tt>.

<p>
Even if the flonum representation distinguishes -0.0 from +0.0, both
are considered nonpositive and nonnegative.

<p>

<p><tt>(flnonpositive?&nbsp;128.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(flnonpositive?&nbsp;0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(flnonpositive?&nbsp;-0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(flnonpositive?&nbsp;-1.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(flnonnegative?&nbsp;-65.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(flnonnegative?&nbsp;0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(flnonnegative?&nbsp;-0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(flnonnegative?&nbsp;1.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(flnonnegative?&nbsp;+nan.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(flnonpositive?&nbsp;+nan.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(flnonnegative?&nbsp;+inf.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(flnonnegative?&nbsp;-inf.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./numeric:s31"></a><span class=formdef><b>procedure</b>: <tt>(flsingle&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b>a possibly less precise variant of <tt><i>fl</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Potentially discards precision from <tt><i>fl</i></tt> so that the result is
representable as a 32-bit IEEE floating-point number.

<p>
<a name="./numeric:s32"></a><span class=formdef><b>procedure</b>: <tt>(decode-float&nbsp;<i>x</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>x</i></tt> must be a flonum.
<tt>decode-float</tt> returns a vector with three integer elements,
<tt><i>m</i></tt>, <tt><i>e</i></tt>, and <tt><i>s</i></tt>, such that
<i>x</i> = <i>sm</i>2<sup>e</sup>.
It is useful primarily in the printing of floating-point numbers.

<p>

<p><tt>(decode-float&nbsp;1.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#(4503599627370496&nbsp;-52&nbsp;1)<br>

(decode-float&nbsp;-1.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#(4503599627370496&nbsp;-52&nbsp;-1)
<br>
<br>
(define&nbsp;slow-identity<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(inexact<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([v&nbsp;(decode-float&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([m&nbsp;(vector-ref&nbsp;v&nbsp;0)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[e&nbsp;(vector-ref&nbsp;v&nbsp;1)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[s&nbsp;(vector-ref&nbsp;v&nbsp;2)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;s&nbsp;m&nbsp;(expt&nbsp;2&nbsp;e)))))))
<br>
<br>
(slow-identity&nbsp;1.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1.0<br>

(slow-identity&nbsp;-1e20)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1e20</tt>
<p><a name="./numeric:s33"></a><span class=formdef><b>procedure</b>: <tt>(fllp&nbsp;<i>flonum</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>fllp</tt> returns the 12-bit integer consisting of the exponent
plus highest order represented bit of a flonum (ieee 64-bit
floating-point number).
It can be used to compute a fast approximation of the logarithm of
the number.

<p>

<p><tt>(fllp&nbsp;0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(fllp&nbsp;1.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2046<br>

(fllp&nbsp;-1.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2046
<br>
<br>
(fllp&nbsp;1.5)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2047
<br>
<br>
(fllp&nbsp;+inf.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4094<br>

(fllp&nbsp;-inf.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4094
<br>
<br>
(fllp&nbsp;#b1.0e-1111111111)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(fllp&nbsp;#b1.0e-10000000000)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0</tt>
<p>
<h3><a name="g71"></a><a name="./numeric:h4"></a>Section 8.4. Inexact Complex Operations<a name="SECTNUMERICCOMPLEXNUM"></a></h3>



<p>
The procedures described in this section provide mechanisms for
creating and operating on inexact complex numbers.
Inexact complex numbers with nonzero imaginary parts are represented as
<i>inexact complexnums</i>.
An inexact complexnum contains two 64-bit double-precision floating point
numbers.
Inexact <a name="./numeric:s34"></a><a name="./numeric:s35"></a>complex numbers
with imaginary parts equal to zero (in other words, inexact real numbers)
may be represented as either inexact complexnums or flonums.
The operations described in this section accept any mix of
inexact complexnum and flonum arguments
(collectively, "<a name="./numeric:s36"></a>cflonums").

<p>
In most cases, the operations are performed with minimal type checking
at optimize-level 3; full type checking is performed at lower optimize
levels.
Inexact complex procedure names begin with the prefix "<tt>cfl</tt>"
to set them apart from their generic counterparts.


<p>
<a name="./numeric:s37"></a><span class=formdef><b>procedure</b>: <tt>(fl-make-rectangular&nbsp;<i>flonum<sub>1</sub></i>&nbsp;<i>flonum<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>an inexact complexnum 
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The inexact complexnum produced by fl-make-rectangular has real part equal
to <tt><i>flonum<sub>1</sub></i></tt> and imaginary part equal to <tt><i>flonum<sub>2</sub></i></tt>.

<p>

<p><tt>(fl-make-rectangular&nbsp;2.0&nbsp;-3.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2.0-3.0i<br>

(fl-make-rectangular&nbsp;2.0&nbsp;0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2.0+0.0i<br>

(fl-make-rectangular&nbsp;2.0&nbsp;-0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2.0-0.0i</tt>
<p><a name="./numeric:s38"></a><span class=formdef><b>procedure</b>: <tt>(cfl-real-part&nbsp;<i>cflonum</i>)</tt></span>
<br>
<b>returns: </b>the real part of <tt><i>cflonum</i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(cfl-imag-part&nbsp;<i>cflonum</i>)</tt></span>
<br>
<b>returns: </b>the imaginary part of <tt><i>cflonum</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>

<p><tt>(cfl-real-part&nbsp;2.0-3.0i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2.0<br>

(cfl-imag-part&nbsp;2.0-3.0i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-3.0<br>

(cfl-imag-part&nbsp;2.0-0.0i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-0.0<br>

(cfl-imag-part&nbsp;2.0-inf.0i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-inf.0</tt>
<p><a name="./numeric:s39"></a><span class=formdef><b>procedure</b>: <tt>(cfl=&nbsp;<i>cflonum</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if its arguments are equal, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(cfl=&nbsp;7.0+0.0i&nbsp;7.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(cfl=&nbsp;1.0+2.0i&nbsp;1.0+2.0i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(cfl=&nbsp;1.0+2.0i&nbsp;1.0-2.0i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./numeric:s40"></a><span class=formdef><b>procedure</b>: <tt>(cfl+&nbsp;<i>cflonum</i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(cfl*&nbsp;<i>cflonum</i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(cfl-&nbsp;<i>cflonum<sub>1</sub></i>&nbsp;<i>cflonum<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(cfl/&nbsp;<i>cflonum<sub>1</sub></i>&nbsp;<i>cflonum<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>a cflonum
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These procedures compute the sum, difference, product, or quotient
of inexact complex quantities, whether these quantities are represented
by flonums or inexact complexnums.
For example, if <tt>cfl+</tt> receives two flonum arguments <i>a</i> and <i>b</i>, it
returns the sum <i>a</i> + <i>b</i>; in this case, it behaves the same as <tt>fl+</tt>.
With two inexact complexnum arguments <i>a</i> + <i>bi</i> and <i>c</i> + <i>di</i>, it returns
the sum (<i>a</i> + <i>c</i>) + (<i>b</i> + <i>d</i>)<i>i</i>.
If one argument is a flonum <i>a</i> and the other an inexact complexnum
<i>c</i> + <i>di</i>, <tt>cfl+</tt> returns (<i>a</i> + <i>c</i>) + <i>di</i>.

<p>
When passed zero arguments, <tt>cfl+</tt> returns 0.0 and
<tt>cfl*</tt> returns 1.0.
When passed one argument, <tt>cfl-</tt> returns the additive inverse
of the argument, and <tt>cfl/</tt> returns the multiplicative inverse
of the argument.
When passed three or more arguments, <tt>cfl-</tt> returns the
difference between its first and the sum of its remaining arguments,
and <tt>cfl/</tt> returns the quotient of its first and the product
of its remaining arguments.


<p>

<p><tt>(cfl+)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0.0<br>

(cfl*)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1.0<br>

(cfl-&nbsp;5.0+1.0i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-5.0-1.0i<br>

(cfl/&nbsp;2.0+2.0i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0.25-0.25i
<br>
<br>
(cfl+&nbsp;1.0+2.2i&nbsp;-3.7+5.3i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-2.7+7.5i<br>

(cfl+&nbsp;1.0&nbsp;-5.3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-4.3<br>

(cfl+&nbsp;1.0&nbsp;2.0&nbsp;-5.3i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3.0-5.3i<br>

(cfl-&nbsp;1.0+2.5i&nbsp;-3.7)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4.7+2.5i<br>

(cfl*&nbsp;1.0+2.0i&nbsp;3.0+4.0i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-5.0+10.0i<br>

(cfl/&nbsp;-5.0+10.0i&nbsp;1.0+2.0i&nbsp;2.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1.5+2.0i</tt>
<p><a name="./numeric:s41"></a><span class=formdef><b>procedure</b>: <tt>(cfl-conjugate&nbsp;<i>cflonum</i>)</tt></span>
<br>
<b>returns: </b>complex conjugate of <tt><i>cflonum</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The procedure <tt>cfl-conjugate</tt>, when passed an inexact complex argument
<i>a</i> + <i>bi</i>, returns its complex conjugate <i>a</i> + (-<i>b</i>)<i>i</i>.

<p>
See also <a name="./numeric:s42"></a><tt>conjugate</tt>, which is a generic
version of this operator that returns the complex conjugate of any
valid representation for a complex number.

<p>

<p><tt>(cfl-conjugate&nbsp;3.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3.0<br>

(cfl-conjugate&nbsp;3.0+4.0i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3.0-4.0i<br>

(cfl-conjugate&nbsp;1e-20-2e-30i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1e-20+2e-30i</tt>
<p><a name="./numeric:s43"></a><span class=formdef><b>procedure</b>: <tt>(cfl-magnitude-squared&nbsp;<i>cflonum</i>)</tt></span>
<br>
<b>returns: </b>magnitude of <tt><i>cflonum</i></tt> squared
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The procedure <tt>cfl-magnitude-squared</tt>, when passed an inexact complex
argument <i>a</i> + <i>bi</i> returns a flonum representing the magnitude of the
argument squared, i.e., <i>a</i><sup>2</sup> + <i>b</i><sup>2</sup>.

<p>
See also <a name="./numeric:s44"></a><tt>magnitude-squared</tt>,
which is a generic version of this
operator that returns the magnitude squared of any valid representation
for a complex number.
Both operations are similar to the <a name="./numeric:s45"></a><tt>magnitude</tt> procedure,
which returns the magnitude, <i>sqrt</i>(<i>a</i><sup>2</sup> + <i>b</i><sup>2</sup>), of its generic complex
argument.

<p>

<p><tt>(cfl-magnitude-squared&nbsp;3.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;9.0<br>

(cfl-magnitude-squared&nbsp;3.0-4.0i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;25.0</tt>
<p>
<h3><a name="g72"></a><a name="./numeric:h5"></a>Section 8.5. Bitwise and Logical Operators<a name="SECTNUMERICLOGICAL"></a></h3>



<p>
<i>Chez&nbsp;Scheme</i> provides a set of logical operators that allow exact
integers (fixnums and bignums) to be treated as sets or sequences
of bits.
These operators include
<tt>logand</tt> (bitwise logical <tt>and</tt>),
<tt>logior</tt> (bitwise logical <tt>or</tt>),
<tt>logxor</tt> (bitwise logical exclusive <tt>or</tt>),
<tt>lognot</tt> (bitwise logical <tt>not</tt>),
<tt>logtest</tt> (test multiple bits),
<tt>logbit?</tt> (test single bit),
<tt>logbit0</tt> (reset single bit),
<tt>logbit1</tt> (set single bit),
and <tt>ash</tt> (arithmetic shift).
Each of these operators treats its arguments as two's complement integers,
regardless of the underlying representation.
This treatment can be exploited to represent infinite sets:
a negative number represents an infinite number of one bits beyond the
leftmost zero, and a nonnegative number represents an infinite number of zero
bits beyond the leftmost one bit.

<p>
Fixnum equivalents of the logical operators are provided, as
<tt>fxlogand</tt>, <tt>fxlogior</tt>, <tt>fxlogxor</tt>,
<tt>fxlognot</tt>, <tt>fxlogtest</tt>, <tt>fxlogbit?</tt>,
<tt>fxlogbit0</tt>, and <tt>fxlogbit1</tt>.
Three separate fixnum operators are provided for shifting:
<tt>fxsll</tt> (shift-left logical),
<tt>fxsrl</tt> (shift-right logical),
<tt>fxsra</tt> (shift-right arithmetic).
Logical and arithmetic shifts differ only for right shifts.
Shift-right logical shifts in zero bits on the left end, and shift-right
arithmetic replicates the sign bit.

<p>
Logical shifts do not make sense for arbitrary-precision integers,
since these have no "left end" into which bits must be shifted.

<p>
<a name="./numeric:s46"></a><span class=formdef><b>procedure</b>: <tt>(logand&nbsp;<i>int</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the logical "and" of the arguments <tt><i>int</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The arguments must be exact integers (fixnums or bignums) and are treated
as two's complement integers, regardless of the underlying representation.
With no arguments, <tt>logand</tt> returns -1, i.e., all bits set.

<p>

<p><tt>(logand)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1<br>

(logand&nbsp;15)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;15<br>

(logand&nbsp;-1&nbsp;-1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1<br>

(logand&nbsp;-1&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(logand&nbsp;5&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(logand&nbsp;#x173C8D95&nbsp;7)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;5<br>

(logand&nbsp;#x173C8D95&nbsp;-8)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#x173C8D90<br>

(logand&nbsp;#b1100&nbsp;#b1111&nbsp;#b1101)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b1100</tt>
<p><a name="./numeric:s47"></a><span class=formdef><b>procedure</b>: <tt>(logior&nbsp;<i>int</i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(logor&nbsp;<i>int</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the logical "or" of the arguments <tt><i>int</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The arguments must be exact integers (fixnums or bignums) and are treated
as two's complement integers, regardless of the underlying representation.
With no arguments, <tt>logior</tt> returns 0, i.e., all bits reset.

<p>

<p><tt>(logior)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(logior&nbsp;15)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;15<br>

(logior&nbsp;-1&nbsp;-1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1<br>

(logior&nbsp;-1&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1<br>

(logior&nbsp;5&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;7<br>

(logior&nbsp;#b111000&nbsp;#b101010)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b111010<br>

(logior&nbsp;#b1000&nbsp;#b0100&nbsp;#b0010)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b1110<br>

(apply&nbsp;logior&nbsp;'(1&nbsp;2&nbsp;4&nbsp;8&nbsp;16))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;31</tt>
<p><a name="./numeric:s48"></a><span class=formdef><b>procedure</b>: <tt>(logxor&nbsp;<i>int</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the logical "exclusive or" of the arguments <tt><i>int</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The arguments must be exact integers (fixnums or bignums) and are treated
as two's complement integers, regardless of the underlying representation.
With no arguments, <tt>logxor</tt> returns 0, i.e., all bits reset.

<p>

<p><tt>(logxor)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(logxor&nbsp;15)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;15<br>

(logxor&nbsp;-1&nbsp;-1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(logxor&nbsp;-1&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1<br>

(logxor&nbsp;5&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;6<br>

(logxor&nbsp;#b111000&nbsp;#b101010)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b010010<br>

(logxor&nbsp;#b1100&nbsp;#b0100&nbsp;#b0110)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b1110</tt>
<p><a name="./numeric:s49"></a><span class=formdef><b>procedure</b>: <tt>(lognot&nbsp;<i>int</i>)</tt></span>
<br>
<b>returns: </b>the logical "not" of <tt><i>int</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The argument must be an exact integer (fixnum or bignum) and is treated
as a two's complement integer, regardless of the underlying representation.

<p>

<p><tt>(lognot&nbsp;-1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(lognot&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1<br>

(lognot&nbsp;7)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-8<br>

(lognot&nbsp;-8)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;7</tt>
<p><a name="./numeric:s50"></a><span class=formdef><b>procedure</b>: <tt>(logbit?&nbsp;<i>index</i>&nbsp;<i>int</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the specified bit is set, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>index</i></tt> must be a nonnegative exact integer.
<tt><i>int</i></tt> must be an exact integer (fixnum or bignum) and is treated
as a two's complement integer, regardless of the underlying representation.

<p>
<tt>logbit?</tt> returns <tt>#t</tt> if the bit at index <tt><i>index</i></tt>
of <tt><i>int</i></tt> is set (one) and <tt>#f</tt> otherwise.
The index is zero-based, counting from the lowest-order toward
higher-order bits.
There is no upper limit on the index; for nonnegative values of <tt><i>int</i></tt>,
the bits above the highest order set bit are all considered to be zero,
and for negative values, the bits above the highest order reset bit are
all considered to be one.

<p>
<tt>logbit?</tt> is equivalent to

<p>

<p><tt>(lambda&nbsp;(k&nbsp;n)&nbsp;(not&nbsp;(zero?&nbsp;(logand&nbsp;n&nbsp;(ash&nbsp;1&nbsp;k)))))</tt>
<p>but more efficient.

<p>

<p><tt>(logbit?&nbsp;0&nbsp;#b1110)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(logbit?&nbsp;1&nbsp;#b1110)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(logbit?&nbsp;2&nbsp;#b1110)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(logbit?&nbsp;3&nbsp;#b1110)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(logbit?&nbsp;4&nbsp;#b1110)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(logbit?&nbsp;100&nbsp;#b1110)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(logbit?&nbsp;0&nbsp;-6)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f&nbsp;&nbsp;;&nbsp;<i>the&nbsp;two's&nbsp;complement&nbsp;of</i>&nbsp;-6&nbsp;<i>is</i>&nbsp;1...1010<br>

(logbit?&nbsp;1&nbsp;-6)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(logbit?&nbsp;2&nbsp;-6)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(logbit?&nbsp;3&nbsp;-6)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(logbit?&nbsp;100&nbsp;-6)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(logbit?&nbsp;(random&nbsp;1000000)&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(logbit?&nbsp;(random&nbsp;1000000)&nbsp;-1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(logbit?&nbsp;20000&nbsp;(ash&nbsp;1&nbsp;20000))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./numeric:s51"></a><span class=formdef><b>procedure</b>: <tt>(logtest&nbsp;<i>int<sub>1</sub></i>&nbsp;<i>int<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if any common bits are set, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The arguments must be exact integers (fixnums or bignums) and are treated
as two's complement integers, regardless of the underlying representation.

<p>
<tt>logtest</tt> returns <tt>#t</tt> if any bit set in one argument is
also set in the other.
It returns <tt>#f</tt> if the two arguments have no set bits in common.

<p>
<tt>logtest</tt> is equivalent to

<p>

<p><tt>(lambda&nbsp;(n1&nbsp;n2)&nbsp;(not&nbsp;(zero?&nbsp;(logand&nbsp;n1&nbsp;n2))))</tt>
<p>but more efficient.

<p>

<p><tt>(logtest&nbsp;#b10001&nbsp;#b1110)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(logtest&nbsp;#b10101&nbsp;#b1110)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(logtest&nbsp;#b111000&nbsp;#b110111)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(logtest&nbsp;#b101&nbsp;-6)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f&nbsp;&nbsp;;&nbsp;<i>the&nbsp;two's&nbsp;complement&nbsp;of</i>&nbsp;-6&nbsp;<i>is</i>&nbsp;1...1010<br>

(logtest&nbsp;#b1000&nbsp;-6)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(logtest&nbsp;100&nbsp;-6)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(logtest&nbsp;(+&nbsp;(random&nbsp;1000000)&nbsp;1)&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(logtest&nbsp;(+&nbsp;(random&nbsp;1000000)&nbsp;1)&nbsp;-1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(logtest&nbsp;(ash&nbsp;#b101&nbsp;20000)&nbsp;(ash&nbsp;#b111&nbsp;20000))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./numeric:s52"></a><span class=formdef><b>procedure</b>: <tt>(logbit0&nbsp;<i>index</i>&nbsp;<i>int</i>)</tt></span>
<br>
<b>returns: </b>the result of clearing bit <tt><i>index</i></tt> of <tt><i>int</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>index</i></tt> must be a nonnegative exact integer.
<tt><i>int</i></tt> must be an exact integer (fixnum or bignum) and is treated
as a two's complement integer, regardless of the underlying representation.

<p>
The index is zero-based, counting from the lowest-order toward
higher-order bits.
As with <tt>logbit?</tt>, there is no upper limit on the index.

<p>
<tt>logbit0</tt> is equivalent to

<p>

<p><tt>(lambda&nbsp;(i&nbsp;n)&nbsp;(logand&nbsp;(lognot&nbsp;(ash&nbsp;1&nbsp;i))&nbsp;n))</tt>
<p>but more efficient.

<p>

<p><tt>(logbit0&nbsp;3&nbsp;#b10101010)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b10100010<br>

(logbit0&nbsp;4&nbsp;#b10101010)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b10101010<br>

(logbit0&nbsp;0&nbsp;-1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-2</tt>
<p><a name="./numeric:s53"></a><span class=formdef><b>procedure</b>: <tt>(logbit1&nbsp;<i>index</i>&nbsp;<i>int</i>)</tt></span>
<br>
<b>returns: </b>the result of setting bit <tt><i>index</i></tt> of <tt><i>int</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>index</i></tt> must be a nonnegative exact integer.
<tt><i>int</i></tt> must be an exact integer (fixnum or bignum) and is treated
as a two's complement integer, regardless of the underlying representation.

<p>
The index is zero-based, counting from the lowest-order toward
higher-order bits.
As with <tt>logbit?</tt>, there is no upper limit on the index.

<p>
<tt>logbit1</tt> is equivalent to

<p>

<p><tt>(lambda&nbsp;(i&nbsp;n)&nbsp;(logor&nbsp;(ash&nbsp;1&nbsp;i)&nbsp;n))</tt>
<p>but more efficient.

<p>

<p><tt>(logbit1&nbsp;3&nbsp;#b10101010)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b10101010<br>

(logbit1&nbsp;4&nbsp;#b10101010)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b10111010<br>

(logbit1&nbsp;4&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b10000<br>

(logbit1&nbsp;0&nbsp;-2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1</tt>
<p><a name="./numeric:s54"></a><span class=formdef><b>procedure</b>: <tt>(ash&nbsp;<i>int</i>&nbsp;<i>count</i>)</tt></span>
<br>
<b>returns: </b><tt><i>int</i></tt> shifted left arithmetically by <tt><i>count</i></tt>.
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Both arguments must be exact integers.
The first argument is treated as a two's complement integer, regardless
of the underlying representation.
If <tt><i>count</i></tt> is negative, <tt><i>int</i></tt> is shifted right by
-<tt><i>count</i></tt> bits.

<p>

<p><tt>(ash&nbsp;8&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;8<br>

(ash&nbsp;8&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;32<br>

(ash&nbsp;8&nbsp;-2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2<br>

(ash&nbsp;-1&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-4<br>

(ash&nbsp;-1&nbsp;-2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1</tt>
<p><a name="./numeric:s55"></a><span class=formdef><b>procedure</b>: <tt>(fxlogand&nbsp;<i>fixnum</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the logical "and" of the arguments <tt><i>fixnum</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The arguments are treated as two's complement integers, regardless
of the underlying representation.
With no arguments, <tt>fxlogand</tt> returns -1, i.e., all bits set.

<p>

<p><tt>(fxlogand)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1<br>

(fxlogand&nbsp;15)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;15<br>

(fxlogand&nbsp;-1&nbsp;-1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1<br>

(fxlogand&nbsp;-1&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(fxlogand&nbsp;5&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(fxlogand&nbsp;#b111000&nbsp;#b101010)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b101000<br>

(fxlogand&nbsp;#b1100&nbsp;#b1111&nbsp;#b1101)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b1100</tt>
<p><a name="./numeric:s56"></a><span class=formdef><b>procedure</b>: <tt>(fxlogior&nbsp;<i>fixnum</i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fxlogor&nbsp;<i>fixnum</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the logical "or" of the arguments <tt><i>fixnum</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The arguments are treated as two's complement integers, regardless
of the underlying representation.
With no arguments, <tt>fxlogior</tt> returns 0, i.e., all bits reset.

<p>

<p><tt>(fxlogior)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(fxlogior&nbsp;15)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;15<br>

(fxlogior&nbsp;-1&nbsp;-1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1<br>

(fxlogior&nbsp;-1&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1<br>

(fxlogior&nbsp;#b111000&nbsp;#b101010)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b111010<br>

(fxlogior&nbsp;#b1000&nbsp;#b0100&nbsp;#b0010)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b1110<br>

(apply&nbsp;fxlogior&nbsp;'(1&nbsp;2&nbsp;4&nbsp;8&nbsp;16))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;31</tt>
<p><a name="./numeric:s57"></a><span class=formdef><b>procedure</b>: <tt>(fxlogxor&nbsp;<i>fixnum</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the logical "exclusive or" of the arguments <tt><i>fixnum</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The arguments are treated as two's complement integers, regardless
of the underlying representation.
With no arguments, <tt>fxlogxor</tt> returns 0, i.e., all bits reset.

<p>

<p><tt>(fxlogxor)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(fxlogxor&nbsp;15)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;15<br>

(fxlogxor&nbsp;-1&nbsp;-1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(fxlogxor&nbsp;-1&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1<br>

(fxlogxor&nbsp;5&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;6<br>

(fxlogxor&nbsp;#b111000&nbsp;#b101010)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b010010<br>

(fxlogxor&nbsp;#b1100&nbsp;#b0100&nbsp;#b0110)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b1110</tt>
<p><a name="./numeric:s58"></a><span class=formdef><b>procedure</b>: <tt>(fxlognot&nbsp;<i>fixnum</i>)</tt></span>
<br>
<b>returns: </b>the logical "not" of <tt><i>fixnum</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The argument is treated as a two's complement integer, regardless
of the underlying representation.

<p>

<p><tt>(fxlognot&nbsp;-1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(fxlognot&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1<br>

(fxlognot&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-2<br>

(fxlognot&nbsp;-2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1</tt>
<p><a name="./numeric:s59"></a><span class=formdef><b>procedure</b>: <tt>(fxlogbit?&nbsp;<i>index</i>&nbsp;<i>fixnum</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the specified bit is set, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>index</i></tt> must be a nonnegative fixnum.
<tt><i>fixnum</i></tt> is treated as a two's complement integer, regardless of
the underlying representation.

<p>
<tt>fxlogbit?</tt> returns <tt>#t</tt> if the bit at index <tt><i>index</i></tt>
of <tt><i>fixnum</i></tt> is set (one) and <tt>#f</tt> otherwise.
The index is zero-based, counting from the lowest-order toward
higher-order bits.
The index is limited only by the fixnum range; for nonnegative values of
<tt><i>fixnum</i></tt>, the bits above the highest order set bit are all considered
to be zero, and for negative values, the bits above the highest order
reset bit are all considered to be one.

<p>

<p><tt>(fxlogbit?&nbsp;0&nbsp;#b1110)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(fxlogbit?&nbsp;1&nbsp;#b1110)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxlogbit?&nbsp;2&nbsp;#b1110)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxlogbit?&nbsp;3&nbsp;#b1110)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxlogbit?&nbsp;4&nbsp;#b1110)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(fxlogbit?&nbsp;100&nbsp;#b1110)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(fxlogbit?&nbsp;0&nbsp;-6)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f&nbsp;&nbsp;;&nbsp;<i>the&nbsp;two's&nbsp;complement&nbsp;of</i>&nbsp;-6&nbsp;<i>is</i>&nbsp;1...1010<br>

(fxlogbit?&nbsp;1&nbsp;-6)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxlogbit?&nbsp;2&nbsp;-6)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(fxlogbit?&nbsp;3&nbsp;-6)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxlogbit?&nbsp;100&nbsp;-6)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(fxlogbit?&nbsp;(random&nbsp;1000000)&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(fxlogbit?&nbsp;(random&nbsp;1000000)&nbsp;-1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./numeric:s60"></a><span class=formdef><b>procedure</b>: <tt>(fxlogtest&nbsp;<i>fixnum<sub>1</sub></i>&nbsp;<i>fixnum<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if any common bits are set, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The arguments are treated as two's complement integers, regardless of
the underlying representation.

<p>
<tt>fxlogtest</tt> returns <tt>#t</tt> if any bit set in one argument is
also set in the other.
It returns <tt>#f</tt> if the two arguments have no set bits in common.

<p>

<p><tt>(fxlogtest&nbsp;#b10001&nbsp;#b1110)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(fxlogtest&nbsp;#b10101&nbsp;#b1110)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxlogtest&nbsp;#b111000&nbsp;#b110111)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(fxlogtest&nbsp;#b101&nbsp;-6)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f&nbsp;&nbsp;;&nbsp;<i>the&nbsp;two's&nbsp;complement&nbsp;of</i>&nbsp;-6&nbsp;<i>is</i>&nbsp;1...1010<br>

(fxlogtest&nbsp;#b1000&nbsp;-6)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxlogtest&nbsp;100&nbsp;-6)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(fxlogtest&nbsp;(+&nbsp;(random&nbsp;1000000)&nbsp;1)&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(fxlogtest&nbsp;(+&nbsp;(random&nbsp;1000000)&nbsp;1)&nbsp;-1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./numeric:s61"></a><span class=formdef><b>procedure</b>: <tt>(fxlogbit0&nbsp;<i>index</i>&nbsp;<i>fixnum</i>)</tt></span>
<br>
<b>returns: </b>the result of clearing bit <tt><i>index</i></tt> of <tt><i>fixnum</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>fixnum</i></tt> is treated
as a two's complement integer, regardless of the underlying representation.
<tt><i>index</i></tt> must be nonnegative and less than the number of
bits in a fixnum, excluding the sign bit, i.e., less than
<tt>(integer-length&nbsp;(most-positive-fixnum))</tt>.
The index is zero-based, counting from the lowest-order toward
higher-order bits.

<p>
<tt>fxlogbit0</tt> is equivalent to

<p>

<p><tt>(lambda&nbsp;(i&nbsp;n)&nbsp;(fxlogand&nbsp;(fxlognot&nbsp;(fxsll&nbsp;1&nbsp;i))&nbsp;n))</tt>
<p>but more efficient.

<p>

<p><tt>(fxlogbit0&nbsp;3&nbsp;#b10101010)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b10100010<br>

(fxlogbit0&nbsp;4&nbsp;#b10101010)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b10101010<br>

(fxlogbit0&nbsp;0&nbsp;-1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-2</tt>
<p><a name="./numeric:s62"></a><span class=formdef><b>procedure</b>: <tt>(fxlogbit1&nbsp;<i>index</i>&nbsp;<i>fixnum</i>)</tt></span>
<br>
<b>returns: </b>the result of setting bit <tt><i>index</i></tt> of <tt><i>fixnum</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>fixnum</i></tt> is treated
as a two's complement integer, regardless of the underlying representation.
<tt><i>index</i></tt> must be nonnegative and less than the number of
bits in a fixnum, excluding the sign bit, i.e., less than
<tt>(integer-length&nbsp;(most-positive-fixnum))</tt>.
The index is zero-based, counting from the lowest-order toward
higher-order bits.

<p>
<tt>fxlogbit1</tt> is equivalent to

<p>

<p><tt>(lambda&nbsp;(i&nbsp;n)&nbsp;(fxlogor&nbsp;(fxsll&nbsp;1&nbsp;i)&nbsp;n))</tt>
<p>but more efficient.

<p>

<p><tt>(fxlogbit1&nbsp;3&nbsp;#b10101010)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b10101010<br>

(fxlogbit1&nbsp;4&nbsp;#b10101010)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b10111010<br>

(fxlogbit1&nbsp;4&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#b10000<br>

(fxlogbit1&nbsp;0&nbsp;-2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1</tt>
<p><a name="./numeric:s63"></a><span class=formdef><b>procedure</b>: <tt>(fxsll&nbsp;<i>fixnum</i>&nbsp;<i>count</i>)</tt></span>
<br>
<b>returns: </b><tt><i>fixnum</i></tt> shifted left by <tt><i>count</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>fixnum</i></tt> is treated as a two's complement integer, regardless
of the underlying representation.
<tt><i>count</i></tt> must be nonnegative and not more than the number of
bits in a fixnum, i.e.,
<tt>(+&nbsp;(integer-length&nbsp;(most-positive-fixnum))&nbsp;1)</tt>.
An exception is raised with condition-type
<tt>&amp;implementation-restriction</tt> if the result cannot be represented
as a fixnum.

<p>

<p><tt>(fxsll&nbsp;1&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4<br>

(fxsll&nbsp;-1&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-4</tt>
<p><a name="./numeric:s64"></a><span class=formdef><b>procedure</b>: <tt>(fxsrl&nbsp;<i>fixnum</i>&nbsp;<i>count</i>)</tt></span>
<br>
<b>returns: </b><tt><i>fixnum</i></tt> logically shifted right by <tt><i>count</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>fixnum</i></tt> is treated as a two's complement integer, regardless
of the underlying representation.
<tt><i>count</i></tt> must be nonnegative and not more than the number of
bits in a fixnum, i.e.,
<tt>(+&nbsp;(integer-length&nbsp;(most-positive-fixnum))&nbsp;1)</tt>.

<p>

<p><tt>(fxsrl&nbsp;4&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(=&nbsp;(fxsrl&nbsp;-1&nbsp;1)&nbsp;(most-positive-fixnum))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./numeric:s65"></a><span class=formdef><b>procedure</b>: <tt>(fxsra&nbsp;<i>fixnum</i>&nbsp;<i>count</i>)</tt></span>
<br>
<b>returns: </b><tt><i>fixnum</i></tt> arithmetically shifted right by <tt><i>count</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>fixnum</i></tt> is treated as a two's complement integer, regardless
of the underlying representation.
<tt><i>count</i></tt> must be nonnegative and not more than the number of
bits in a fixnum, i.e.,
<tt>(+&nbsp;(integer-length&nbsp;(most-positive-fixnum))&nbsp;1)</tt>.

<p>

<p><tt>(fxsra&nbsp;64&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;8<br>

(fxsra&nbsp;-1&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1<br>

(fxsra&nbsp;-64&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-8</tt>
<p><a name="./numeric:s66"></a><span class=formdef><b>procedure</b>: <tt>(fxpopcount&nbsp;<i>fixnum</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fxpopcount32&nbsp;<i>fixnum</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(fxpopcount16&nbsp;<i>fixnum</i>)</tt></span>
<br>
<b>returns: </b>number of bits set in <tt><i>fixnum</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>fixnum</i></tt> must be non-negative, and it must have a width of no more than 32 for
<tt>fxpopcount32</tt> or no more than 16 for <tt>fxpopcount16</tt>.
<tt><i>fixnum</i></tt> is treated as a two's complement integer, regardless
of the underlying representation.

<p>
See also <tt>fxbit-count</tt>, which produces the same result as
<tt>fxpopcount</tt> for the domain of <tt>fxpopcount</tt>. Because
<tt>fxbit-count</tt> also handles negative arguments, however, it does
not map as simply to certain processor instructions.


<p>

<h3><a name="g73"></a><a name="./numeric:h6"></a>Section 8.6. Random Number Generation<a name="SECTNUMERICRANDOM"></a></h3>



<p>
<a name="./numeric:s67"></a><span class=formdef><b>procedure</b>: <tt>(random&nbsp;<i>real</i>)</tt></span>
<br>
<b>returns: </b>a nonnegative pseudo-random number less than <tt><i>real</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>real</i></tt> must be a positive integer or positive inexact real number.

<p>

<p><tt>(random&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(random&nbsp;1029384535235)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1029384535001,&nbsp;<i>every</i>&nbsp;<i>now</i>&nbsp;<i>and</i>&nbsp;<i>then</i><br>

(random&nbsp;1.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0.5,&nbsp;<i>every</i>&nbsp;<i>now</i>&nbsp;<i>and</i>&nbsp;<i>then</i></tt>
<p><a name="./numeric:s68"></a><span class=formdef><b>thread parameter</b>: <tt>random-seed</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The <a name="./numeric:s69"></a>random number generator allows the
current random seed to be obtained and modified via the parameter
<tt>random-seed</tt>.

<p>
When called without arguments, <tt>random-seed</tt> returns the current
random seed.
When called with one argument, which must be a nonnegative exact integer
ranging from 1 through 2<sup>32</sup> - 1, <tt>random-seed</tt> sets the current
random seed to the argument.

<p>

<p><tt>(let&nbsp;([s&nbsp;(random-seed)])<br>

&nbsp;&nbsp;(let&nbsp;([r1&nbsp;(random&nbsp;1.0)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(random-seed&nbsp;s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(eqv?&nbsp;(random&nbsp;1.0)&nbsp;r1)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./numeric:s70"></a><span class=formdef><b>procedure</b>: <tt>(make-pseudo-random-generator)</tt></span>
<br>
<b>returns: </b>a fresh pseudo-random generator
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Creates a pseudo-random generator state for use with
<tt>pseudo-random-generator-next!</tt>. This generator uses a more
modern algorithm than <tt>random</tt> and generates number sequences
that better approximate true randomness.

<p>
The initial state of the pseudo-random generator is based on the
current time, which is good enough for generating variability in most
programs but not good enough for security purposes.

<p>
<a name="./numeric:s71"></a><span class=formdef><b>procedure</b>: <tt>(pseudo-random-generator?&nbsp;<i>val</i>)</tt></span>
<br>
<b>returns: </b>a boolean
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Checks whether <tt><i>val</i></tt> is a pseudo-random generator state.

<p>
<a name="./numeric:s72"></a><span class=formdef><b>procedure</b>: <tt>(pseudo-random-generator-next!&nbsp;<i>prgen</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(pseudo-random-generator-next!&nbsp;<i>prgen</i>&nbsp;<i>below-int</i>)</tt></span>
<br>
<b>returns: </b>a pseudo-random number
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>prgen</i></tt> must be a pseudo-random generator state. If <tt><i>below-int</i></tt> is
provided, it must be a positive, exact integer.

<p>
Steps a pseudo-random generator to produce a number. The result is an
inexact number between <tt>0.0</tt> and <tt>1.0</tt>
(both exclusive) if <tt><i>below-int</i></tt> is not provided. If <tt>below-int</tt> is
provided, the result is an exact integer between <tt>0</tt> (inclusive)
and <tt>below-int</tt> (exclusive).

<p>
<a name="./numeric:s73"></a><span class=formdef><b>procedure</b>: <tt>(pseudo-random-generator-seed!&nbsp;<i>prgen</i>&nbsp;<i>seed-int</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>prgen</i></tt> must be a pseudo-random generator state, and <tt><i>seed-int</i></tt> must
be a nonnegative, exact integer.

<p>
Sets the state of a pseudo-random generator using only 31 or so bits
of <tt><i>seed-int</i></tt>. This procedure is useful for initializing the state
of a pseudo-random generator to one of a small number of known states
for triggering predictable output, but it is not a good way to put a
generator into an unpredictable state.

<p>
<a name="./numeric:s74"></a><span class=formdef><b>procedure</b>: <tt>(pseudo-random-generator-&gt;vector&nbsp;<i>prgen</i>)</tt></span>
<br>
<b>returns: </b>a vector
<br>
<b>libraries: </b><tt>(chezscheme)</tt>
<br><span class=formdef><b>procedure</b>: <tt>(vector-&gt;pseudo-random-generator&nbsp;<i>vec</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(vector-&gt;pseudo-random-generator!&nbsp;<i>prgen</i>&nbsp;<i>vec</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>prgen</i></tt> must be a pseudo-random generator state, and <tt><i>vec</i></tt> must
be a vector previously produced by <tt>pseudo-random-generator-&gt;vector</tt>.

<p>
<tt>pseudo-random-generator-&gt;vector</tt> converts the current state of
a pseudo-random generator to a vector of numbers, <tt>vector-&gt;pseudo-random-generator</tt>
creates a fresh pseudo-random generator with the same state, and
<tt>vector-&gt;pseudo-random-generator!</tt>
changes an existing pseudo-random generator to have the same state.


<p>

<h3><a name="g74"></a><a name="./numeric:h7"></a>Section 8.7. Miscellaneous Numeric Operations<a name="SECTNUMERICMISC"></a></h3>



<p>
<a name="./numeric:s75"></a><span class=formdef><b>procedure</b>: <tt>(=&nbsp;<i>num<sub>1</sub></i>&nbsp;<i>num<sub>2</sub></i>&nbsp;<i>num<sub>3</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(&lt;&nbsp;<i>real<sub>1</sub></i>&nbsp;<i>real<sub>2</sub></i>&nbsp;<i>real<sub>3</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(&gt;&nbsp;<i>real<sub>1</sub></i>&nbsp;<i>real<sub>2</sub></i>&nbsp;<i>real<sub>3</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(&lt;=&nbsp;<i>real<sub>1</sub></i>&nbsp;<i>real<sub>2</sub></i>&nbsp;<i>real<sub>3</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(&gt;=&nbsp;<i>real<sub>1</sub></i>&nbsp;<i>real<sub>2</sub></i>&nbsp;<i>real<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the relation holds, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These predicates are identical to the Revised<sup>6</sup> Report counterparts,
except they are extended to accept one or more rather than two or more
arguments.
When passed one argument, each of these predicates returns <tt>#t</tt>.

<p>

<p><tt>(&gt;&nbsp;3/4)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(&lt;&nbsp;3/4)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(=&nbsp;3/4)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./numeric:s76"></a><span class=formdef><b>procedure</b>: <tt>(1+&nbsp;<i>num</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(add1&nbsp;<i>num</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(1-&nbsp;<i>num</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(-1+&nbsp;<i>num</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(sub1&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b><tt><i>num</i></tt> plus 1 or <tt><i>num</i></tt> minus 1
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>1+</tt> and <tt>add1</tt> are equivalent to
<tt>(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;1))</tt>;
<tt>1-</tt>, <tt>-1+</tt>, and <tt>sub1</tt> are equivalent to
<tt>(lambda&nbsp;(x)&nbsp;(-&nbsp;x&nbsp;1))</tt>.

<p>

<p><tt>(define&nbsp;plus<br>

&nbsp;;&nbsp;x&nbsp;should&nbsp;be&nbsp;a&nbsp;nonnegative&nbsp;integer<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(plus&nbsp;(1-&nbsp;x)&nbsp;(1+&nbsp;y)))))
<br>
<br>
(plus&nbsp;7&nbsp;8)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;15
<br>
<br>
(define&nbsp;double<br>

&nbsp;;&nbsp;x&nbsp;should&nbsp;be&nbsp;a&nbsp;nonnegative&nbsp;integer<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add1&nbsp;(add1&nbsp;(double&nbsp;(sub1&nbsp;x)))))))
<br>
<br>
(double&nbsp;7)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;14</tt>
<p><a name="./numeric:s77"></a><span class=formdef><b>procedure</b>: <tt>(expt-mod&nbsp;<i>int<sub>1</sub></i>&nbsp;<i>int<sub>2</sub></i>&nbsp;<i>int<sub>3</sub></i>)</tt></span>
<br>
<b>returns: </b><tt><i>int<sub>1</sub></i></tt> raised to the <tt><i>int<sub>2</sub></i></tt> power, modulo <tt><i>int<sub>3</sub></i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>int<sub>1</sub></i></tt>, <tt><i>int<sub>2</sub></i></tt> and <tt><i>int<sub>3</sub></i></tt>
must be nonnegative integers.
<tt>expt-mod</tt> performs its computation in such a way that the
intermediate results are never much larger than <tt><i>int<sub>3</sub></i></tt>.
This means that when <tt><i>int<sub>2</sub></i></tt> is large, <tt>expt-mod</tt> is more efficient
than the equivalent procedure <tt>(lambda&nbsp;(x&nbsp;y&nbsp;z)&nbsp;(modulo&nbsp;(expt&nbsp;x&nbsp;y)&nbsp;z))</tt>.

<p>

<p><tt>(expt-mod&nbsp;2&nbsp;4&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(expt-mod&nbsp;2&nbsp;76543&nbsp;76543)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2</tt>
<p><a name="./numeric:s78"></a><span class=formdef><b>procedure</b>: <tt>(isqrt&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the integer square root of <tt><i>n</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>n</i></tt> must be a nonnegative integer.
The integer square root of <i>n</i> is defined to be
<img src="math/csug/1.gif" alt="<graphic>">.


<p>

<p><tt>(isqrt&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(isqrt&nbsp;16)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4<br>

(isqrt&nbsp;16.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4.0<br>

(isqrt&nbsp;20)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4<br>

(isqrt&nbsp;20.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4.0<br>

(isqrt&nbsp;(*&nbsp;2&nbsp;(expt&nbsp;10&nbsp;20)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;14142135623</tt>
<p><a name="./numeric:s79"></a><span class=formdef><b>procedure</b>: <tt>(integer-length&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The procedure <tt>integer-length</tt> returns the length in bits of
the smallest two's complement representation for <tt><i>n</i></tt>, with an
assumed leading 1 (sign) bit for negative numbers.
For zero, <tt>integer-length</tt> returns 0.

<p>

<p><tt>(integer-length&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(integer-length&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(integer-length&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2<br>

(integer-length&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2<br>

(integer-length&nbsp;4)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(integer-length&nbsp;#b10000000)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;8<br>

(integer-length&nbsp;#b11111111)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;8<br>

(integer-length&nbsp;-1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(integer-length&nbsp;-2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(integer-length&nbsp;-3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2<br>

(integer-length&nbsp;-4)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2</tt>
<p><a name="./numeric:s80"></a><span class=formdef><b>procedure</b>: <tt>(nonpositive?&nbsp;<i>real</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>real</i></tt> is not greater than zero, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>nonpositive?</tt> is equivalent to <tt>(lambda&nbsp;(x)&nbsp;(&lt;=&nbsp;x&nbsp;0))</tt>.

<p>

<p><tt>(nonpositive?&nbsp;128)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(nonpositive?&nbsp;0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(nonpositive?&nbsp;1.8e-15)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(nonpositive?&nbsp;-2/3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./numeric:s81"></a><span class=formdef><b>procedure</b>: <tt>(nonnegative?&nbsp;<i>real</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>real</i></tt> is not less than zero, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>nonnegative?</tt> is equivalent to <tt>(lambda&nbsp;(x)&nbsp;(&gt;=&nbsp;x&nbsp;0))</tt>.

<p>

<p><tt>(nonnegative?&nbsp;-65)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(nonnegative?&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(nonnegative?&nbsp;-0.0121)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(nonnegative?&nbsp;15/16)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./numeric:s82"></a><span class=formdef><b>procedure</b>: <tt>(conjugate&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b>complex conjugate of <tt><i>num</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The procedure <tt>conjugate</tt>, when passed a complex argument
<i>a</i> + <i>bi</i>, returns its complex conjugate <i>a</i> + (-<i>b</i>)<i>i</i>.

<p>

<p><tt>(conjugate&nbsp;3.0+4.0i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3.0-4.0i<br>

(conjugate&nbsp;1e-20-2e-30i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1e-20+2e-30i<br>

(conjugate&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3</tt>
<p><a name="./numeric:s83"></a><span class=formdef><b>procedure</b>: <tt>(magnitude-squared&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b>magnitude of <tt><i>num</i></tt> squared
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The procedure <tt>magnitude-squared</tt>, when passed a complex
argument <i>a</i> + <i>bi</i> returns its magnitude squared,
i.e., <i>a</i><sup>2</sup> + <i>b</i><sup>2</sup>.

<p>

<p><tt>(magnitude-squared&nbsp;3.0-4.0i)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;25.0<br>

(magnitude-squared&nbsp;3.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;9.0</tt>
<p><a name="./numeric:s84"></a><span class=formdef><b>procedure</b>: <tt>(sinh&nbsp;<i>num</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(cosh&nbsp;<i>num</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(tanh&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b>the hyperbolic sine, cosine, or tangent of <tt><i>num</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>(sinh&nbsp;0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0.0<br>

(cosh&nbsp;0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1.0<br>

(tanh&nbsp;-0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-0.0</tt>
<p><a name="./numeric:s85"></a><span class=formdef><b>procedure</b>: <tt>(asinh&nbsp;<i>num</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(acosh&nbsp;<i>num</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(atanh&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b>the hyperbolic arc sine, arc cosine, or arc tangent of <tt><i>num</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>(acosh&nbsp;0.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0.0+1.5707963267948966i<br>

(acosh&nbsp;1.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0.0<br>

(atanh&nbsp;-1.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-inf.0</tt>
<p><a name="./numeric:s86"></a><span class=formdef><b>procedure</b>: <tt>(string-&gt;number&nbsp;<i>string</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(string-&gt;number&nbsp;<i>string</i>&nbsp;<i>radix</i>)</tt></span>
<br>
<b>returns: </b>the number represented by <tt><i>string</i></tt>, or <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure is identical to the Revised<sup>6</sup> Report version except
that <tt>radix</tt> may be any exact integer between 2 and 36, inclusive.
The Revised<sup>6</sup> Report version requires radix to be in the set
{2,8,10,16}.

<p>

<p><tt>(string-&gt;number&nbsp;"211012"&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;559<br>

(string-&gt;number&nbsp;"tobeornottobe"&nbsp;36)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;140613689159812836698</tt>
<p><a name="./numeric:s87"></a><span class=formdef><b>procedure</b>: <tt>(number-&gt;string&nbsp;<i>num</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(number-&gt;string&nbsp;<i>num</i>&nbsp;<i>radix</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(number-&gt;string&nbsp;<i>num</i>&nbsp;<i>radix</i>&nbsp;<i>precision</i>)</tt></span>
<br>
<b>returns: </b>an external representation of <tt><i>num</i></tt> as a string
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure is identical to the Revised<sup>6</sup> Report version except
that <tt>radix</tt> may be any exact integer between 2 and 36, inclusive.
The Revised<sup>6</sup> Report version requires radix to be in the set
{2,8,10,16}.

<p>

<p><tt>(number-&gt;string&nbsp;10000&nbsp;4)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"2130100"<br>

(number-&gt;string&nbsp;10000&nbsp;27)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"DJA"</tt>
<p>



<hr class=copyright align=left>
<p>
<a class=plain href="index.html">Chez Scheme Version 10 User's Guide</a><br>
Copyright &copy; 2024 Cisco Systems, Inc.<br>
Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License Version 2.0</a>
(<a class=plain href="canned/copyright.html">full copyright notice.</a>).</br>
Revised February 2024 for Chez Scheme Version 10.0.0<br>
<a class=plain href="canned/about.html">about this book</a>
</tr></table>
</body>
</html>
