# Mf-base
# Copyright 1984-2021 Cisco Systems, Inc.
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
# http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Assumes recursive makes inherit command-line settings as in GNU make

# Running "make" or "make all" in this directory runs the mats (test
# programs) and produces a report of bugs and errors.  Unless you make
# changes to the mats or to the system, the report file report-$(conf)
# (where $(conf) is set below) will be output in the $(outdir) directory.

# If an error or bug report occurs, refer to the offending ".mo" file
# produced by the mats and mentioned in the bug or error report to
# determine what failed.

# Running "make allx" runs a set of mats with various settings.  "make
# bullyx" runs a different, more stressful set.  These targets allow make
# to run the various configurations in parallel (if so configured, e.g.
# with the -j flag).  Most output from each parallel execution is directed
# to (separate) files, with status printed to stdout when testing of each
# different configuration begins and ends.  In addition, each target
# concatenates the summary file from all configurations run into "summary"
# in the current directory.

# Running make with the argument "clean" removes the .so files, .mo
# files, report files, and temporary files generated by the mats.

# The variables below may be changed to affect how the mats are run.
# For example, "make o=2 cp0=t ctb=8192" causes the mats to be run at
# optimize level 2 with cp0 enabled and collect-trip-bytes set to 8192.

MatsDir = $(abspath .)

ifeq (${OS},Windows_NT)
  dirsep = ;
else
  dirsep = :
endif

# Explicit ".exe" needed for WSL
ifeq ($(OS),Windows_NT)
  ExeSuffix = .exe
else
  ExeSuffix =
endif

include ../c/Mf-config

# Scheme is the scheme executable to test, SCHEMEHEAPDIRS tells
# it where to find its boot files, and CHEZSCHEMELIBDIRS tells
# it where to find libraries.
Scheme = $(abspath ../bin/$m/scheme${ExeSuffix})
export SCHEMEHEAPDIRS=.${dirsep}$(abspath ../boot)/%m
export CHEZSCHEMELIBDIRS=.

# Include is the directory holding scheme.h.
Include = ../boot/$m

# patchfile is the name of a patch to be loaded while running the mats.
patchfile =

# o is the optimize level at which the mats should be run.
o = 0

# p determines whether profiling is enabled: f for false, t for true.
defaultp = f
p = $(defaultp)

# pdhtml determines whether profile-dump-html is called at end of a run: f for false, t for true.
# NB: beware of lost profile information due to mats that call profile-clear
defaultpdhtml = f
pdhtml = $(defaultpdhtml)

# cp0 determines whether cp0 is run: f for no, t for yes
defaultcp0 = f
cp0 = $(defaultcp0)

# eval is the evaluator to use.
defaulteval = compile
eval = $(defaulteval)

# ctb is the value to which collect-trip-bytes is set.
defaultctb = (collect-trip-bytes)
ctb = $(defaultctb)

# cn defines the value to which collect-notify is set: f for #f, t for #t
defaultcn = f
cn = $(defaultcn)

# cgr is the value to which collect-generation-radix is set.
defaultcgr = (collect-generation-radix)
cgr = $(defaultcgr)

# cmg is the value to which collect-maximum-generation is set.
defaultcmg = (collect-maximum-generation)
cmg = $(defaultcmg)

# rmg is the value to which release-minimum-generation is set.
defaultrmg = (release-minimum-generation)
rmg = $(defaultrmg)

# cis defines the value to which compile-interpret-simple is set: f for
# #f, t for #t
defaultcis = f
cis = $(defaultcis)

# spi defines the value to which suppress-primitive-inlining is set:
# f for #f, t for #t
defaultspi = f
spi = $(defaultspi)

# hci defines the value to which heap-check-interval (mat.ss) is set:
# 0 to disable, > 0 to enable
defaulthci = 0
hci = $(defaulthci)

# eoc determines whether object counts are enabled
defaulteoc = t
eoc = $(defaulteoc)

# cl determines the commonization level
defaultcl = (commonization-level)
cl = $(defaultcl)

# ecpf determines whether the compiler checks prelex flags
defaultecpf = t
ecpf = $(defaultecpf)

# c determines whether mat coverage (.covout) files are created
defaultc = f
c = $(defaultc)

# set of coverage files to load
coverage-files = $(abspath ../boot/$m/petite.covin ../boot/$m/scheme.covin)

# set of mats to run
mats = primvars 3 4 5_1 5_2 5_3 5_4 5_5 bytevector thread profile\
 misc cp0 5_6 5_7 5_8 6 io format 7 record hash enum 8 fx fl cfl foreign\
 ftype unix windows examples ieee date exceptions oop

Examples = $(abspath ../examples)

MAKEFLAGS += --no-print-directory

# directory where (most) output for this run will be written
outdir=output

conf = $(eval)-$o-$(spi)-$(cp0)-$(cis)
objdir=output-$(conf)
objname = $(mats:%=%.mo)
obj = $(objname:%=$(objdir)/%)
src = $(mats:%=%.ms)

# prettysrc is src to use for pretty-print test; we leave out mat files
# with cycles, e.g., primvars.ms, misc.ms, 4.ms, 5_1.ms, hash.ms
prettysrc = 3.ms 5_3.ms 5_4.ms 5_5.ms bytevector.ms thread.ms profile.ms\
 5_6.ms 5_7.ms 5_8.ms 6.ms io.ms format.ms 7.ms record.ms enum.ms 8.ms\
 fx.ms fl.ms cfl.ms foreign.ms unix.ms windows.ms examples.ms ieee.ms date.ms\
 exceptions.ms

define conf-scheme-code
  '(optimize-level $o)'\
  '(#%$$suppress-primitive-inlining #${spi})'\
  '(heap-check-interval ${hci})'\
  '(#%$$enable-check-prelex-flags #${ecpf})'\
  '(compile-profile #$p)'\
  '(collect-notify #${cn})'\
  '(collect-trip-bytes ${ctb})'\
  '(collect-generation-radix ${cgr})'\
  '(collect-maximum-generation ${cmg})'\
  '(enable-object-counts #${eoc})'\
  '(commonization-level ${cl})'\
  '(release-minimum-generation ${rmg})'\
  '(compile-interpret-simple #${cis})'\
  '(set! *examples-directory* "${Examples}")'\
  '(enable-cp0 #${cp0})'\
  '(set! *scheme* "${Scheme}")'\
  '(set! *mats-dir* "${MatsDir}")'\
  '(set! $$cat_flush "${MatsDir}/cat_flush${ExeSuffix}")'\
  '(current-eval ${eval})'\
  '(when #$c (coverage-table (load-coverage-files ${coverage-files:%="%"})))'
endef

$(objdir)/%.mo : %.ms mat.so
	echo $(conf-scheme-code)\
             '(time ((mat-file "$(objdir)") "$*"))'\
             '(unless (= (#%$$check-heap-errors) 0)'\
             '  (fprintf (console-error-port) "check heap detected errors---grep standard output for !!!\n")'\
             '  (abort))'\
           | ${Scheme} -q mat.so ${patchfile}

# same as above except puts the .mo file in .
%.mo : %.ms mat.so
	echo $(conf-scheme-code)\
             '(time ((mat-file ".") "$*"))'\
             '(parameterize ([source-directories (quote ("." "../s"))]) (when #${pdhtml} (profile-dump-html)))'\
             '(unless (= (#%$$check-heap-errors) 0)'\
             '  (fprintf (console-error-port) "check heap detected errors---grep standard output for !!!\n")'\
             '  (abort))'\
           | ${Scheme} -q mat.so ${patchfile}

%.so : %.ss
	echo '(reset-handler abort) (time (compile-file "$*"))' | ${Scheme} -q ${patchfile}

report: $(outdir)/report-$(conf)

experr: experr-$(conf)

$(outdir)/report-$(conf): $(outdir)/errors-$(conf)
	$(MAKE) doreport

doreport: experr-$(conf)
	rm -f $(outdir)/report-$(conf)
	-diff experr-$(conf) $(outdir)/errors-$(conf) > $(outdir)/report-$(conf) 2>&1

maybe-doreport:
	-if [ -f $(outdir)/errors-$(conf) ] ; then\
          $(MAKE) doreport ;\
         fi

$(outdir)/errors-$(conf): ${obj}
	$(MAKE) doerrors

doerrors: $(outdir)
	rm -f $(outdir)/errors-$(conf)
	-(cd $(objdir); grep '^Error' $(objname)) > $(outdir)/errors-$(conf)
	-(cd $(objdir); grep '^Bug' $(objname)) >> $(outdir)/errors-$(conf)
	-(cd $(objdir); grep '^Warning' $(objname)) >> $(outdir)/errors-$(conf)
	-(cd $(objdir); grep '^Expected' $(objname))\
         >> $(outdir)/errors-$(conf)

fastreport:
	$(MAKE) doerrors
	$(MAKE) doreport

docoverage: mat.so
	if [ "$c" = "t" ] ; then\
          echo '(reset-handler abort) (combine-coverage-files "$(objdir)/all.covout" (quote ($(mats:%="$(objdir)/%.covout"))))' | ${Scheme} -q ${patchfile} mat.so ;\
          echo '(reset-handler abort) (coverage-percent "$(objdir)/all.covout" ${coverage-files:%="%"})'  | ${Scheme} -q ${patchfile} mat.so ;\
          echo '(reset-handler abort) (coverage-percent "$(objdir)/run.covout" ${coverage-files:%="%"})'  | ${Scheme} -q ${patchfile} mat.so ;\
        fi

doallcoverage: mat.so
	if [ "$c" = "t" ] ; then\
          echo '(reset-handler abort) (combine-coverage-files "all.covout" (map symbol->string (quote ($(shell echo */all.covout)))))' | ${Scheme} -q ${patchfile} mat.so ;\
          echo '(reset-handler abort) (coverage-percent "all.covout" ${coverage-files:%="%"})'  | ${Scheme} -q ${patchfile} mat.so ;\
          echo '(reset-handler abort) (combine-coverage-files "run.covout" (map symbol->string (quote ($(shell echo */run.covout)))))' | ${Scheme} -q ${patchfile} mat.so ;\
          echo '(reset-handler abort) (coverage-percent "run.covout" ${coverage-files:%="%"})'  | ${Scheme} -q ${patchfile} mat.so ;\
        fi

define parallel-config-template
parallel$(1)-0:
	-@$$(MAKE) allxphelp outdir=output-$(1)-0 objdir=output-$(1)-0 o=0 $(2)
parallel$(1)-3:
	-@$$(MAKE) allxphelp outdir=output-$(1)-3 objdir=output-$(1)-3 o=3 $(2)
endef

#configs from partialx and allx
$(eval $(call parallel-config-template,1,))
$(eval $(call parallel-config-template,2,cp0=t))
$(eval $(call parallel-config-template,3,cp0=t cl=3))
$(eval $(call parallel-config-template,4,spi=t rmg=2 p=t))
$(eval $(call parallel-config-template,5,eval=interpret cl=6))
$(eval $(call parallel-config-template,6,eval=interpret cp0=t rmg=2))
$(eval $(call parallel-config-template,7,eoc=f hci=101 cl=9))
$(eval $(call parallel-config-template,8,eval=interpret hci=101 rmg=2))

#configs from bullyx
$(eval $(call parallel-config-template,b1,allxphelp-target=allxhelpnotall spi=t cp0=f))
$(eval $(call parallel-config-template,b2,spi=f cp0=f cl=9 ctb='(/ (collect-trip-bytes) 64)' hci=503))
$(eval $(call parallel-config-template,b3,spi=t cp0=f cis=t cmg=1))
$(eval $(call parallel-config-template,b4,spi=f cp0=f cis=t cmg=6 hci=101))
$(eval $(call parallel-config-template,b5,spi=t cp0=t ctb='(/ (collect-trip-bytes) 64)' cgr=6))
$(eval $(call parallel-config-template,b6,spi=t cp0=f p=t eoc=f hci=101))
$(eval $(call parallel-config-template,b7,spi=f cp0=t cl=9 p=t hci=101))
$(eval $(call parallel-config-template,b8,eval=interpret spi=f cp0=f))
$(eval $(call parallel-config-template,b9,eval=interpret spi=f cp0=t))
$(eval $(call parallel-config-template,b10,eval=interpret spi=t cp0=f ctb='(/ (collect-trip-bytes) 64)' hci=503))
$(eval $(call parallel-config-template,b11,eval=interpret spi=t cp0=t cgr=2 hci=101 p=t))


partialx-confs = 1-0 1-3 2-3 6-3

allx-confs = 1-0 1-3 3-0 3-3 4-0 4-3 5-0 5-3 6-0 6-3 7-0 8-3

bullyx-confs = $(foreach n,1 2 3 4 5 6 7 8 9 10 11,b$(n)-0 b$(n)-3)

define parallel-target-template
$(1)-targets: $($(1)-confs:%=parallel%)
$(1): prettyclean
	@echo building prereqs with output to Make.out
	@$$(MAKE) parallel-prereqs > Make.out 2>&1
	@$$(MAKE) $(1)-targets
	$(if $(2),@$$(MAKE) $(2))
	cat $($(1)-confs:%=output-%/summary) > summary && cat summary
endef

$(eval $(call parallel-target-template,partialx))
$(eval $(call parallel-target-template,allx,doallcoverage))
$(eval $(call parallel-target-template,bullyx,doallcoverage))


just-reports:
	for EVAL in compile interpret ; do\
          for O in 0 2 3 ; do\
            for SPI in f t ; do\
              for CP0 in f t ; do\
                for CIS in f t ; do\
                  $(MAKE) maybe-doreport eval=$$EVAL o=$$O spi=$$SPI cp0=$$CP0 cis=$$CIS ;\
                done\
              done\
            done\
          done\
        done


allxhelp:
	$(MAKE) doheader
	-$(MAKE) all
	$(MAKE) dosummary

config-vars = spi hci ecpf cp0 cis p eval ctb cgr cmg eoc cl rmg
full-config-str = $(strip o=$(o) $(foreach var, $(config-vars),$(if $(filter-out $($(var:%=default%)),$($(var))),$(var)=$($(var)))) $(hdrmsg))

allxphelp-target = allxhelp
allxphelp: $(outdir)
	@echo "matting configuration ($(full-config-str)) with output to $(outdir)/Make.out"
	@$(MAKE) $(allxphelp-target) > "$(outdir)/Make.out" 2>&1
	@echo "finished matting configuration $(full-config-str)"

summary-file=$(outdir)/summary

$(outdir):
	@mkdir -p "$(outdir)"

doheader: $(outdir)
	printf "%s" "-------- o=$o" >> $(summary-file)
	if [ "$(spi)" != "$(defaultspi)" ] ; then printf " spi=$(spi)" >> $(summary-file) ; fi
	if [ "$(hci)" != "$(defaulthci)" ] ; then printf " hci=$(hci)" >> $(summary-file) ; fi
	if [ "$(ecpf)" != "$(defaultecpf)" ] ; then printf " ecpf(ecpf)" >> $(summary-file) ; fi
	if [ "$(cp0)" != "$(defaultcp0)" ] ; then printf " cp0=$(cp0)" >> $(summary-file) ; fi
	if [ "$(cis)" != "$(defaultcis)" ] ; then printf " cis=$(cis)" >> $(summary-file) ; fi
	if [ "$p" != "$(defaultp)" ] ; then printf " p=$p" >> $(summary-file) ; fi
	if [ "$(eval)" != "$(defaulteval)" ] ; then printf " eval=$(eval)" >> $(summary-file) ; fi
	if [ "$(ctb)" != "$(defaultctb)" ] ; then printf " ctb=$(ctb)" >> $(summary-file) ; fi
	if [ "$(cgr)" != "$(defaultcgr)" ] ; then printf " cgr=$(cgr)" >> $(summary-file) ; fi
	if [ "$(cmg)" != "$(defaultcmg)" ] ; then printf " cmg=$(cmg)" >> $(summary-file) ; fi
	if [ "$(eoc)" != "$(defaulteoc)" ] ; then printf " eoc=$(eoc)" >> $(summary-file) ; fi
	if [ "$(cl)" != "$(defaultcl)" ] ; then printf " cl=$(cl)" >> $(summary-file) ; fi
	if [ "$(rmg)" != "$(defaultrmg)" ] ; then printf " rmg=$(rmg)" >> $(summary-file) ; fi
	if [ "$(hdrmsg)" != "" ] ; then printf " $(hdrmsg)" >> $(summary-file) ; fi

dosummary:
	printf " --------\n" >> $(summary-file)
	if [ -f $(outdir)/report-$(conf) ] ; then\
          cat $(outdir)/report-$(conf) >> $(summary-file) ;\
        else \
          printf 'NO REPORT\n' >> $(summary-file) ;\
        fi

allxhelpnotall:
	rm -f mat.so
	$(MAKE) doheader hdrmsg="not all"
	-$(MAKE)
	$(MAKE) dosummary
	$(MAKE) docoverage

all0: ; $(MAKE) all o=0
all1: ; $(MAKE) all o=1
all2: ; $(MAKE) all o=2
all3: ; $(MAKE) all o=3

parallel-prereqs: $(src) oop.ss ht.ss mat.so cat_flush${ExeSuffix} ${fobj} m4test.in m4test.out prettytest.ss ftype.h freq.in freq.out ${patchfile} build-examples

all: $(outdir) $(outdir)/script.all $(src) oop.ss ht.ss mat.so cat_flush${ExeSuffix} ${fobj} m4test.in m4test.out prettytest.ss ftype.h freq.in freq.out ${patchfile} build-examples
	${Scheme} --verbose -q mat.so ${patchfile} < $(outdir)/script.all
	$(MAKE) doerrors
	$(MAKE) doreport
	$(MAKE) docoverage

$(outdir)/script.all: Mf-base $(outdir)

$(outdir)/script.all makescript$o:
	echo $(conf-scheme-code)\
             '(record-run-coverage "$(objdir)/run.covout"'\
             '  (lambda ()'\
             '    (time (for-each (lambda (x) (time ((mat-file "$(objdir)") x)))'\
             '            (quote ($(mats:%="%")))))'\
             '    (parameterize ([source-directories (quote ("." "../s"))]) (when #${pdhtml} (profile-dump-html)))'\
             '    (unless (= (#%$$check-heap-errors) 0)'\
             '      (fprintf (console-error-port) "check heap detected errors---grep standard output for !!!\n")'\
             '      (abort))))'\
          > $(outdir)/script.all

source:
	$(MAKE) source0 o=0
	$(MAKE) source2 o=2
	$(MAKE) source3 o=3

source$o: ${src} mat.ss oop.ss ht.ss cat_flush.c ${fsrc} freq.in freq.out m4test.in m4test.out $(outdir)/script.all prettytest.ss ftype.h

rootsrc = $(shell cd ../../mats; echo *)
${rootsrc}:
ifeq ($(OS),Windows_NT)
	cp -p ../../mats/$@ $@
else
	ln -s ../../mats/$@ $@
endif

prettytest.ss:
	rm -f prettytest.ss
	$(MAKE) ${prettysrc}
	cat ${prettysrc} > prettytest.ss

bullyprettytest.ss: ${src}
	(cd ../s; make source)
	cat ${src} ../s/*.ss > prettytest.ss

mat.so: ${patchfile}
foreign.mo ${objdir}/foreign.mo: ${fobj}
thread.mo ${objdir}/thread.mo: ${fobj}
examples.mo ${objdir}/examples.mo: m4test.in m4test.out freq.in freq.out build-examples
6.mo ${objdir}/6.mo: prettytest.ss
bytevector.mo ${objdir}/bytevector.mo: prettytest.ss
io.mo ${objdir}/io.mo: prettytest.ss
unix.mo ${objdir}/unix.mo io.mo ${objdir}/io.mo 6.mo ${objdir}/6.mo: cat_flush${ExeSuffix}
oop.mo ${objdir}/oop.mo: oop.ss
ftype.mo ${objdir}/ftype.mo: ftype.h
hash.mo ${objdir}/hash.mo: ht.ss

build-examples:
	( cd ../examples && ${MAKE} Scheme=${Scheme} )
	touch build-examples

prettyclean:
	rm -f *.o ${mdclean} *.so *.mo *.covout experr* errors* report* summary testfile* testscript\
 ${fobj} prettytest.ss cat_flush${ExeSuffix} so_locations\
 build-examples script.all? *.html experr*.rej experr*.orig
	rm -rf testdir*
	rm -rf output output-* patches-work-dir
	( cd ../examples && ${MAKE} Scheme=${Scheme} clean )

clean: prettyclean
	rm -f Make.out


### rules for generating various experr files

# everything starts with the root experr files with default
# settings for the various parameters
experr-compile-$o-f-f-f: root-experr-compile-$o-f-f-f
	cp root-experr-compile-$o-f-f-f experr-compile-$o-f-f-f

root-experr: # don't list dependencies!
	rm -f root-experr-compile-$o-f-f-f
	# use the shell glob mechanism to find the file in any output* dir
	err_file=(output*/errors-compile-$o-f-f-f); cp $${err_file[0]} root-experr-compile-$o-f-f-f

root-experrs: # don't list dependencies!
	$(MAKE) root-experr o=0
	$(MAKE) root-experr o=3

# derive spi=t experr files by patching spi=f experr files
# cp first in case patch is empty, since patch produces an empty output
# file rather than a copy of the input file if the patch file is empty
experr-compile-$o-t-f-f: experr-compile-$o-f-f-f patch-compile-$o-t-f-f
	cp experr-compile-$o-f-f-f experr-compile-$o-t-f-f
	-patch experr-compile-$o-t-f-f patch-compile-$o-t-f-f

# derive cp0=t experr files by patching cp0=f experr files
experr-compile-$o-$(spi)-t-f: experr-compile-$o-$(spi)-f-f patch-compile-$o-$(spi)-t-f
	cp experr-compile-$o-$(spi)-f-f experr-compile-$o-$(spi)-t-f
	-patch experr-compile-$o-$(spi)-t-f patch-compile-$o-$(spi)-t-f

# derive cis=t experr files by patching cis=f experr files
experr-compile-$o-$(spi)-$(cp0)-t: experr-compile-$o-$(spi)-$(cp0)-f patch-compile-$o-$(spi)-$(cp0)-t
	cp experr-compile-$o-$(spi)-$(cp0)-f experr-compile-$o-$(spi)-$(cp0)-t
	-patch experr-compile-$o-$(spi)-$(cp0)-t patch-compile-$o-$(spi)-$(cp0)-t

# derive eval=interpret experr files by patching eval=compile experr files
# (with cis=f, since compile-interpret-simple does not affect interpret)
experr-interpret-$o-$(spi)-$(cp0)-$(cis): experr-compile-$o-$(spi)-$(cp0)-f patch-interpret-$o-$(spi)-$(cp0)-f
	cp experr-compile-$o-$(spi)-$(cp0)-f experr-interpret-$o-$(spi)-$(cp0)-$(cis)
	-patch experr-interpret-$o-$(spi)-$(cp0)-$(cis) patch-interpret-$o-$(spi)-$(cp0)-f


### rebuilding patch files

patches:
	rm -rf patches-work-dir
	mkdir patches-work-dir
	shopt -s nullglob; cp output*/errors-compile* output*/errors-interpret* patches-work-dir
	for O in 0 2 3 ; do\
	  if [ -f patches-work-dir/errors-compile-$$O-f-f-f -a -e patches-work-dir/errors-compile-$$O-t-f-f ] ; then \
            $(MAKE) xpatch-compile-$$O-t-f-f o=$$O spi=t ; \
          fi ;\
          for SPI in f t ; do\
	    if [ -f patches-work-dir/errors-compile-$$O-$$SPI-f-f -a -e patches-work-dir/errors-compile-$$O-$$SPI-t-f ] ; then \
              $(MAKE) xpatch-compile-$$O-$$SPI-t-f o=$$O spi=$$SPI cp0=t ;\
            fi ;\
            for CP0 in f t ; do\
	      if [ -f patches-work-dir/errors-compile-$$O-$$SPI-$$CP0-f -a -e patches-work-dir/errors-compile-$$O-$$SPI-$$CP0-t ] ; then \
                $(MAKE) xpatch-compile-$$O-$$SPI-$$CP0-t o=$$O spi=$$SPI cp0=$$CP0 cis=t ;\
              fi ;\
	      if [ -f patches-work-dir/errors-compile-$$O-$$SPI-$$CP0-f -a -e patches-work-dir/errors-interpret-$$O-$$SPI-$$CP0-f ] ; then \
                $(MAKE) xpatch-interpret-$$O-$$SPI-$$CP0-f o=$$O spi=$$SPI cp0=$$CP0 ;\
              fi\
            done\
          done\
        done

xpatch-compile-$o-t-f-f: # don't list dependencies!
	rm -f patch-compile-$o-t-f-f
	-diff --context patches-work-dir/errors-compile-$o-f-f-f\
                        patches-work-dir/errors-compile-$o-t-f-f\
                        > patch-compile-$o-t-f-f

xpatch-compile-$o-$(spi)-t-f: # don't list dependencies!
	rm -f patch-compile-$o-$(spi)-t-f
	-diff --context patches-work-dir/errors-compile-$o-$(spi)-f-f\
                        patches-work-dir/errors-compile-$o-$(spi)-t-f\
                        > patch-compile-$o-$(spi)-t-f

xpatch-compile-$o-$(spi)-$(cp0)-t: # don't list dependencies!
	rm -f patch-compile-$o-$(spi)-$(cp0)-t
	-diff --context patches-work-dir/errors-compile-$o-$(spi)-$(cp0)-f\
                        patches-work-dir/errors-compile-$o-$(spi)-$(cp0)-t\
                        > patch-compile-$o-$(spi)-$(cp0)-t

xpatch-interpret-$o-$(spi)-$(cp0)-f: # don't list dependencies!
	rm -f patch-interpret-$o-$(spi)-$(cp0)-f
	-diff --context patches-work-dir/errors-compile-$o-$(spi)-$(cp0)-f\
                        patches-work-dir/errors-interpret-$o-$(spi)-$(cp0)-f\
                        > patch-interpret-$o-$(spi)-$(cp0)-f
