# Mf-base
# Copyright 1984-2017 Cisco Systems, Inc.
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
# http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Assumes recursive makes inherit command-line settings as in GNU make

# Running "make" or "make all" in this directory runs the mats (test
# programs) and produces a report of bugs and errors.  Unless you make
# changes to the mats or to the system, the report file report-$(conf)
# (where $(conf) is set below)

# If an error or bug report occurs, refer to the offending ".mo" file
# produced by the mats and mentioned in the bug or error report to
# determine what failed.

# Running "make allx" runs a set of mats with various settings.
# "make bullyx" runs a different, more stressful set.

# Running make with the argument "clean" removes the .so files, .mo
# files, report files, and temporary files generated by the mats.

# The variables below may be changed to affect how the mats are run.
# For example, "make o=2 cp0=t ctb=8192" causes the mats to be run at
# optimize level 2 with cp0 enabled and collect-trip-bytes set to 8192.

ifeq (${OS},Windows_NT)
  dirsep = ;
else
  dirsep = :
endif

# Explicit ".exe" needed for WSL
ifeq ($(OS),Windows_NT)
  ExeSuffix = .exe
else
  ExeSuffix =
endif

# Scheme is the scheme executable to test, SCHEMEHEAPDIRS tells
# it where to find its boot files, and CHEZSCHEMELIBDIRS tells
# it where to find libraries.
Scheme = ../bin/$m/scheme${ExeSuffix}
export SCHEMEHEAPDIRS=.${dirsep}../boot/%m
export CHEZSCHEMELIBDIRS=.

# Include is the directory holding scheme.h.
Include = ../boot/$m

# patchfile is the name of a patch to be loaded while running the mats.
patchfile =

# o is the optimize level at which the mats should be run.
o = 0

# p determines whether profiling is enabled: f for false, t for true.
defaultp = f
p = $(defaultp)

# pdhtml determines whether profile-dump-html is called at end of a run: f for false, t for true.
# NB: beware of lost profile information due to mats that call profile-clear
defaultpdhtml = f
pdhtml = $(defaultpdhtml)

# cp0 determines whether cp0 is run: f for no, t for yes
defaultcp0 = f
cp0 = $(defaultcp0)

# eval is the evaluator to use.
defaulteval = compile
eval = $(defaulteval)

# ctb is the value to which collect-trip-bytes is set.
defaultctb = (collect-trip-bytes)
ctb = $(defaultctb)

# cgr is the value to which collect-generation-radix is set.
defaultcgr = (collect-generation-radix)
cgr = $(defaultcgr)

# cmg is the value to which collect-maximum-generation is set.
defaultcmg = (collect-maximum-generation)
cmg = $(defaultcmg)

# rmg is the value to which release-minimum-generation is set.
defaultrmg = (release-minimum-generation)
rmg = $(defaultrmg)

# cis defines the value to which compile-interpret-simple is set: f for
# #f, t for #t
defaultcis = f
cis = $(defaultcis)

# spi defines the value to which suppress-primitive-inlining is set:
# f for #f, t for #t
defaultspi = f
spi = $(defaultspi)

# ehc defines the value to which $enable-check-heap is set:
# f for #f, t for #t
defaultehc = f
ehc = $(defaultehc)

# eoc determines whether object counts are enabled
defaulteoc = t
eoc = $(defaulteoc)

# cl determines the commonization level
defaultcl = (commonization-level)
cl = $(defaultcl)

# ecpf determines whether the compiler checks prelex flags
defaultecpf = t
ecpf = $(defaultecpf)

# set of mats to run
mats = primvars 3 4 5_1 5_2 5_3 5_4 5_5 bytevector thread\
 misc cp0 cptypes 5_6 5_7 5_8 6 io format 7 record hash enum 8 fx fl cfl foreign\
 ftype unix windows examples ieee date exceptions oop

Examples = ../examples

MAKEFLAGS += --no-print-directory

conf = $(eval)-$o-$(spi)-$(cp0)-$(cis)
objdir=output-$(conf)
objname = $(mats:%=%.mo)
obj = $(objname:%=$(objdir)/%)
src = $(mats:%=%.ms)

# prettysrc is src to use for pretty-print test; we leave out mat files
# with cycles, e.g., primvars.ms, misc.ms, 4.ms, 5_1.ms, hash.ms
prettysrc = 3.ms 5_3.ms 5_4.ms 5_5.ms bytevector.ms\
 thread.ms 5_6.ms 5_7.ms 5_8.ms 6.ms io.ms format.ms 7.ms record.ms enum.ms 8.ms\
 fx.ms fl.ms cfl.ms foreign.ms unix.ms windows.ms examples.ms ieee.ms date.ms\
 exceptions.ms

$(objdir)/%.mo : %.ms mat.so
	echo '(optimize-level $o)'\
             '(#%$$suppress-primitive-inlining #${spi})'\
             '(#%$$enable-check-heap #${ehc})'\
             '(#%$$enable-check-prelex-flags #${ecpf})'\
             '(compile-profile #$p)'\
             '(collect-trip-bytes ${ctb})'\
             '(collect-generation-radix ${cgr})'\
             '(collect-maximum-generation ${cmg})'\
             '(enable-object-counts #${eoc})'\
             '(commonization-level ${cl})'\
             '(compile-interpret-simple #${cis})'\
             '(set! *examples-directory* "${Examples}")'\
             '(enable-cp0 #${cp0})'\
             '(set! *scheme* "${Scheme}")'\
             '(current-eval ${eval})'\
             '(time ((mat-file "$(objdir)") "$*"))'\
             '(unless (= (#%$$check-heap-errors) 0)'\
             '  (fprintf (console-error-port) "check heap detected errors---grep standard output for !!!\n")'\
             '  (abort))'\
           | ${Scheme} -q mat.so ${patchfile}

# same as above except puts the .mo file in .
%.mo : %.ms mat.so
	echo '(optimize-level $o)'\
             '(#%$$suppress-primitive-inlining #${spi})'\
             '(#%$$enable-check-heap #${ehc})'\
             '(#%$$enable-check-prelex-flags #${ecpf})'\
             '(compile-profile #$p)'\
             '(collect-trip-bytes ${ctb})'\
             '(collect-generation-radix ${cgr})'\
             '(collect-maximum-generation ${cmg})'\
             '(enable-object-counts #${eoc})'\
             '(commonization-level ${cl})'\
             '(compile-interpret-simple #${cis})'\
             '(set! *examples-directory* "${Examples}")'\
             '(enable-cp0 #${cp0})'\
             '(set! *scheme* "${Scheme}")'\
             '(current-eval ${eval})'\
             '(time ((mat-file ".") "$*"))'\
             '(parameterize ([source-directories (quote ("." "../s"))]) (when #${pdhtml} (profile-dump-html)))'\
             '(unless (= (#%$$check-heap-errors) 0)'\
             '  (fprintf (console-error-port) "check heap detected errors---grep standard output for !!!\n")'\
             '  (abort))'\
           | ${Scheme} -q mat.so ${patchfile}

%.so : %.ss
	echo '(reset-handler abort) (time (compile-file "$*"))' | ${Scheme} -q ${patchfile}

report: report-$(conf)

experr: experr-$(conf)

report-$(conf): errors-$(conf)
	$(MAKE) doreport

doreport: experr-$(conf)
	rm -f report-$(conf)
	-diff experr-$(conf) errors-$(conf) > report-$(conf) 2>&1

maybe-doreport:
	-if [ -f errors-$(conf) ] ; then\
          $(MAKE) doreport ;\
         fi

errors-$(conf): ${obj}
	$(MAKE) doerrors

doerrors:
	rm -f errors-$(conf)
	-(cd $(objdir); grep '^Error' $(objname)) > errors-$(conf)
	-(cd $(objdir); grep '^Bug' $(objname)) >> errors-$(conf)
	-(cd $(objdir); grep '^Warning' $(objname)) >> errors-$(conf)
	-(cd $(objdir); grep '^Expected' $(objname))\
         >> errors-$(conf)

fastreport:
	$(MAKE) doerrors
	$(MAKE) doreport

partialx:
	$(MAKE) allxhelp o=0
	$(MAKE) allxhelp o=3
	$(MAKE) allxhelp o=3 cp0=t
	$(MAKE) allxhelp o=3 eval=interpret cp0=t rmg=2

allx: prettyclean
	$(MAKE) allxhelp o=0
	$(MAKE) allxhelp o=3
	$(MAKE) allxhelp o=0 cp0=t cl=3
	$(MAKE) allxhelp o=3 cp0=t cl=3
	$(MAKE) allxhelp o=0 spi=t rmg=2 p=t
	$(MAKE) allxhelp o=3 spi=t rmg=2 p=t
	$(MAKE) allxhelp o=0 eval=interpret cl=6
	$(MAKE) allxhelp o=3 eval=interpret cl=6
	$(MAKE) allxhelp o=0 eval=interpret cp0=t rmg=2
	$(MAKE) allxhelp o=3 eval=interpret cp0=t rmg=2
	$(MAKE) allxhelp o=0 eoc=f ehc=t cl=9
	$(MAKE) allxhelp o=3 eval=interpret ehc=t rmg=2

just-reports:
	for EVAL in compile interpret ; do\
          for O in 0 2 3 ; do\
            for SPI in f t ; do\
              for CP0 in f t ; do\
                for CIS in f t ; do\
                  $(MAKE) maybe-doreport eval=$$EVAL o=$$O spi=$$SPI cp0=$$CP0 cis=$$CIS ;\
                done\
              done\
            done\
          done\
        done

bullyx:
	-$(MAKE) bully o=0
	-$(MAKE) bully o=3

bully:
	-$(MAKE) allxhelpnotall spi=t cp0=f
	-$(MAKE) allxhelp spi=f cp0=f cl=9 ctb='(/ (collect-trip-bytes) 64)' ehc=t
	-$(MAKE) allxhelp spi=t cp0=f cis=t cmg=1
	-$(MAKE) allxhelp spi=f cp0=f cis=t cmg=6 ehc=t
	-$(MAKE) allxhelp spi=t cp0=t ctb='(/ (collect-trip-bytes) 64)' cgr=6
	-$(MAKE) allxhelp spi=t cp0=f p=t eoc=f ehc=t
	-$(MAKE) allxhelp spi=f cp0=t cl=9 p=t ehc=t
	-$(MAKE) allxhelp eval=interpret spi=f cp0=f
	-$(MAKE) allxhelp eval=interpret spi=f cp0=t
	-$(MAKE) allxhelp eval=interpret spi=t cp0=f ctb='(/ (collect-trip-bytes) 64)' ehc=t
	-$(MAKE) allxhelp eval=interpret spi=t cp0=t cgr=2 ehc=t p=t

allxhelp:
	$(MAKE) doheader
	-$(MAKE) all
	$(MAKE) dosummary

doheader:
	printf "%s" "-------- o=$o" >> summary
	if [ "$(spi)" != "$(defaultspi)" ] ; then printf " spi=$(spi)" >> summary ; fi
	if [ "$(ehc)" != "$(defaultehc)" ] ; then printf " ehc=$(ehc)" >> summary ; fi
	if [ "$(ecpf)" != "$(defaultecpf)" ] ; then printf " ecpf(ecpf)" >> summary ; fi
	if [ "$(cp0)" != "$(defaultcp0)" ] ; then printf " cp0=$(cp0)" >> summary ; fi
	if [ "$(cis)" != "$(defaultcis)" ] ; then printf " cis=$(cis)" >> summary ; fi
	if [ "$p" != "$(defaultp)" ] ; then printf " p=$p" >> summary ; fi
	if [ "$(eval)" != "$(defaulteval)" ] ; then printf " eval=$(eval)" >> summary ; fi
	if [ "$(ctb)" != "$(defaultctb)" ] ; then printf " ctb=$(ctb)" >> summary ; fi
	if [ "$(cgr)" != "$(defaultcgr)" ] ; then printf " cgr=$(cgr)" >> summary ; fi
	if [ "$(cmg)" != "$(defaultcmg)" ] ; then printf " cmg=$(cmg)" >> summary ; fi
	if [ "$(eoc)" != "$(defaulteoc)" ] ; then printf " eoc=$(eoc)" >> summary ; fi
	if [ "$(cl)" != "$(defaultcl)" ] ; then printf " cl=$(cl)" >> summary ; fi
	if [ "$(hdrmsg)" != "" ] ; then printf " $(hdrmsg)" >> summary ; fi

dosummary:
	printf " --------\n" >> summary
	if [ -f report-$(conf) ] ; then\
          cat report-$(conf) >> summary ;\
        else \
          printf 'NO REPORT\n' >> summary ;\
        fi

allxhelpnotall:
	rm -f mat.so
	$(MAKE) doheader hdrmsg="not all"
	-$(MAKE)
	$(MAKE) dosummary

all0: ; $(MAKE) all o=0
all1: ; $(MAKE) all o=1
all2: ; $(MAKE) all o=2
all3: ; $(MAKE) all o=3

all: makescript$o $(src) oop.ss ht.ss mat.so cat_flush ${fobj} m4test.in m4test.out prettytest.ss ftype.h freq.in freq.out ${patchfile} examples
	${Scheme} --verbose -q mat.so ${patchfile} < script.all$o
	$(MAKE) doerrors
	$(MAKE) doreport

script.all$o: Mf-base

script.all$o makescript$o:
	echo '(optimize-level $o)'\
             '(#%$$suppress-primitive-inlining #${spi})'\
             '(#%$$enable-check-heap #${ehc})'\
             '(#%$$enable-check-prelex-flags #${ecpf})'\
             '(compile-profile #$p)'\
             '(collect-trip-bytes ${ctb})'\
             '(collect-generation-radix ${cgr})'\
             '(collect-maximum-generation ${cmg})'\
             '(enable-object-counts #${eoc})'\
             '(commonization-level ${cl})'\
             '(compile-interpret-simple #${cis})'\
             '(set! *examples-directory* "${Examples}")'\
             '(enable-cp0 #${cp0})'\
             '(set! *scheme* "${Scheme}")'\
             '(current-eval ${eval})'\
             '(time (for-each (mat-file "$(objdir)")'\
             '        (quote ($(mats:%="%")))))'\
             '(parameterize ([source-directories (quote ("." "../s"))]) (when #${pdhtml} (profile-dump-html)))'\
             '(unless (= (#%$$check-heap-errors) 0)'\
             '  (fprintf (console-error-port) "check heap detected errors---grep standard output for !!!\n")'\
             '  (abort))'\
          > script.all$o

source:
	$(MAKE) source0 o=0
	$(MAKE) source2 o=2
	$(MAKE) source3 o=3

source$o: ${src} mat.ss oop.ss ht.ss cat_flush.c ${fsrc} freq.in freq.out m4test.in m4test.out script.all$o prettytest.ss ftype.h

rootsrc = $(shell cd ../../mats; echo *)
${rootsrc}:
ifeq ($(OS),Windows_NT)
	cp -p ../../mats/$@ $@
else
	ln -s ../../mats/$@ $@
endif

prettytest.ss:
	rm -f prettytest.ss
	$(MAKE) ${prettysrc}
	cat ${prettysrc} > prettytest.ss

bullyprettytest.ss: ${src}
	(cd ../s; make source)
	cat ${src} ../s/*.ss > prettytest.ss

mat.so: ${patchfile}
foreign.mo ${objdir}/foreign.mo: ${fobj}
thread.mo ${objdir}/thread.mo: ${fobj}
examples.mo ${objdir}/examples.mo: m4test.in m4test.out freq.in freq.out examples
6.mo ${objdir}/6.mo: prettytest.ss
io.mo ${objdir}/io.mo: prettytest.ss
unix.mo ${objdir}/unix.mo io.mo ${objdir}/io.mo 6.mo ${objdir}/6.mo: cat_flush
oop.mo ${objdir}/oop.mo: oop.ss
ftype.mo ${objdir}/ftype.mo: ftype.h
hash.mo ${objdir}/hash.mo: ht.ss

examples:
	( cd ../examples && ${MAKE} Scheme=${Scheme} )

prettyclean:
	rm -f *.o ${mdclean} *.so *.mo experr* errors* report* summary testfile* testscript\
 ${fobj} prettytest.ss cat_flush so_locations\
 script.all? *.html experr*.rej experr*.orig
	rm -rf testdir*
	rm -rf output-*

clean: prettyclean
	rm -f Make.out


### rules for generating various experr files

# everything starts with the root experr files with default
# settings for the various parameters
experr-compile-$o-f-f-f: root-experr-compile-$o-f-f-f
	cp root-experr-compile-$o-f-f-f experr-compile-$o-f-f-f

root-experr: # don't list dependencies!
	rm -f root-experr-compile-$o-f-f-f
	cp errors-compile-$o-f-f-f root-experr-compile-$o-f-f-f

# derive spi=t experr files by patching spi=f experr files
# cp first in case patch is empty, since patch produces an empty output
# file rather than a copy of the input file if the patch file is empty
experr-compile-$o-t-f-f: experr-compile-$o-f-f-f patch-compile-$o-t-f-f
	cp experr-compile-$o-f-f-f experr-compile-$o-t-f-f
	-patch experr-compile-$o-t-f-f patch-compile-$o-t-f-f

# derive cp0=t experr files by patching cp0=f experr files
experr-compile-$o-$(spi)-t-f: experr-compile-$o-$(spi)-f-f patch-compile-$o-$(spi)-t-f
	cp experr-compile-$o-$(spi)-f-f experr-compile-$o-$(spi)-t-f
	-patch experr-compile-$o-$(spi)-t-f patch-compile-$o-$(spi)-t-f

# derive cis=t experr files by patching cis=f experr files
experr-compile-$o-$(spi)-$(cp0)-t: experr-compile-$o-$(spi)-$(cp0)-f patch-compile-$o-$(spi)-$(cp0)-t
	cp experr-compile-$o-$(spi)-$(cp0)-f experr-compile-$o-$(spi)-$(cp0)-t
	-patch experr-compile-$o-$(spi)-$(cp0)-t patch-compile-$o-$(spi)-$(cp0)-t

# derive eval=interpret experr files by patching eval=compile experr files
# (with cis=f, since compile-interpret-simple does not affect interpret)
experr-interpret-$o-$(spi)-$(cp0)-$(cis): experr-compile-$o-$(spi)-$(cp0)-f patch-interpret-$o-$(spi)-$(cp0)-f
	cp experr-compile-$o-$(spi)-$(cp0)-f experr-interpret-$o-$(spi)-$(cp0)-$(cis)
	-patch experr-interpret-$o-$(spi)-$(cp0)-$(cis) patch-interpret-$o-$(spi)-$(cp0)-f


### rebuilding patch files

patches:
	for O in 0 2 3 ; do\
	  if [ -f errors-compile-$$O-f-f-f -a -e errors-compile-$$O-t-f-f ] ; then \
            $(MAKE) xpatch-compile-$$O-t-f-f o=$$O spi=t ; \
          fi ;\
          for SPI in f t ; do\
	    if [ -f errors-compile-$$O-$$SPI-f-f -a -e errors-compile-$$O-$$SPI-t-f ] ; then \
              $(MAKE) xpatch-compile-$$O-$$SPI-t-f o=$$O spi=$$SPI cp0=t ;\
            fi ;\
            for CP0 in f t ; do\
	      if [ -f errors-compile-$$O-$$SPI-$$CP0-f -a -e errors-compile-$$O-$$SPI-$$CP0-t ] ; then \
                $(MAKE) xpatch-compile-$$O-$$SPI-$$CP0-t o=$$O spi=$$SPI cp0=$$CP0 cis=t ;\
              fi ;\
	      if [ -f errors-compile-$$O-$$SPI-$$CP0-f -a -e errors-interpret-$$O-$$SPI-$$CP0-f ] ; then \
                $(MAKE) xpatch-interpret-$$O-$$SPI-$$CP0-f o=$$O spi=$$SPI cp0=$$CP0 ;\
              fi\
            done\
          done\
        done

xpatch-compile-$o-t-f-f: # don't list dependencies!
	rm -f patch-compile-$o-t-f-f
	-diff --context errors-compile-$o-f-f-f\
                        errors-compile-$o-t-f-f\
                        > patch-compile-$o-t-f-f

xpatch-compile-$o-$(spi)-t-f: # don't list dependencies!
	rm -f patch-compile-$o-$(spi)-t-f
	-diff --context errors-compile-$o-$(spi)-f-f\
                        errors-compile-$o-$(spi)-t-f\
                        > patch-compile-$o-$(spi)-t-f

xpatch-compile-$o-$(spi)-$(cp0)-t: # don't list dependencies!
	rm -f patch-compile-$o-$(spi)-$(cp0)-t
	-diff --context errors-compile-$o-$(spi)-$(cp0)-f\
                        errors-compile-$o-$(spi)-$(cp0)-t\
                        > patch-compile-$o-$(spi)-$(cp0)-t

xpatch-interpret-$o-$(spi)-$(cp0)-f: # don't list dependencies!
	rm -f patch-interpret-$o-$(spi)-$(cp0)-f
	-diff --context errors-compile-$o-$(spi)-$(cp0)-f\
                        errors-interpret-$o-$(spi)-$(cp0)-f\
                        > patch-interpret-$o-$(spi)-$(cp0)-f
