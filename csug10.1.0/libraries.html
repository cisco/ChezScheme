<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Libraries and Top-level Programs</title>
<link href="csug.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g93"></a>
<a name="./libraries:h0"></a>

<h1>Chapter 10. Libraries and Top-level Programs<a name="CHPTLIBRARIES"></a></h1>





<p>
<a name="./libraries:s0"></a><a name="./libraries:s1"></a>The Revised<sup>6</sup> Report describes two units of portable code:
libraries and top-level programs.
A library is a named collection of bindings with a declared set of
explicitly exported bindings, a declared set of imported libraries, and a
body that initializes its bindings.
A top-level program is a stand-alone program with a declared set of
imported libraries and a body that is run when the top-level program is
run.
The bindings in a library are created and its initialization code run only
if the library is used, directly or indirectly, by a top-level program.

<p>
<a name="./libraries:s2"></a>The <tt>import</tt> declarations appearing within libraries and top-level
programs serve two purposes:  first, they cause the imported libraries to
be loaded, and second, they cause the bindings of the imported libraries
to become visible in the importing library or top-level program.
Libraries are typically stored in the file system, with one library per
file, and the library name typically identifies the file-system path to
the library, possibly relative to a default or programmer-specified set of
library locations.
The exact mechanism by which top-level programs are run and libraries are
loaded is implementation-dependent.

<p>
This chapter describes the mechanisms by which libraries and programs are
loaded in <i>Chez&nbsp;Scheme</i> along with various features for controlling and
tracking this process.
It also describes the set of built-in libraries and syntactic forms for
defining new libraries and top-level programs outside of a library or
top-level program file.



<p>

<h3><a name="g94"></a><a name="./libraries:h1"></a>Section 10.1. Built-in Libraries<a name="SECTBUILTINLIBRARIES"></a></h3>



<p>
In addition to the RNRS libraries mandated by the Revised<sup>6</sup> Report:

<p>

<p><tt>&nbsp;&nbsp;(rnrs&nbsp;base&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;arithmetic&nbsp;bitwise&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;arithmetic&nbsp;fixnums&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;arithmetic&nbsp;flonums&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;bytevectors&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;conditions&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;control&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;enums&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;eval&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;exceptions&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;files&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;hashtables&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;io&nbsp;ports&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;io&nbsp;simple&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;lists&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;mutable-pairs&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;mutable-strings&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;programs&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;r5rs&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;records&nbsp;procedural&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;records&nbsp;syntactic&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;records&nbsp;inspection&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;sorting&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;syntax-case&nbsp;(6))<br>

&nbsp;&nbsp;(rnrs&nbsp;unicode&nbsp;(6))</tt>
<p><a name="./libraries:s3"></a><a name="./libraries:s4"></a><a name="./libraries:s5"></a><a name="./libraries:s6"></a><i>Chez&nbsp;Scheme</i> also provides two additional libraries: <tt>(chezscheme)</tt>
and <tt>(chezscheme&nbsp;csv7)</tt>.
The former can also be referenced as <tt>(scheme)</tt> and the latter can
also be referenced as <tt>(scheme&nbsp;csv7)</tt>.

<p>
The <tt>(chezscheme)</tt> library exports bindings for every identifier whose
binding is described in this document, including those for keywords like
<tt>lambda</tt>, auxiliary keywords like <tt>else</tt>, module names
like <tt>scheme</tt>, and procedure names like <tt>cons</tt>.
In most cases where an identifier exported from the
<tt>(chezscheme)</tt> library corresponds to an identifier exported from
one of the RNRS libraries, the bindings are identical.
In some cases, however, the <tt>(chezscheme)</tt> bindings extend the
<tt>rnrs</tt> bindings in some way.
For example, the <tt>(chezscheme)</tt> <tt>syntax-rules</tt> form allows
its clauses to have fenders (Section&nbsp;<a href="./syntax.html#g103">11.2</a>), while the
<tt>(rnrs)</tt> <tt>syntax-rules</tt> form does not.
Similarly, the <tt>(chezscheme)</tt> <tt>current-input-port</tt> procedure
accepts an optional <tt><i>port</i></tt> argument that, when specified, sets the
current input port to <tt><i>port</i></tt> (Section&nbsp;<a href="./io.html#g83">9.8</a>), while the
<tt>(rnrs)</tt> <tt>current-input-port</tt> procedure does not.
When the <tt>(chezscheme)</tt> library extends an RNRS binding in some
way, the <tt>(chezscheme)</tt> library also exports the RNRS version,
with the name prefixed by <tt>r6rs:</tt>, e.g., <tt>r6rs:syntax-rules</tt>
or <tt>r6rs:current-input-port</tt>.

<p>
The <tt>(chezscheme&nbsp;csv7)</tt> Version&nbsp;7 backward compatibility library
contains bindings for a set of syntactic forms and procedures whose syntax
or semantics directly conflicts with the RNRS bindings for the same
identifiers.
The following identifiers are exported from <tt>(chezscheme&nbsp;csv7)</tt>.

<p>

<p><tt>record-field-accessible?<br>

record-field-accessor<br>

record-field-mutable?<br>

record-field-mutator<br>

record-type-descriptor<br>

record-type-field-decls<br>

record-type-field-names<br>

record-type-name<br>

record-type-symbol</tt>
<p>The bindings of this library should be used only for old code; new
code should use the RNRS variants.
Each of these is also available in the <tt>(chezscheme)</tt> library with
the prefix <tt>csv7:</tt>, e.g., <tt>csv7:record-type-name</tt>.

<p>
The interaction environment in which code outside of a library or
RNRS top-level program is scoped contains all of the bindings of the
<tt>(chezscheme)</tt> library, as described in
Section&nbsp;<a href="./use.html#g8">2.3</a>.


<p>

<h3><a name="g95"></a><a name="./libraries:h2"></a>Section 10.2. Running Top-level Programs<a name="SECTRUNNINGTOPLEVELPROGRAMS"></a></h3>



<p>
<a name="./libraries:s7"></a><a name="./libraries:s8"></a><a name="./libraries:s9"></a>A top-level program must reside in its own file, which may have any
name and may reside anywhere in the file system.
A top-level program residing in a file is run by one of three mechanisms: 
the <tt>scheme-script</tt> command, the <tt>--program</tt> command-line
argument, or the <tt>load-program</tt> procedure.

<p>
The <tt>scheme-script</tt> command is used as follows:

<p>

<p><tt>scheme-script&nbsp;<i>program-filename</i>&nbsp;<i>arg</i>&nbsp;...</tt>
<p>It may also be run implicitly on Unix-based systems by placing the line

<p>

<p><tt>#!&nbsp;/usr/bin/env&nbsp;scheme-script</tt>
<p>at the front of the file containing the top-level program, making the
top-level program file executable, and executing the file.
This line may be replaced with

<p>

<p><tt>#!&nbsp;/usr/bin/scheme-script</tt>
<p>with <tt>/usr/bin</tt> replaced by the absolute path to the directory
containing <tt>scheme-script</tt> if it is not in <tt>/usr/bin</tt>.
The first form is recommended in the nonnormative appendices to the
Revised<sup>6</sup> Report&nbsp;[<a class=citation href="./bibliography.html#g186">29</a>], and works wherever
<tt>scheme-script</tt> appears in the path.

<p>
The <tt>--program</tt> command is used similarly with the <tt>scheme</tt>
or <tt>petite</tt> executables, either by running:

<p>

<p><tt>scheme&nbsp;--program&nbsp;<i>program-filename</i>&nbsp;<i>arg</i>&nbsp;...<br>

petite&nbsp;--program&nbsp;<i>program-filename</i>&nbsp;<i>arg</i>&nbsp;...</tt>
<p>or by including

<p>

<p><tt>#!&nbsp;/usr/bin/scheme&nbsp;--script</tt>
<p>or

<p>

<p><tt>#!&nbsp;/usr/bin/petite&nbsp;--script</tt>
<p>at the front of the top-level program file, making the file executable,
and executing the file.
Again, <tt>/usr/bin</tt> should be replaced with the absolute path to
the actual directory in which <tt>scheme</tt> and/or <tt>petite</tt>
resides, if not <tt>/usr/bin</tt>.

<p>
The <tt>load-program</tt> procedure, described in
Section&nbsp;<a href="./system.html#g118">12.4</a>, is used like <tt>load</tt>:

<p>

<p><tt>(load-program&nbsp;<i>string</i>)</tt>
<p>where <tt><i>string</i></tt> names the file in which the top-level program resides.

<p>
Regardless of the mechanism used, if the opening line is in one of the
forms described above, or more generally, consists of
<tt>#!</tt> followed by a space or a forward slash, the opening line
is not considered part of the program and is ignored once the Scheme
system starts up and begins to run the program.
Thus, the line may be present even in a file loaded by <tt>load-program</tt>.
In fact, <tt>load-program</tt> is ultimately used by the other two
mechanisms described above, via the value of the <tt>scheme-program</tt>
parameter described in Section&nbsp;<a href="./system.html#g122">12.8</a>, and it is
<tt>load-program</tt> that scans past the <tt>#!</tt> line, if present,
before evaluating the program.

<p>
A top-level program may be compiled with the
<a name="./libraries:s10"></a><tt>compile-program</tt>
procedure described in Section&nbsp;<a href="./system.html#g118">12.4</a>.
<tt>compile-program</tt> copies the <tt>#!</tt> line from the source
file to the object file, followed by a compiled version of the source
code.
Any libraries upon which the top-level program depends, other than
built-in libraries, must be compiled first via <tt>compile-file</tt>
or <tt>compile-library</tt>.
This can be done manually or by setting the parameter
<tt>compile-imported-libraries</tt> to <tt>#t</tt> before compiling
the program.
The program must be recompiled if any of the libraries upon which
it depends are recompiled.
A compiled top-level program can be run just like a source top-level
program via each of the mechanisms described above.

<p>
<a name="./libraries:s11"></a>In <i>Chez&nbsp;Scheme</i>, a library may also be defined in the REPL or placed in a
file to be loaded via <tt>load</tt> or <tt>load-library</tt>.
The syntax for a library is the same whether the library is placed in
its own file and implicitly loaded via <tt>import</tt>, entered into
the REPL, or placed in a file along with other top-level expressions to
be evaluated by <tt>load</tt>.
A top-level program may also be defined in the REPL or placed in a file
to be loaded via <tt>load</tt>, but in this case, the syntax is slightly
different.
In the language of the Revised<sup>6</sup> Report, a top-level program is merely
an unwrapped sequence of subforms consisting of an <tt>import</tt> form
and a body, delimited only by the boundaries of the file in which it
resides.
In order for a top-level program to be entered in the REPL or placed in
a file to be evaluated by <tt>load</tt>, <i>Chez&nbsp;Scheme</i> allows top-level
programs to be enclosed in a
<a name="./libraries:s12"></a><tt>top-level-program</tt> form.

<p>

<h3><a name="g96"></a><a name="./libraries:h3"></a>Section 10.3. Library and Top-level Program Forms<a name="SECTLIBRARYFORMS"></a></h3>



<p>
<a name="./libraries:s13"></a><span class=formdef><b>syntax</b>: <tt>(library&nbsp;<i>name</i>&nbsp;<i>exports</i>&nbsp;<i>imports</i>&nbsp;<i>library-body</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The <tt>library</tt> form defines a new library with the specified
name, exports, imports, and body.
Details on the syntax and semantics of the library form are given in
Section&nbsp;<a href="http://scheme.com/tspl4/./libraries.html#g145">10.3</a> of <i>The Scheme Programming Language, 4th Edition</i> and in the Revised<sup>6</sup>
Report.

<p>
Only one version of a library can be loaded at any given time, and an
exception is raised if a library is implicitly loaded via <tt>import</tt>
when another version of the library has already been loaded.
<i>Chez&nbsp;Scheme</i> permits a different version of the library, or a new
instance of the same version, to be entered explicitly into the REPL
or loaded explicitly from a file, to facilitate interactive testing
and debugging.
The programmer should take care to make sure that any code that uses
the library is also reentered or reloaded, to make sure that code
accesses the bindings of the new instance of the library.

<p>

<p><tt>(library&nbsp;(test&nbsp;(1))&nbsp;(export&nbsp;x)&nbsp;(import&nbsp;(rnrs))&nbsp;(define&nbsp;x&nbsp;3))<br>

(import&nbsp;(test))<br>

(define&nbsp;f&nbsp;(lambda&nbsp;()&nbsp;x))<br>

(f)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3
<br>
<br>
(library&nbsp;(test&nbsp;(1))&nbsp;(export&nbsp;x)&nbsp;(import&nbsp;(rnrs))&nbsp;(define&nbsp;x&nbsp;4))<br>

(import&nbsp;(test))<br>

(f)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;oops---forgot&nbsp;to&nbsp;redefine&nbsp;f<br>

(define&nbsp;f&nbsp;(lambda&nbsp;()&nbsp;x))<br>

(f)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4
<br>
<br>
(library&nbsp;(test&nbsp;(2))&nbsp;(export&nbsp;x)&nbsp;(import&nbsp;(rnrs))&nbsp;(define&nbsp;x&nbsp;5))<br>

(import&nbsp;(test))<br>

(define&nbsp;f&nbsp;(lambda&nbsp;()&nbsp;x))<br>

(f)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;5</tt>
<p>As with module imports (Section&nbsp;<a href="./syntax.html#g106">11.5</a>), a library
<tt>import</tt> may appear anywhere a definition may appear, including at
top level in the REPL, in a file to be loaded by <tt>load</tt>, or within
a <tt>lambda</tt>, <tt>let</tt>, <tt>letrec</tt>, <tt>letrec*</tt>,
etc., body.
The same <tt>import</tt> form may be used to import from both libraries
and modules.

<p>

<p><tt>(library&nbsp;(foo)&nbsp;(export&nbsp;a)&nbsp;(import&nbsp;(rnrs))&nbsp;(define&nbsp;a&nbsp;'a-from-foo))<br>

(module&nbsp;bar&nbsp;(b)&nbsp;(define&nbsp;b&nbsp;'b-from-bar))<br>

(let&nbsp;()&nbsp;(import&nbsp;(foo)&nbsp;bar)&nbsp;(list&nbsp;a&nbsp;b))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(a-from-foo&nbsp;b-from-bar)</tt>
<p>The <tt>import</tt> keyword is not visible within a library body
unless the library imports it from the <tt>(chezscheme)</tt> library.

<p>
<a name="./libraries:s14"></a><span class=formdef><b>syntax</b>: <tt>(top-level-program&nbsp;<i>imports</i>&nbsp;<i>body</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./libraries:s15"></a>A <tt>top-level-program</tt> form may be entered into the REPL or placed
in a file to be loaded via <tt>load</tt>, where it behaves as if its
subforms were placed in a file and loaded via <tt>load-program</tt>.
Details on the syntax and semantics of a top-level program are given in
Section&nbsp;<a href="http://scheme.com/tspl4/./libraries.html#g145">10.3</a> of <i>The Scheme Programming Language, 4th Edition</i> and in the Revised<sup>6</sup>
Report.

<p>
The following transcript illustrates a <tt>top-level-program</tt> being
tested in the REPL.

<p>

<p><tt>&gt;&nbsp;(top-level-program&nbsp;(import&nbsp;(rnrs))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"hello!\n"))<br>

hello!</tt>
<p>
<h3><a name="g97"></a><a name="./libraries:h4"></a>Section 10.4. Standalone import and export forms<a name="SECTLIBRARYIMPORTEXPORTFORMS"></a></h3>



<p>
Although not required by the Revised<sup>6</sup> Report,
<i>Chez&nbsp;Scheme</i> supports the use of standalone import and
export forms.
The import forms can appear anywhere other definitions
can appear, including within a <tt>library</tt> body,
<tt>module</tt> (Section&nbsp;<a href="./syntax.html#g106">11.5</a>) body,
<tt>lambda</tt> or other local body, and at top level.
The export forms can appear within the definitions of a
<tt>library</tt> or <tt>module</tt> body to specify additional
exports for the library or module.

<p>
Within a library or top-level program, the keywords for
these forms must be imported from the <tt>(chezscheme)</tt>
library to be available for use, since they are not
defined in any of the Revised<sup>6</sup> Report libraries.

<p>
<a name="./libraries:s16"></a><span class=formdef><b>syntax</b>: <tt>(import&nbsp;<i>import-spec</i>&nbsp;...)</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>(import-only&nbsp;<i>import-spec</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>An <tt>import</tt> or <tt>import-only</tt> form is a definition and can
appear anywhere other definitions can appear, including
at the top level of a program, nested within the bodies of
<tt>lambda</tt> expressions, and nested within modules
and libraries.

<p>
Each <tt><i>import-spec</i></tt> must take one of the following forms.

<p>

<p><tt><i>import-set</i><br>

(for&nbsp;<i>import-set</i>&nbsp;<i>import-level</i>&nbsp;...)</tt>
<p>The <tt>for</tt> wrapper and <tt><i>import-level</i></tt> are described in 
Chapter&nbsp;<a href="http://scheme.com/tspl4/./libraries.html#g142">10</a> of <i>The Scheme Programming Language, 4th Edition</i>.
They are ignored by <i>Chez&nbsp;Scheme</i>, which determines
automatically the levels at which identifiers must
be imported, as permitted by the Revised<sup>6</sup> Report.
This frees the programmer from the obligation
to do so and results in more generality as well as more
precision in the set of libraries actually imported
at compile and run time&nbsp;[<a class=citation href="./bibliography.html#g178">21</a>,<a class=citation href="./bibliography.html#g176">19</a>].

<p>
An <tt><i>import-set</i></tt> must take one of the following forms:

<p>

<p><tt><i>library-spec</i><br>

<i>module-name</i><br>

(only&nbsp;<i>import-set</i>&nbsp;<i>identifier</i>&nbsp;...)<br>

(except&nbsp;<i>import-set</i>&nbsp;<i>identifier</i>&nbsp;...)<br>

(prefix&nbsp;<i>import-set</i>&nbsp;<i>prefix</i>)<br>

(add-prefix&nbsp;<i>import-set</i>&nbsp;<i>prefix</i>)<br>

(drop-prefix&nbsp;<i>import-set</i>&nbsp;<i>prefix</i>)<br>

(rename&nbsp;<i>import-set</i>&nbsp;(<i>import-name</i>&nbsp;<i>internal-name</i>)&nbsp;...)<br>

(alias&nbsp;<i>import-set</i>&nbsp;(<i>import-name</i>&nbsp;<i>internal-name</i>)&nbsp;...)</tt>
<p>Several of these are specified by the Revised<sup>6</sup> Report; the remainder
are <i>Chez&nbsp;Scheme</i> extensions, including <tt><i>module-name</i></tt> and the
<tt>add-prefix</tt>, <tt>drop-prefix</tt>, and <tt>alias</tt> forms.

<p>
An <tt>import</tt> or <tt>import-only</tt> form makes the specified bindings
visible in the scope in which they appear.
Except at top level, they differ in that <tt>import</tt> leaves all bindings
except for those shadowed by the imported names visible, whereas <tt>import-only</tt>
hides all existing bindings, i.e., makes only the imported names visible.
At top level, <tt>import-only</tt> behaves like <tt>import</tt>.

<p>
Each <tt><i>import-set</i></tt> identifies a set of names to make visible
as follows.

<p>
<dl compact>
<dt><tt><i>library-spec</i></tt>:<dd>
all exports of the library identified by the Revised<sup>6</sup> Report <tt><i>library-spec</i></tt>
(Chapter&nbsp;<a href="http://scheme.com/tspl4/./libraries.html#g142">10</a>).

<p>
<dt><tt><i>module-name</i></tt>:<dd>
all exports of module named by the identifier <tt><i>module-name</i></tt>

<p>
<dt><tt>(only&nbsp;<i>import-set</i>&nbsp;<i>identifier</i>&nbsp;...)</tt>:<dd>
of those specified by <tt><i>import-set</i></tt>, just <tt><i>identifier</i>&nbsp;...</tt>

<p>
<dt><tt>(except&nbsp;<i>import-set</i>&nbsp;<i>identifier</i>&nbsp;...)</tt>:<dd>
all specified by <tt><i>import-set</i></tt> except <tt><i>identifier</i>&nbsp;...</tt>

<p>
<dt><tt>(prefix&nbsp;<i>import-set</i>&nbsp;<i>prefix</i>)</tt>:<dd>
all specified by <tt><i>import-set</i></tt>, each prefixed by <tt><i>prefix</i></tt>

<p>
<dt><tt>(add-prefix&nbsp;<i>import-set</i>&nbsp;<i>prefix</i>)</tt>:<dd>
all specified by <tt><i>import-set</i></tt>, each prefixed by <tt><i>prefix</i></tt>
(just like <tt>prefix</tt>)

<p>
<dt><tt>(drop-prefix&nbsp;<i>import-set</i>&nbsp;<i>prefix</i>)</tt>:<dd>
all specified by <tt><i>import-set</i></tt>, with prefix <tt><i>prefix</i></tt> removed

<p>
<dt><tt>(rename&nbsp;<i>import-set</i>&nbsp;(<i>import-name</i>&nbsp;<i>internal-name</i>)&nbsp;...)</tt>:<dd>
all specified by <tt><i>import-set</i></tt>, with each identifier <tt><i>import-name</i></tt>
renamed to the corresponding identifier <tt><i>internal-name</i></tt>

<p>
<dt><tt>(alias&nbsp;<i>import-set</i>&nbsp;(<i>import-name</i>&nbsp;<i>internal-name</i>)&nbsp;...)</tt>:<dd>
all specified by <tt><i>import-set</i></tt>, with each <tt><i>internal-name</i></tt> as an alias
for <tt><i>import-name</i></tt>
</dl>

<p>
The <tt>alias</tt> form differs from the <tt>rename</tt> form in that both
<tt><i>import-name</i></tt> and <tt><i>internal-name</i></tt> are in the resulting set,
rather than just <tt><i>internal-name</i></tt>.

<p>
It is a syntax violation if the
given selection or transformation cannot be made because of a missing
export or prefix.

<p>
An identifier made visible via an import of a module or library is scoped as if its
definition appears where the import occurs.
The following example illustrates these scoping rules, using a local
module <tt>m</tt>.

<p>

<p><tt>(library&nbsp;(A)&nbsp;(export&nbsp;x)&nbsp;(import&nbsp;(rnrs))&nbsp;(define&nbsp;x&nbsp;0))<br>

(let&nbsp;([x&nbsp;1])<br>

&nbsp;&nbsp;(module&nbsp;m&nbsp;(x&nbsp;setter)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define-syntax&nbsp;x&nbsp;(identifier-syntax&nbsp;z))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;setter&nbsp;(lambda&nbsp;(x)&nbsp;(set!&nbsp;z&nbsp;x)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;z&nbsp;2))<br>

&nbsp;&nbsp;(let&nbsp;([y&nbsp;x]&nbsp;[z&nbsp;3])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(import&nbsp;m&nbsp;(prefix&nbsp;(A)&nbsp;a:))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(setter&nbsp;4)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;x&nbsp;a:x&nbsp;y&nbsp;z)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(4&nbsp;0&nbsp;1&nbsp;3)</tt>
<p>The inner <tt>let</tt> expression binds <tt>y</tt> to the value of
the <tt>x</tt> bound by the outer <tt>let</tt>.
The import of <tt>m</tt> makes the definitions of <tt>x</tt>
and <tt>setter</tt> visible within the inner <tt>let</tt>.
The import of <tt>(A)</tt> makes the variable <tt>x</tt> exported
from <tt>(A)</tt> visible as <tt>a:x</tt> within the body of the
inner <tt>let</tt>.
Thus, in the expression <tt>(list&nbsp;x&nbsp;a:x&nbsp;y&nbsp;z)</tt>, <tt>x</tt> refers to the
identifier macro exported from <tt>m</tt> while <tt>a:x</tt> refers to the
variable <tt>x</tt> exported from <tt>(A)</tt> and <tt>y</tt> and <tt>z</tt>
refer to the bindings established by the inner <tt>let</tt>.
The identifier macro <tt>x</tt> expands into a reference to
the variable <tt>z</tt> defined within the module.

<p>
With local import forms, it is rarely necessary to use the extended
import specifiers.
For example, an abstraction that encapsulates the import and reference
can easily be defined and used as follows.

<p>

<p><tt>(define-syntax&nbsp;from<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;m&nbsp;id)&nbsp;(let&nbsp;()&nbsp;(import-only&nbsp;m)&nbsp;id)]))
<br>
<br>
(library&nbsp;(A)&nbsp;(export&nbsp;x)&nbsp;(import&nbsp;(rnrs))&nbsp;(define&nbsp;x&nbsp;1))<br>

(let&nbsp;([x&nbsp;10])<br>

&nbsp;&nbsp;(module&nbsp;M&nbsp;(x)&nbsp;(define&nbsp;x&nbsp;2))<br>

&nbsp;&nbsp;(cons&nbsp;(from&nbsp;(A)&nbsp;x)&nbsp;(from&nbsp;M&nbsp;x)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(1&nbsp;.&nbsp;2)</tt>
<p>The definition of <tt>from</tt> could use <tt>import</tt> rather than
<tt>import-only</tt>, but by using <tt>import-only</tt> we get feedback
if an attempt is made to import an identifier from a library or
module that does not export the identifier.
With <tt>import</tt> instead of <tt>import-only</tt>, the current binding,
if any, would be visible if the library or module does not export the
specified name.

<p>

<p><tt>(define-syntax&nbsp;lax-from<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;m&nbsp;id)&nbsp;(let&nbsp;()&nbsp;(import&nbsp;m)&nbsp;id)]))
<br>
<br>
(library&nbsp;(A)&nbsp;(export&nbsp;x)&nbsp;(import&nbsp;(rnrs))&nbsp;(define&nbsp;x&nbsp;1))
<br>
<br>
(let&nbsp;([x&nbsp;10])<br>

&nbsp;&nbsp;(module&nbsp;M&nbsp;(x)&nbsp;(define&nbsp;x&nbsp;2))<br>

&nbsp;&nbsp;(+&nbsp;(from&nbsp;(A)&nbsp;x)&nbsp;(from&nbsp;M&nbsp;y)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;unbound&nbsp;identifier&nbsp;y</i><br>

&nbsp;<br>

(let&nbsp;([x&nbsp;10]&nbsp;[y&nbsp;20])<br>

&nbsp;&nbsp;(module&nbsp;M&nbsp;(x)&nbsp;(define&nbsp;x&nbsp;2))<br>

&nbsp;&nbsp;(+&nbsp;(lax-from&nbsp;(A)&nbsp;x)&nbsp;(lax-from&nbsp;M&nbsp;y)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;21</tt>
<p>Import visibility interacts with hygienic macro expansion in such a
way that, as one might expect,
an identifier <tt><i>x</i></tt> imported from a module <tt><i>M</i></tt> is treated in
the importing context as if the corresponding export identifier had
been present in the import form along with <tt><i>M</i></tt>.

<p>
The <tt>from</tt> abstraction above works because both <tt><i>M</i></tt> and <tt><i>id</i></tt>
appear in the input to the abstraction, so the imported <tt><i>id</i></tt> captures
the reference to <tt><i>id</i></tt>.

<p>
The following variant of <tt><i>from</i></tt> also works, because both names are
introduced into the output by the transformer.

<p>

<p><tt>(module&nbsp;M&nbsp;(x)&nbsp;(define&nbsp;x&nbsp;'x-of-M))<br>

(define-syntax&nbsp;x-from-M<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_)&nbsp;(let&nbsp;()&nbsp;(import&nbsp;M)&nbsp;x)]))
<br>
<br>
(let&nbsp;([x&nbsp;'local-x])&nbsp;(x-from-M))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;x-of-M</tt>
<p>On the other hand, imports of introduced module names do not capture
free references.

<p>

<p><tt>(let&nbsp;([x&nbsp;'local-x])<br>

&nbsp;&nbsp;(define-syntax&nbsp;alpha<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;var)&nbsp;(let&nbsp;()&nbsp;(import&nbsp;M)&nbsp;(list&nbsp;x&nbsp;var))]))<br>

&nbsp;<br>

&nbsp;&nbsp;(alpha&nbsp;x))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(x-of-M&nbsp;local-x)</tt>
<p>Similarly, imports from free module names do not capture references
to introduced variables.

<p>

<p><tt>(let&nbsp;([x&nbsp;'local-x])<br>

&nbsp;&nbsp;(define-syntax&nbsp;beta<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;m&nbsp;var)&nbsp;(let&nbsp;()&nbsp;(import&nbsp;m)&nbsp;(list&nbsp;x&nbsp;var))]))
<br>
<br>
&nbsp;&nbsp;(beta&nbsp;M&nbsp;x))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(local-x&nbsp;x-of-M)</tt>
<p>This semantics extends to prefixed, renamed, and aliased bindings
created by the extended <tt>import</tt> specifiers <tt>prefix</tt>,
<tt>rename</tt>, and <tt>alias</tt>.

<p>
The <tt>from</tt> abstraction
works for variables but not for exported keywords, record names,
or module names, since the output is an expression and may thus appear only where
expressions may appear.
A generalization of this technique is used in the following definition
of <tt>import*</tt>, which supports renaming of imported bindings and
selective import of specific bindings---without the use of the built-in
<tt>import</tt> subforms for selecting and renaming identifiers

<p>

<p><tt>(define-syntax&nbsp;import*<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;m)&nbsp;(begin)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;m&nbsp;(new&nbsp;old))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(module&nbsp;(new)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(module&nbsp;(tmp)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(import&nbsp;m)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(alias&nbsp;tmp&nbsp;old))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(alias&nbsp;new&nbsp;tmp))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;m&nbsp;id)&nbsp;(module&nbsp;(id)&nbsp;(import&nbsp;m))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;m&nbsp;spec0&nbsp;spec1&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(import*&nbsp;m&nbsp;spec0)&nbsp;(import*&nbsp;m&nbsp;spec1&nbsp;...))]))</tt>
<p>To selectively import an identifier from module or library <tt>m</tt>, the
<tt>import*</tt> form expands into an anonymous module that first
imports all exports of <tt>m</tt> then re-exports only the selected
identifier.
To rename on import the macro expands into an anonymous module that
instead exports an alias (Section&nbsp;<a href="./syntax.html#g111">11.10</a>) bound to the new name.

<p>
If the output placed the definition of <tt>new</tt> in the same
scope as the import of <tt>m</tt>, a naming conflict would arise
whenever <tt>new</tt> is also present in the interface
of <tt>m</tt>.
To prevent this, the output instead places the import within a nested
anonymous module and links <tt>old</tt> and <tt>new</tt>
by means of an alias for the introduced identifier <tt>tmp</tt>.

<p>
The macro expands recursively to handle multiple import specifications.
Each of the following examples imports <tt>cons</tt> as <tt>+</tt> and <tt>+</tt> as
<tt>cons</tt>, which is probably not a very good idea.

<p>

<p><tt>(let&nbsp;()<br>

&nbsp;&nbsp;(import*&nbsp;scheme&nbsp;(+&nbsp;cons)&nbsp;(cons&nbsp;+))<br>

&nbsp;&nbsp;(+&nbsp;(cons&nbsp;1&nbsp;2)&nbsp;(cons&nbsp;3&nbsp;4)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(3&nbsp;.&nbsp;7)
<br>
<br>
(let&nbsp;()<br>

&nbsp;&nbsp;(import*&nbsp;(rnrs)&nbsp;(+&nbsp;cons)&nbsp;(cons&nbsp;+))<br>

&nbsp;&nbsp;(+&nbsp;(cons&nbsp;1&nbsp;2)&nbsp;(cons&nbsp;3&nbsp;4)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(3&nbsp;.&nbsp;7)</tt>
<p><a name="./libraries:s17"></a><span class=formdef><b>syntax</b>: <tt>(export&nbsp;<i>export-spec</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>An <tt>export</tt> form is a definition and can appear with other
definitions at the front of a <tt>library</tt> or <tt>module</tt>.
It is a syntax error for an <tt>export</tt> form to appear in other
contexts, including at top level or among the definitions of a
top-level program or <tt>lambda</tt> body.

<p>
Each <tt><i>export-spec</i></tt> must take one of the following forms.

<p>

<p><tt><i>identifier</i><br>

(rename&nbsp;(<i>internal-name</i>&nbsp;<i>export-name</i>)&nbsp;...)<br>

(import&nbsp;<i>import-spec</i>&nbsp;...)</tt>
<p>where each <tt><i>internal-name</i></tt> and <tt><i>export-name</i></tt> is an identifier.
The first two are syntactically identical to <tt>library</tt>
<tt><i>export-spec</i></tt>s, while the third is syntactically
identical to a <i>Chez&nbsp;Scheme</i> <tt>import</tt> form, which is an extension of the
R6RS library <tt>import</tt> subform.
The first form names a single export, <tt><i>identifier</i></tt>, whose export
name is the same as its internal name.
The second names a set of exports, each of whose export name is
given explicitly and may differ from its internal name.

<p>
For the third, the identifiers identified by the <tt>import</tt> form
become exports, with aliasing, renaming, prefixing, etc., as specified by the
<tt><i>import-spec</i></tt>s.
The module or library whose bindings are exported by an <tt>import</tt>
form appearing within an <tt>export</tt> form can
be defined within or outside the exporting module or library and need
not be imported elsewhere within the exporting module or library.

<p>
The following library exports a two-armed-only variant of <tt>if</tt>
along with all remaining bindings of the <tt>(rnrs)</tt> library.

<p>

<p><tt>(library&nbsp;(rnrs-no-one-armed-if)&nbsp;(export)&nbsp;(import&nbsp;(except&nbsp;(chezscheme)&nbsp;if))<br>

&nbsp;&nbsp;(export&nbsp;if&nbsp;(import&nbsp;(except&nbsp;(rnrs)&nbsp;if)))<br>

&nbsp;&nbsp;(define-syntax&nbsp;if<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(import&nbsp;(only&nbsp;(rnrs)&nbsp;if))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;tst&nbsp;thn&nbsp;els)&nbsp;(if&nbsp;tst&nbsp;thn&nbsp;els)]))))
<br>
<br>
(import&nbsp;(rnrs-no-one-armed-if))<br>

(if&nbsp;#t&nbsp;3&nbsp;4)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(if&nbsp;#t&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;invalid&nbsp;syntax</i></tt>
<p>Another way to define the same library would be to define the
two-armed-only <tt>if</tt> with a different internal name and use
<tt>rename</tt> to export it under the name <tt>if</tt>:

<p>

<p><tt>(library&nbsp;(rnrs-no-one-armed-if)&nbsp;(export)&nbsp;(import&nbsp;(chezscheme))<br>

&nbsp;&nbsp;(export&nbsp;(rename&nbsp;(two-armed-if&nbsp;if))&nbsp;(import&nbsp;(except&nbsp;(rnrs)&nbsp;if)))<br>

&nbsp;&nbsp;(define-syntax&nbsp;two-armed-if<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;tst&nbsp;thn&nbsp;els)&nbsp;(if&nbsp;tst&nbsp;thn&nbsp;els)])))
<br>
<br>
(import&nbsp;(rnrs-no-one-armed-if))<br>

(if&nbsp;#t&nbsp;3&nbsp;4)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(if&nbsp;#t&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;invalid&nbsp;syntax</i></tt>
<p>The placement of the <tt>export</tt> form in the library body is
irrelevant, e.g., the <tt>export</tt> form can appear after the
definition in the examples above.


<p>
<a name="./libraries:s18"></a><span class=formdef><b>syntax</b>: <tt>(indirect-export&nbsp;<i>id</i>&nbsp;<i>indirect-id</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This form is a definition and can appear wherever any other definition
can appear.

<p>
An <tt>indirect-export</tt> form declares that the named
<tt><i>indirect-id</i></tt>s are indirectly exported to top level if <tt><i>id</i></tt>
is exported to top level.

<p>
In general, if an identifier is not directly exported by a library or
module, it can be referenced outside of the library or module only in
the expansion of a macro defined within and exported from the library
or module.
Even this cannot occur for libraries or modules defined at top level
(or nested within other libraries or modules), unless either (1)
the library or module has been set up to implicitly export all
identifiers as indirect exports, or (2) each indirectly exported
identifier is explicitly declared as an indirect export of some
other identifier that is exported, either directly or indirectly, from
the library or module, via an <tt>indirect-export</tt> or the built-in
indirect export feature of a <tt>module</tt> export subform.
By default, (1) is true for a library and false for a module, but the
default can be overridden via the <tt>implicit-exports</tt>
form, which is described below.

<p>
This form is meaningful only within a top-level library, top-level module,
or module enclosed within a library or top-level module, although it
has no effect if the library or module already implicitly exports all
bindings.
It is allowed anywhere else definitions can appear, however, so macros
that expand into indirect export forms can be used in any definition
context.

<p>
Indirect exports are listed so the compiler can determine the
exact set of bindings (direct and indirect) that must be inserted
into the top-level environment, and conversely, the set of bindings
that may be treated more efficiently as local bindings (and
perhaps discarded, if they are not used).

<p>
In the example below, <tt>indirect-export</tt> is used to indirectly
export <tt>count</tt> to top level when <tt>current-count</tt> is
exported to top level.

<p>

<p><tt>(module&nbsp;M&nbsp;(bump-count&nbsp;current-count)<br>

&nbsp;&nbsp;(define-syntax&nbsp;current-count&nbsp;(identifier-syntax&nbsp;count))<br>

&nbsp;&nbsp;(indirect-export&nbsp;current-count&nbsp;count)<br>

&nbsp;&nbsp;(define&nbsp;count&nbsp;0)<br>

&nbsp;&nbsp;(define&nbsp;bump-count<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;count&nbsp;(+&nbsp;count&nbsp;1)))))
<br>
<br>
(import&nbsp;M)<br>

(bump-count)<br>

current-count&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

count&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;unbound&nbsp;identifier&nbsp;count</i></tt>
<p>An <tt>indirect-export</tt> form is not required to make <tt>count</tt>
visible for <tt>bump-count</tt>, since it is a procedure whose code
is contained within the module rather than a macro that might expand
into a reference to <tt>count</tt> somewhere outside the module.

<p>
It is often useful to use <tt>indirect-export</tt> in the output
of a macro that expands into another macro named <tt><i>a</i></tt> if
<tt><i>a</i></tt> expands into references to identifiers that might not
be directly exported, as illustrated by the alternative definition
of module <tt>M</tt> above.

<p>

<p><tt>(define-syntax&nbsp;define-counter<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;getter&nbsp;bumper&nbsp;init&nbsp;incr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;count&nbsp;init)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-syntax&nbsp;getter&nbsp;(identifier-syntax&nbsp;count))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(indirect-export&nbsp;getter&nbsp;count)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;bumper<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;count&nbsp;(incr&nbsp;count)))))]))
<br>
<br>
(module&nbsp;M&nbsp;(bump-count&nbsp;current-count)<br>

&nbsp;&nbsp;(define-counter&nbsp;current-count&nbsp;bump-count&nbsp;0&nbsp;add1))</tt>
<p><a name="./libraries:s19"></a><span class=formdef><b>syntax</b>: <tt>(implicit-exports&nbsp;#t)</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>(implicit-exports&nbsp;#f)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>An <tt>implicit-exports</tt> form is a definition and can appear with other
definitions at the front of a <tt>library</tt> or <tt>module</tt>.
It is a syntax error for an <tt>implicit-exports</tt> form to appear in other
contexts, including at top level or among the definitions of a
top-level program or <tt>lambda</tt> body.

<p>
The <tt>implicit-exports</tt> form determines whether identifiers
not directly exported from a module or library are automatically
indirectly exported to the top level if any meta-binding (keyword, meta
definition, or property definition) is directly exported to top level
from the library or module.
The default for libraries is <tt>#t</tt>, to match the behavior required
by the Revised<sup>6</sup> Report, while the default for modules is <tt>#f</tt>.
The <tt>implicit-exports</tt> form is meaningful only within a library,
top-level module, or module enclosed within a library or top-level module.
It is allowed in a module enclosed within a <tt>lambda</tt>, <tt>let</tt>,
or similar body, but ignored there because none of that module's bindings
can be exported to top level.

<p>
The advantage of <tt>(implicit-exports&nbsp;#t)</tt> is that indirect exports
need not be listed explicitly, which is convenient.
A disadvantage is that it often results in more bindings than necessary
being elevated to top level where they cannot be discarded as useless
by the optimizer.
For modules, another disadvantage is such bindings
cannot be proven immutable, which inhibits important optimizations such
as procedure inlining.
This can result in significantly lower run-time performance.

<p>

<h3><a name="g98"></a><a name="./libraries:h5"></a>Section 10.5. Explicitly invoking libraries<a name="SECTLIBRARYINVOCATION"></a></h3>



<p>
<a name="./libraries:s20"></a><span class=formdef><b>procedure</b>: <tt>(invoke-library&nbsp;<i>libref</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>libref</i></tt> must be an s-expression in the form of a library reference.
The syntax for library references is given in
Chapter&nbsp;<a href="http://scheme.com/tspl4/./libraries.html#g142">10</a> of <i>The Scheme Programming Language, 4th Edition</i> and in the Revised<sup>6</sup>
Report.

<p>
A library is implicitly invoked when or before some expression
outside the library (e.g., in another library or in a top-level
program) evaluates a reference to one of the library's exported
variables.
When the library is invoked, its body expressions (the right-hand-sides
of the library's variable definitions and its initialization
expressions) are evaluated.
Once invoked, the library is not invoked again within the same process,
unless it is first explicitly redefined or reloaded.

<p>
<tt>invoke-library</tt> explicitly invokes the library specified
by <tt><i>libref</i></tt> if it has not already been invoked or has since
been redefined or reloaded.
If the library has not yet been loaded, <tt>invoke-library</tt>
first loads the library via the process described in
Section&nbsp;<a href="./use.html#g9">2.4</a>.

<p>
<tt>invoke-library</tt> is typically only useful for libraries whose
body expressions have side effects.
It is useful to control when the side effects occur and to force
invocation of a library that has no exported variables.
Invoking a library does not force the compile-time code (macro
transformer expressions and meta definitions) to be loaded or
evaluated, nor does it cause the library's bindings to become
visible.

<p>
It is good practice to avoid externally visible side effects in
library bodies so the library can be used equally well at compile
time and run time.
When feasible, consider moving the side effects of a library body
to an initialization routine and adding a top-level program that
imports the library and calls the initialization routine.
With this structure, calls to <tt>invoke-library</tt> on the
library can be replaced by calls to 
<a name="./libraries:s21"></a><tt>load-program</tt> on the
top-level program.

<p>

<h3><a name="g99"></a><a name="./libraries:h6"></a>Section 10.6. Library Parameters<a name="SECTLIBRARYPARAMETERS"></a></h3>



<p>
<a name="./libraries:s22"></a>The parameters described below control where <tt>import</tt> looks
when attempting to load a library, whether it compiles the libraries
it loads, and whether it displays tracking messages as it performs its
search.

<p>
<a name="./libraries:s23"></a><span class=formdef><b>thread parameter</b>: <tt>library-directories</tt></span>
<br><span class=formdef><b>thread parameter</b>: <tt>library-extensions</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The parameter <tt>library-directories</tt> determines where the files
containing library source and object code are located in the file system,
and the parameter <tt>library-extensions</tt> determines the filename
extensions for the files holding the code, as described in
section&nbsp;<a href="./use.html#g9">2.4</a>.
The values of both parameters are lists of pairs of strings.
The first string in each <tt>library-directories</tt> pair identifies a
source-file root directory, and the second identifies the corresponding
object-file root directory.
Similarly, the first string in each <tt>library-extensions</tt> pair
identifies a source-file extension, and the second identifies the
corresponding object-file extension.
The full path of a library source or object file consists of the source or
object root followed by the components of the library name prefixed by
slashes, with the library extension added on the end.
For example, for root <tt>/usr/lib/scheme</tt>, library name
<tt>(app&nbsp;lib1)</tt>, and extension <tt>.sls</tt>, the full path is
<tt>/usr/lib/scheme/app/lib1.sls</tt>.
If the library name portion forms an absolute pathname, e.g.,
<tt>~/.myappinit</tt>, the <tt>library-directories</tt> parameter is
ignored and no prefix is added.

<p>
The initial values of these parameters are shown below.

<p>

<p><tt>(library-directories)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(("."&nbsp;.&nbsp;"."))
<br>
<br>
(library-extensions)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;((".chezscheme.sls"&nbsp;.&nbsp;".chezscheme.so")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;(".ss"&nbsp;.&nbsp;".so")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;(".sls"&nbsp;.&nbsp;".so")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;(".scm"&nbsp;.&nbsp;".so")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;(".sch"&nbsp;.&nbsp;".so"))</tt>
<p>As a convenience, when either of these parameters is set, any element of
the list can be specified as a single source string, in which case the
object string is determined automatically.
For <tt>library-directories</tt>, the object string is the same as
the source string, effectively naming the
same directory as a source- and object-code root.
For <tt>library-extensions</tt>, the object string is the result of
removing the last (or only) extension from the string and appending
<tt>".so"</tt>.
The <tt>library-directories</tt> and <tt>library-extensions</tt>
parameters also accept as input strings in the format described
in Section&nbsp;<a href="./use.html#g10">2.5</a>
for the
<a name="./libraries:s24"></a><tt>--libdirs</tt> and
<a name="./libraries:s25"></a><tt>--libexts</tt> command-line
options.

<p>
<a name="./libraries:s26"></a><span class=formdef><b>thread parameter</b>: <tt>compile-imported-libraries</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When the value of this parameter is <tt>#t</tt>, <tt>import</tt>
automatically calls the value of the <tt>compile-library-handler</tt> parameter (which defaults
to a procedure that simply calls <tt>compile-library</tt>) on any imported library if
the object file is missing, older than the corresponding source file,
older than any source files included (via <a name="./libraries:s27"></a><tt>include</tt>) when the
object file was created, or itself requires a library that has been or must
be recompiled, as described in Section&nbsp;<a href="./use.html#g9">2.4</a>.
The <tt>library-timestamp-mode</tt> parameter controls the meaning of "older."
The default initial value of this parameter is <tt>#f</tt>.
It can be set to <tt>#t</tt> via the command-line option
<a name="./libraries:s28"></a><tt>--compile-imported-libraries</tt>.

<p>
When <tt>import</tt> compiles a library via this mechanism, it does not
also load the compiled library, because this would cause portions of
library to be reevaluated.
Because of this, run-time expressions in the file outside of a
<tt>library</tt> form will not be evaluated.
If such expressions are present and should be evaluated, the library
should be loaded explicitly.

<p>
<a name="./libraries:s29"></a><span class=formdef><b>thread parameter</b>: <tt>import-notify</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>When the new parameter <tt>import-notify</tt> is set to a true value,
<tt>import</tt> displays messages to the console-output port as it
searches for the file containing each library it needs to load.
The default value of this parameter is <tt>#f</tt>.

<p>
<a name="./libraries:s30"></a><span class=formdef><b>thread parameter</b>: <tt>library-search-handler</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of parameter must be a procedure that follows the protocol described
below for <tt>default-library-search-handler</tt>, which is the default value
of this parameter.

<p>
The value of this parameter is invoked to locate the source or object code for
a library during <tt>import</tt>, <tt>compile-whole-program</tt>, or
<tt>compile-whole-library</tt>.

<p>
<a name="./libraries:s31"></a><span class=formdef><b>procedure</b>: <tt>(default-library-search-handler&nbsp;<i>who</i>&nbsp;<i>library</i>&nbsp;<i>directories</i>&nbsp;<i>extensions</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This procedure is the default value of the <tt>library-search-handler</tt>,
which is
called to locate the source or object code for a library
during <tt>import</tt>,
<tt>compile-whole-program</tt>, or <tt>compile-whole-library</tt>.
<tt><i>who</i></tt> is a symbol that provides context in <tt>import-notify</tt> messages.
<tt><i>library</i></tt> is the name of the desired library.
<tt><i>directories</i></tt> is a list of source and object directory pairs in
the form returned by <tt>library-directories</tt>.
<tt><i>extensions</i></tt> is a list of source and object extension pairs in the form
returned by <tt>library-extensions</tt>.

<p>
This procedure searches the specified directories until it finds a library source or
object file with one of the specified extensions.
If it finds the source file first, it constructs the corresponding
object file path and checks whether the file exists.
If it finds the object file first, the procedure looks for a corresponding
source file with one of the given source extensions in a source directory paired
with that object directory.
The procedure returns three values:
the file-system path of the library source file or <tt>#f</tt> if not found,
the file-system path of the corresponding object file, which may be <tt>#f</tt>,
and a boolean that is true if the object file exists.

<p>
<a name="./libraries:s32"></a><span class=formdef><b>thread parameter</b>: <tt>library-timestamp-mode</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The value of parameter must be either <tt>'modification-time</tt> (the
default) or <tt>'exists</tt>. If it is <tt>'modification-time</tt>,
the timestamp of library source and object files is obtained with
<tt>file-modification-time</tt> to determine whether a file is older
than the other. If the parameter's value is <tt>'exists</tt>, then all
files that exist are considered to have the same age. This parameter's
value can be set to <tt>'exists</tt> via the command-line option
<a name="./libraries:s33"></a><tt>--disable-library-timestamps</tt>.


<p>

<h3><a name="g100"></a><a name="./libraries:h7"></a>Section 10.7. Library Inspection<a name="SECTLIBRARYINSPECTION"></a></h3>



<p>
<a name="./libraries:s34"></a><span class=formdef><b>procedure</b>: <tt>(library-list)</tt></span>
<br>
<b>returns: </b>a list of the libraries currently defined
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The set of libraries initially defined includes those listed in
Section&nbsp;<a href="./libraries.html#g94">10.1</a> above.

<p>
<a name="./libraries:s35"></a><span class=formdef><b>procedure</b>: <tt>(library-version&nbsp;<i>libref</i>)</tt></span>
<br>
<b>returns: </b>the version of the specified library
<br><span class=formdef><b>procedure</b>: <tt>(library-exports&nbsp;<i>libref</i>)</tt></span>
<br>
<b>returns: </b>a list of the exports of the specified library
<br><span class=formdef><b>procedure</b>: <tt>(library-requirements&nbsp;<i>libref</i>)</tt></span>
<br>
<b>returns: </b>a list of libraries required by the specified library
<br><span class=formdef><b>procedure</b>: <tt>(library-requirements&nbsp;<i>libref</i>&nbsp;<i>options</i>)</tt></span>
<br>
<b>returns: </b>a list of libraries required by the specified library, filtered by <tt><i>options</i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(library-object-filename&nbsp;<i>libref</i>)</tt></span>
<br>
<b>returns: </b>the name of the object file holding the specified library, if any
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Information can be obtained only for built-in libraries or libraries
previously loaded into the system.
<tt><i>libref</i></tt> must be an s-expression in the form of a library reference.
The syntax for library references is given in
Chapter&nbsp;<a href="http://scheme.com/tspl4/./libraries.html#g142">10</a> of <i>The Scheme Programming Language, 4th Edition</i> and in the Revised<sup>6</sup>
Report.

<p>
The <tt>library-version</tt> return value is a list of numbers
(possibly empty) representing the library's version.

<p>
The list of exports returned by <tt>library-exports</tt> is a list of
symbols, each identifying one of the library's exports.
The order in which the elements appear is unspecified.

<p>
When the optional <tt><i>options</i></tt> argument is supplied, it must be
an enumeration set over the symbols constituting
valid library-requirements options, as described in the
<tt>library-requirements-options</tt> entry below.
It defaults to a set containing all of the options.
Each element of the list of libraries returned by
<tt>library-requirements</tt> is an s-expression form of a library
reference.
The library reference includes the actual version of the library that is
present in the system (if nonempty), even if a version was not specified
when it was imported.
The order in which the libraries appear in the list returned by
<tt>library-requirements</tt> is unspecified.

<p>
<tt>library-object-filename</tt> returns a string naming the object
file if the specified library was loaded from or compiled to an object
file.
Otherwise, it returns <tt>#f</tt>.


<p>

<p><tt>(with-output-to-file&nbsp;"A.ss"<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(pretty-print<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(library&nbsp;(A&nbsp;(1&nbsp;2))&nbsp;(export&nbsp;x&nbsp;z)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(import&nbsp;(rnrs))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;x&nbsp;'ex)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;y&nbsp;23)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-syntax&nbsp;z<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e)&nbsp;(+&nbsp;y&nbsp;e)])))))<br>

&nbsp;&nbsp;'replace)<br>

(with-output-to-file&nbsp;"B.ss"<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(pretty-print<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(library&nbsp;(B)&nbsp;(export&nbsp;x&nbsp;w)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(import&nbsp;(rnrs)&nbsp;(A))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;w&nbsp;(cons&nbsp;(z&nbsp;12)&nbsp;x)))))<br>

&nbsp;&nbsp;'replace)<br>

(compile-imported-libraries&nbsp;#t)<br>

(import&nbsp;(B))<br>

(library-exports&nbsp;'(A))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(x&nbsp;z)&nbsp;;&nbsp;or&nbsp;(z&nbsp;x)<br>

(library-exports&nbsp;'(A&nbsp;(1&nbsp;2)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(x&nbsp;z)&nbsp;;&nbsp;or&nbsp;(z&nbsp;x)<br>

(library-exports&nbsp;'(B))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(x&nbsp;w)&nbsp;;&nbsp;or&nbsp;(w&nbsp;x)<br>

(library-version&nbsp;'(A))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2)<br>

(library-version&nbsp;'(B))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;()<br>

(library-requirements&nbsp;'(A))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;((rnrs&nbsp;(6)))<br>

(library-requirements&nbsp;'(B))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;((rnrs&nbsp;(6))&nbsp;(A&nbsp;(1&nbsp;2)))<br>

(library-object-filename&nbsp;'(A))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"A.so"<br>

(library-object-filename&nbsp;'(B))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"B.so"</tt>
<p><a name="./libraries:s36"></a><span class=formdef><b>syntax</b>: <tt>(library-requirements-options&nbsp;<i>symbol</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>a library-requirements-options enumeration set
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Library-requirements-options enumeration sets are passed to
<tt>library-requirements</tt> to determine the library requirements
to be listed.  The available options are described below.

<p>
<dl compact>
<dt><tt>import</tt>:<dd>
Include the libraries that must be imported when the specified library
is imported.

<p>
<dt><tt>visit@visit</tt>:<dd>
Includes the libraries that must be visited when the specified library
is visited.

<p>
<dt><tt>invoke@visit</tt>:<dd>
Include the libraries that must be invoked when the specified library
is visited.

<p>
<dt><tt>invoke</tt>:<dd>
Includes the libraries that must be invoked when the specified library
is invoked.
</dl>

<p>




<hr class=copyright align=left>
<p>
<a class=plain href="index.html">Chez Scheme Version 10 User's Guide</a><br>
Copyright &copy; 2024 Cisco Systems, Inc.<br>
Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License Version 2.0</a>
(<a class=plain href="canned/copyright.html">full copyright notice.</a>).</br>
Revised November 2024 for Chez Scheme Version 10.1.0<br>
<a class=plain href="canned/about.html">about this book</a>
</tr></table>
</body>
</html>
