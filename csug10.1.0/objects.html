<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Operations on Objects</title>
<link href="csug.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g48"></a>
<a name="./objects:h0"></a>

<h1>Chapter 7. Operations on Objects<a name="CHPTOBJECTS"></a></h1>





<p>
This chapter describes operations specific to <i>Chez&nbsp;Scheme</i> on
nonnumeric objects, including standard objects such as pairs and
numbers and <i>Chez&nbsp;Scheme</i> extensions such as boxes and records.
Chapter&nbsp;<a href="./numeric.html#g67">8</a> describes operations on numbers.
See Chapter&nbsp;<a href="http://scheme.com/tspl4/./objects.html#g106">6</a> of <i>The Scheme Programming Language, 4th Edition</i> or the Revised<sup>6</sup> Report
on Scheme for a description of standard operations on objects.

<p>

<h3><a name="g49"></a><a name="./objects:h1"></a>Section 7.1. Missing R6RS Type Predicates<a name="SECTMISSINGR6RSTYPEPREDS"></a></h3>



<p>
<a name="./objects:s0"></a><span class=formdef><b>procedure</b>: <tt>(enum-set?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an enum set, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This predicate is not defined by the Revised<sup>6</sup> Report, but should be.

<p>
<a name="./objects:s1"></a><span class=formdef><b>procedure</b>: <tt>(record-constructor-descriptor?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a record constructor descriptor, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This predicate is not defined by the Revised<sup>6</sup> Report, but should be.


<p>

<h3><a name="g50"></a><a name="./objects:h2"></a>Section 7.2. Pairs and Lists</h3>



<p>
<a name="./objects:s2"></a><span class=formdef><b>procedure</b>: <tt>(atom?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is not a pair, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>atom?</tt> is equivalent to <tt>(lambda&nbsp;(x)&nbsp;(not&nbsp;(pair?&nbsp;x)))</tt>.

<p>

<p><tt>(atom?&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(atom?&nbsp;'(3&nbsp;.&nbsp;4))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(atom?&nbsp;'())&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(atom?&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s3"></a><span class=formdef><b>procedure</b>: <tt>(list-head&nbsp;<i>list</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>a list of the first <tt><i>n</i></tt> elements of <tt><i>list</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer less than or equal to
the length of <tt><i>list</i></tt>.

<p>
<tt>list-head</tt> and the standard Scheme procedure <tt>list-tail</tt> 
may be used together to split a list into two separate lists.
While <tt>list-tail</tt> performs no allocation but instead returns a
sublist of the original list, <tt>list-head</tt> always returns a copy
of the first portion of the list.

<p>
<tt>list-head</tt> may be defined as follows.

<p>

<p><tt>(define&nbsp;list-head<br>

&nbsp;&nbsp;(lambda&nbsp;(ls&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;ls)&nbsp;(list-head&nbsp;(cdr&nbsp;ls)&nbsp;(-&nbsp;n&nbsp;1))))))
<br>
<br>
(list-head&nbsp;'(a&nbsp;b&nbsp;c)&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;()<br>

(list-head&nbsp;'(a&nbsp;b&nbsp;c)&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b)<br>

(list-head&nbsp;'(a&nbsp;b&nbsp;c)&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(list-head&nbsp;'(a&nbsp;b&nbsp;c&nbsp;.&nbsp;d)&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b)<br>

(list-head&nbsp;'(a&nbsp;b&nbsp;c&nbsp;.&nbsp;d)&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(list-head&nbsp;'#1=(a&nbsp;.&nbsp;#1#)&nbsp;5)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(a&nbsp;a&nbsp;a&nbsp;a&nbsp;a)</tt>
<p><a name="./objects:s4"></a><span class=formdef><b>procedure</b>: <tt>(last-pair&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>the last pair of a <tt><i>list</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>list</i></tt> must not be empty.
<tt>last-pair</tt> returns the last pair (not the last element) of <tt><i>list</i></tt>.
<tt><i>list</i></tt> may be an improper list, in which case the last pair is the
pair containing the last element and the terminating object.

<p>

<p><tt>(last-pair&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(d)<br>

(last-pair&nbsp;'(a&nbsp;b&nbsp;c&nbsp;.&nbsp;d))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(c&nbsp;.&nbsp;d)</tt>
<p><a name="./objects:s5"></a><span class=formdef><b>procedure</b>: <tt>(list-assuming-immutable?&nbsp;<i>v</i>)</tt></span>
<br>
<b>returns: </b>a boolean
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Like <tt>list?</tt>, but on the assumption that any pairs traversed while
computing the result are never mutated further, the result is produced in amoritized
constant time.

<p>

<p><tt>(list-assuming-immutable?&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(list-assuming-immutable?&nbsp;'(a&nbsp;b&nbsp;c&nbsp;.&nbsp;d))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s6"></a><span class=formdef><b>procedure</b>: <tt>(list-copy&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>a copy of <tt><i>list</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>list-copy</tt> returns a list <tt>equal?</tt> to <tt><i>list</i></tt>, using new pairs
to reform the top-level list structure.

<p>

<p><tt>(list-copy&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)
<br>
<br>
(let&nbsp;([ls&nbsp;'(a&nbsp;b&nbsp;c)])<br>

&nbsp;&nbsp;(equal?&nbsp;ls&nbsp;(list-copy&nbsp;ls)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(let&nbsp;([ls&nbsp;'(a&nbsp;b&nbsp;c)])<br>

&nbsp;&nbsp;(let&nbsp;([ls-copy&nbsp;(list-copy&nbsp;ls)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(eq?&nbsp;ls-copy&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eq?&nbsp;(cdr&nbsp;ls-copy)&nbsp;(cdr&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eq?&nbsp;(cddr&nbsp;ls-copy)&nbsp;(cddr&nbsp;ls)))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s7"></a><span class=formdef><b>procedure</b>: <tt>(list*&nbsp;<i>obj</i>&nbsp;...&nbsp;<i>final-obj</i>)</tt></span>
<br>
<b>returns: </b>a list of <tt><i>obj</i>&nbsp;...</tt> terminated by <tt><i>final-obj</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>list*</tt> is identical to the Revised<sup>6</sup> Report <tt>cons*</tt>.


<p>
<a name="./objects:s8"></a><span class=formdef><b>procedure</b>: <tt>(make-list&nbsp;<i>n</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-list&nbsp;<i>n</i>&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>a list of <tt><i>n</i></tt> <tt><i>objs</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>n</i></tt> must be a nonnegative integer.
If <tt><i>obj</i></tt> is omitted, the elements of the list are unspecified.

<p>

<p><tt>(make-list&nbsp;0&nbsp;'())&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;()<br>

(make-list&nbsp;3&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(0&nbsp;0&nbsp;0)<br>

(make-list&nbsp;2&nbsp;"hi")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;("hi"&nbsp;"hi")</tt>
<p><a name="./objects:s9"></a><span class=formdef><b>procedure</b>: <tt>(iota&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>a list of integers from 0 (inclusive) to <tt><i>n</i></tt> (exclusive)
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer.

<p>

<p><tt>(iota&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;()<br>

(iota&nbsp;5)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(0&nbsp;1&nbsp;2&nbsp;3&nbsp;4)</tt>
<p><a name="./objects:s10"></a><span class=formdef><b>procedure</b>: <tt>(enumerate&nbsp;<i>ls</i>)</tt></span>
<br>
<b>returns: </b>a list of integers from 0 (inclusive) to the length of <tt><i>ls</i></tt> (exclusive)
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>(enumerate&nbsp;'())&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;()<br>

(enumerate&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(0&nbsp;1&nbsp;2)<br>

(let&nbsp;([ls&nbsp;'(a&nbsp;b&nbsp;c)])<br>

&nbsp;&nbsp;(map&nbsp;cons&nbsp;ls&nbsp;(enumerate&nbsp;ls)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;((a&nbsp;.&nbsp;0)&nbsp;(b&nbsp;.&nbsp;1)&nbsp;(c&nbsp;.&nbsp;2))</tt>
<p><a name="./objects:s11"></a><span class=formdef><b>procedure</b>: <tt>(remq!&nbsp;<i>obj</i>&nbsp;<i>list</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(remv!&nbsp;<i>obj</i>&nbsp;<i>list</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(remove!&nbsp;<i>obj</i>&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>a list containing the elements of <tt><i>list</i></tt> with all occurrences of <tt><i>obj</i></tt> removed
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These procedures are similar to the Revised<sup>6</sup> Report
<tt>remq</tt>, <tt>remv</tt>, and <tt>remove</tt> procedures, except
<tt>remq!</tt>, <tt>remv!</tt> and <tt>remove!</tt> use pairs from the
input list to build the output list.
They perform less allocation but are not
necessarily faster than their nondestructive counterparts.
Their use can easily lead to confusing or incorrect results if used
indiscriminately.

<p>

<p><tt>(remq!&nbsp;'a&nbsp;'(a&nbsp;b&nbsp;a&nbsp;c&nbsp;a&nbsp;d))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(b&nbsp;c&nbsp;d)
<br>
<br>
(remv!&nbsp;#\a&nbsp;'(#\a&nbsp;#\b&nbsp;#\c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(#\b&nbsp;#\c)
<br>
<br>
(remove!&nbsp;'(c)&nbsp;'((a)&nbsp;(b)&nbsp;(c)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;((a)&nbsp;(b))</tt>
<p><a name="./objects:s12"></a><span class=formdef><b>procedure</b>: <tt>(substq&nbsp;<i>new</i>&nbsp;<i>old</i>&nbsp;<i>tree</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(substv&nbsp;<i>new</i>&nbsp;<i>old</i>&nbsp;<i>tree</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(subst&nbsp;<i>new</i>&nbsp;<i>old</i>&nbsp;<i>tree</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(substq!&nbsp;<i>new</i>&nbsp;<i>old</i>&nbsp;<i>tree</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(substv!&nbsp;<i>new</i>&nbsp;<i>old</i>&nbsp;<i>tree</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(subst!&nbsp;<i>new</i>&nbsp;<i>old</i>&nbsp;<i>tree</i>)</tt></span>
<br>
<b>returns: </b>a tree with <tt><i>new</i></tt> substituted for occurrences of <tt><i>old</i></tt> in <tt><i>tree</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These procedures traverse <tt><i>tree</i></tt>, replacing all objects equivalent to
the object <tt><i>old</i></tt> with the object <tt><i>new</i></tt>.

<p>
The equivalence test for <tt>substq</tt> and <tt>substq!</tt> is <tt>eq?</tt>,
for <tt>substv</tt> and <tt>substv!</tt> is <tt>eqv?</tt>,
and for <tt>subst</tt> and <tt>subst!</tt> is <tt>equal?</tt>.

<p>
<tt>substq!</tt>, <tt>substv!</tt>, and <tt>subst!</tt> perform the
substitutions destructively.
They perform less allocation but are not
necessarily faster than their nondestructive counterparts.
Their use can easily lead to confusing or incorrect results if used
indiscriminately.


<p>

<p><tt>(substq&nbsp;'a&nbsp;'b&nbsp;'((b&nbsp;c)&nbsp;b&nbsp;a))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;((a&nbsp;c)&nbsp;a&nbsp;a)
<br>
<br>
(substv&nbsp;2&nbsp;1&nbsp;'((1&nbsp;.&nbsp;2)&nbsp;(1&nbsp;.&nbsp;4)&nbsp;.&nbsp;1))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;((2&nbsp;.&nbsp;2)&nbsp;(2&nbsp;.&nbsp;4)&nbsp;.&nbsp;2)
<br>
<br>
(subst&nbsp;'a<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(a&nbsp;.&nbsp;b)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'((a&nbsp;.&nbsp;b)&nbsp;(c&nbsp;a&nbsp;.&nbsp;b)&nbsp;.&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(a&nbsp;(c&nbsp;.&nbsp;a)&nbsp;.&nbsp;c)
<br>
<br>
(let&nbsp;([tr&nbsp;'((b&nbsp;c)&nbsp;b&nbsp;a)])<br>

&nbsp;&nbsp;(substq!&nbsp;'a&nbsp;'b&nbsp;tr)<br>

&nbsp;&nbsp;tr)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;((a&nbsp;c)&nbsp;a&nbsp;a)</tt>
<p><a name="./objects:s13"></a><span class=formdef><b>procedure</b>: <tt>(reverse!&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>a list containing the elements of <tt><i>list</i></tt> in reverse order
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>reverse!</tt> destructively reverses <tt><i>list</i></tt>
by reversing its links.
Using <tt>reverse!</tt> in place of <tt>reverse</tt> reduces allocation but is not
necessarily faster than <tt>reverse</tt>.
Its use can easily lead to confusing or incorrect results if used
indiscriminately.

<p>

<p><tt>(reverse!&nbsp;'())&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;()<br>

(reverse!&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(c&nbsp;b&nbsp;a)
<br>
<br>
(let&nbsp;([x&nbsp;'(a&nbsp;b&nbsp;c)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(reverse!&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(a)
<br>
<br>
(let&nbsp;([x&nbsp;'(a&nbsp;b&nbsp;c)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;x&nbsp;(reverse!&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(c&nbsp;b&nbsp;a)</tt>
<p><a name="./objects:s14"></a><span class=formdef><b>procedure</b>: <tt>(append!&nbsp;<i>list</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the concatenation of the input lists
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Like <tt>append</tt>,
<tt>append!</tt> returns a new list consisting of the elements of the first
list followed by the elements of the second list, the elements of the
third list, and so on.
Unlike <tt>append</tt>,
<tt>append!</tt> reuses the pairs in all of the
arguments in forming the new list.
That is, the last cdr of each list argument but the last is changed to
point to the next list argument.
If any argument but the last is the empty list, it is essentially ignored.
The final argument (which need not be a list) is not altered.

<p>
<tt>append!</tt> performs less allocation than <tt>append</tt> but is not
necessarily faster.
Its use can easily lead to confusing or incorrect results if used
indiscriminately.

<p>

<p><tt>(append!&nbsp;'(a&nbsp;b)&nbsp;'(c&nbsp;d))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c&nbsp;d)
<br>
<br>
(let&nbsp;([x&nbsp;'(a&nbsp;b)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(append!&nbsp;x&nbsp;'(c&nbsp;d))<br>

&nbsp;&nbsp;&nbsp;&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c&nbsp;d)</tt>
<p>
<h3><a name="g51"></a><a name="./objects:h3"></a>Section 7.3. Characters</h3>



<p>
<i>Chez&nbsp;Scheme</i> extends the syntax of characters in two ways.
First, a <tt>#\</tt> prefix followed by exactly three octal digits is read
as a character whose numeric code is the octal value of the three digits,
e.g., <tt>#\044</tt> is read as <tt>#\$</tt>.
Second, it recognizes several nonstandard named characters:
<tt>#\rubout</tt> (which is the same as <tt>#\delete</tt>),
<tt>#\bel</tt> (which is the same as <tt>#\alarm</tt>),
<tt>#\vt</tt> (which is the same as <tt>#\vtab</tt>),
<tt>#\nel</tt> (the Unicode NEL character), and
<tt>#\ls</tt> (the Unicode LS character).
The set of nonstandard character names may be changed via the procedure
<a name="./objects:s15"></a><tt>char-name</tt> (page <a href="./io.html#g89">9.14</a>).

<p>
These extensions are disabled in an input stream after <tt>#!r6rs</tt> has
been seen by the reader, unless <tt>#!chezscheme</tt> has been seen more
recently.

<p>
<a name="./objects:s16"></a><span class=formdef><b>procedure</b>: <tt>(char=?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(char&lt;?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(char&gt;?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(char&lt;=?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(char&gt;=?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(char-ci=?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(char-ci&lt;?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(char-ci&gt;?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(char-ci&lt;=?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(char-ci&gt;=?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the relation holds, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These predicates are identical to the Revised<sup>6</sup> Report counterparts,
except they are extended to accept one or more rather than two or more
arguments.
When passed one argument, each of these predicates returns <tt>#t</tt>.

<p>

<p><tt>(char&gt;?&nbsp;#\a)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(char&lt;?&nbsp;#\a)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(char-ci=?&nbsp;#\a)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s17"></a><span class=formdef><b>procedure</b>: <tt>(char-&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the integer difference between <tt><i>char<sub>1</sub></i></tt> and <tt><i>char<sub>2</sub></i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>char-</tt> subtracts the integer value of <tt><i>char<sub>2</sub></i></tt> from the
integer value of <tt><i>char<sub>1</sub></i></tt> and returns the difference.
The following examples assume that the integer representation is the
ASCII code for the character.

<p>

<p><tt>(char-&nbsp;#\f&nbsp;#\e)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1
<br>
<br>
(define&nbsp;digit-value<br>

&nbsp;;&nbsp;returns&nbsp;the&nbsp;digit&nbsp;value&nbsp;of&nbsp;the&nbsp;base-r&nbsp;digit&nbsp;c,&nbsp;or&nbsp;#f&nbsp;if&nbsp;c<br>

&nbsp;;&nbsp;is&nbsp;not&nbsp;a&nbsp;valid&nbsp;digit<br>

&nbsp;&nbsp;(lambda&nbsp;(c&nbsp;r)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([v&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(char&lt;=?&nbsp;#\0&nbsp;c&nbsp;#\9)&nbsp;(char-&nbsp;c&nbsp;#\0)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(char&lt;=?&nbsp;#\A&nbsp;c&nbsp;#\Z)&nbsp;(char-&nbsp;c&nbsp;#\7)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(char&lt;=?&nbsp;#\a&nbsp;c&nbsp;#\z)&nbsp;(char-&nbsp;c&nbsp;#\W)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;36])])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(fx&lt;&nbsp;v&nbsp;r)&nbsp;v))))<br>

(digit-value&nbsp;#\8&nbsp;10)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;8<br>

(digit-value&nbsp;#\z&nbsp;10)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(digit-value&nbsp;#\z&nbsp;36)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;35</tt>
<p><tt>char-</tt> might be defined as follows.

<p>

<p><tt>(define&nbsp;char-<br>

&nbsp;&nbsp;(lambda&nbsp;(c1&nbsp;c2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;(char-&gt;integer&nbsp;c1)&nbsp;(char-&gt;integer&nbsp;c2))))</tt>
<p><a name="./objects:s18"></a><span class=formdef><b>procedure</b>: <tt>(char-grapheme-step&nbsp;<i>char</i>&nbsp;<i>state</i>)</tt></span>
<br>
<b>returns: </b>two values: a boolean indicating whether a cluster terminated and a new state
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>char</i></tt> must be a character, and <tt><i>state</i></tt> must be a fixnum.

<p>
<tt>char-grapheme-step</tt> encodes a state machine for
Unicode's grapheme specification on a sequence of code points.
It accepts a character for the next code point in a sequence, and it
returns two values: whether a (single) grapheme cluster has terminated
since the most recently reported termination (or the start of the
stream), and a new state to be used with
<tt>char-grapheme-step</tt> and the next character.

<p>
A <tt><i>state</i></tt> is represented by a fixnum. A value of <tt>0</tt> for
<tt><i>state</i></tt> represents the initial state or a state where no
characters are pending toward a new boundary. Thus, if a sequence of
characters is exhausted and <tt><i>state</i></tt> is not <tt>0</tt>, then the
end of the stream creates one last grapheme boundary.

<p>
<tt>char-grapheme-step</tt> will produce a result for any
fixnum <tt><i>state</i></tt>, but the meaning of a non-<tt>0</tt> <tt><i>state</i></tt> is
specified only in that providing such a state produced by
<tt>char-grapheme-step</tt> in another call to
<tt>char-grapheme-step</tt> continues detecting
grapheme boundaries in the sequence.

<p>
<a name="./objects:s19"></a><span class=formdef><b>procedure</b>: <tt>(char-grapheme-break-property&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b>a symbol
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>char-grapheme-break-property</tt> reports the grapheme-break
property of <tt><i>char</i></tt>, one of <tt>Other</tt>, <tt>CR</tt>,
<tt>LF</tt>, <tt>Control</tt>, <tt>Extend</tt>, <tt>ZWJ</tt>,
<tt>Regional_Indicator</tt>, <tt>Prepend</tt>, <tt>SpacingMark</tt>,
<tt>L</tt>, <tt>V</tt>, <tt>T</tt>, <tt>LV</tt>, or <tt>LVT</tt>.
This function is used in the implementation of
<tt>char-grapheme-step</tt>.

<p>

<p><tt>(char-grapheme-break-property&nbsp;#\a)&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;Other<br>

(char-grapheme-break-property&nbsp;#\x300)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;Extend</tt>
<p><a name="./objects:s20"></a><span class=formdef><b>procedure</b>: <tt>(char-extended-pictographic?&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b>a boolean
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>char-extended-pictographic?</tt> reports whether <tt><i>char</i></tt> has
the Unicode Extended_Pictographic property. This function is used in
the implementation of <tt>char-grapheme-step</tt>.

<p>

<p><tt>(char-extended-pictographic?&nbsp;#\a)&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(char-extended-pictographic?&nbsp;#\xA9)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p>
<h3><a name="g52"></a><a name="./objects:h4"></a>Section 7.4. Strings</h3>



<p>
<i>Chez&nbsp;Scheme</i> extends the standard string syntax with two character
escapes: <tt>\'</tt>, which produces the single quote character, and
<tt>\<i>nnn</i></tt>, i.e., backslash followed by 3 octal digits,
which produces the character equivalent of the octal value of
the 3 digits.
These extensions are disabled in an input stream after <tt>#!r6rs</tt> has
been seen by the reader, unless <tt>#!chezscheme</tt> has been seen more
recently.

<p>
<a name="./objects:s21"></a><a name="./objects:s22"></a>All strings are mutable by default, including constants.
A program can create immutable strings via
<a name="./objects:s23"></a><tt>string-&gt;immutable-string</tt>
or <a name="./objects:s24"></a><tt>string-append-immutable</tt>.
Any attempt to modify an immutable string causes an exception to be raised.

<p>
The length and indices of a string in <i>Chez&nbsp;Scheme</i> are always fixnums.


<p>
<a name="./objects:s25"></a><span class=formdef><b>procedure</b>: <tt>(string=?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(string&lt;?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(string&gt;?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(string&lt;=?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(string&gt;=?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(string-ci=?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(string-ci&lt;?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(string-ci&gt;?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(string-ci&lt;=?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(string-ci&gt;=?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the relation holds, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These predicates are identical to the Revised<sup>6</sup> Report counterparts,
except they are extended to accept one or more rather than two or more
arguments.
When passed one argument, each of these predicates returns <tt>#t</tt>.

<p>

<p><tt>(string&gt;?&nbsp;"a")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(string&lt;?&nbsp;"a")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(string-ci=?&nbsp;"a")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s26"></a><span class=formdef><b>procedure</b>: <tt>(string-copy!&nbsp;<i>src</i>&nbsp;<i>src-start</i>&nbsp;<i>dst</i>&nbsp;<i>dst-start</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>src</i></tt> and <tt><i>dst</i></tt> must be strings, and <tt><i>dst</i></tt> must be mutable.
<tt><i>src-start</i></tt>, <tt><i>dst-start</i></tt>, and <tt><i>n</i></tt> must be exact nonnegative
integers.
The sum of <tt><i>src-start</i></tt> and <tt><i>n</i></tt> must not exceed the length of <tt><i>src</i></tt>,
and the sum of <tt><i>dst-start</i></tt> and <tt><i>n</i></tt> must not exceed the length of <tt><i>dst</i></tt>.

<p>
<tt>string-copy!</tt> overwrites the <tt><i>n</i></tt> bytes of <tt><i>dst</i></tt>
starting at <tt><i>dst-start</i></tt> with the <tt><i>n</i></tt> bytes of <tt><i>dst</i></tt>
starting at <tt><i>src-start</i></tt>.
This works even if <tt><i>dst</i></tt> is the same string as <tt><i>src</i></tt> and the
source and destination locations overlap.
That is, the destination is filled with the characters that appeared at the
source before the operation began.

<p>

<p><tt>(define&nbsp;s1&nbsp;"to&nbsp;boldly&nbsp;go")<br>

(define&nbsp;s2&nbsp;(make-string&nbsp;10&nbsp;#\-))
<br>
<br>
(string-copy!&nbsp;s1&nbsp;3&nbsp;s2&nbsp;1&nbsp;3)<br>

s2&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"-bol------"<br>

&nbsp;<br>

(string-copy!&nbsp;s1&nbsp;7&nbsp;s2&nbsp;4&nbsp;2)<br>

s2&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"-bolly----"<br>

&nbsp;<br>

(string-copy!&nbsp;s2&nbsp;2&nbsp;s2&nbsp;5&nbsp;4)<br>

s2&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"-bollolly-"</tt>
<p><a name="./objects:s27"></a><span class=formdef><b>procedure</b>: <tt>(substring-fill!&nbsp;<i>string</i>&nbsp;<i>start</i>&nbsp;<i>end</i>&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>string</i></tt> must be mutable.
The characters of <tt><i>string</i></tt> from <tt><i>start</i></tt> (inclusive) to <tt><i>end</i></tt>
(exclusive) are set to <tt><i>char</i></tt>.
<tt><i>start</i></tt> and <tt><i>end</i></tt> must be nonnegative integers; <tt><i>start</i></tt>
must be strictly less than the length of <tt><i>string</i></tt>, while <tt><i>end</i></tt> may
be less than or equal to the length of <tt><i>string</i></tt>.
If <i>end</i> &le; <i>start</i>, the string is left unchanged.

<p>

<p><tt>(let&nbsp;([str&nbsp;(string-copy&nbsp;"a&nbsp;tpyo&nbsp;typo")])<br>

&nbsp;&nbsp;(substring-fill!&nbsp;str&nbsp;2&nbsp;6&nbsp;#\X)<br>

&nbsp;&nbsp;str)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"a&nbsp;XXXX&nbsp;typo"</tt>
<p><a name="./objects:s28"></a><span class=formdef><b>procedure</b>: <tt>(string-truncate!&nbsp;<i>string</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b><tt><i>string</i></tt> or the empty string
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>string</i></tt> must be mutable.
<tt><i>n</i></tt> must be an exact nonnegative fixnum not greater than the length of
<tt><i>string</i></tt>.
If <tt><i>n</i></tt> is zero, <tt>string-truncate!</tt> returns the empty string.
Otherwise, <tt><i>string-truncate!</i></tt> destructively truncates <tt><i>string</i></tt> to
its first <tt><i>n</i></tt> characters and returns <tt><i>string</i></tt>.

<p>

<p><tt>(define&nbsp;s&nbsp;(make-string&nbsp;7&nbsp;#\$))<br>

(string-truncate!&nbsp;s&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;""<br>

s&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"$$$$$$$"<br>

(string-truncate!&nbsp;s&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"$$$"<br>

s&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"$$$"</tt>
<p><a name="./objects:s29"></a><span class=formdef><b>procedure</b>: <tt>(mutable-string?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a mutable string, <tt>#f</tt> otherwise
<br><span class=formdef><b>procedure</b>: <tt>(immutable-string?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an immutable string, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(mutable-string?&nbsp;(string&nbsp;#\a&nbsp;#\b&nbsp;#\c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(mutable-string?&nbsp;(string-&gt;immutable-string&nbsp;"abc"))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(immutable-string?&nbsp;(string&nbsp;#\a&nbsp;#\b&nbsp;#\c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(immutable-string?&nbsp;(string-&gt;immutable-string&nbsp;"abc"))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(immutable-string?&nbsp;(cons&nbsp;3&nbsp;4))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s30"></a><span class=formdef><b>procedure</b>: <tt>(string-&gt;immutable-string&nbsp;<i>string</i>)</tt></span>
<br>
<b>returns: </b>an immutable string equal to <tt><i>string</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./objects:s31"></a><a name="./objects:s32"></a>The result is <tt><i>string</i></tt> itself if <tt><i>string</i></tt>
is immutable; otherwise, the result is an immutable string with the same content as <tt><i>string</i></tt>.

<p>

<p><tt>(define&nbsp;s&nbsp;(string-&gt;immutable-string&nbsp;(string&nbsp;#\x&nbsp;#\y&nbsp;#\z)))<br>

(string-set!&nbsp;s&nbsp;0&nbsp;#\a)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;not&nbsp;mutable</i></tt>
<p><a name="./objects:s33"></a><span class=formdef><b>procedure</b>: <tt>(string-append-immutable&nbsp;<i>string</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>an immutable string that appends the argument <tt><i>string</i></tt>s
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Like <tt>string-append</tt>, but produces an immutable string.

<p>
<a name="./objects:s34"></a><span class=formdef><b>procedure</b>: <tt>(string-grapheme-span&nbsp;<i>string</i>&nbsp;<i>start</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(string-grapheme-span&nbsp;<i>string</i>&nbsp;<i>start</i>&nbsp;<i>end</i>)</tt></span>
<br>
<b>returns: </b>the number of characters in a grapheme cluster at the given <tt><i>start</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>start</i></tt> and <tt><i>end</i></tt> must indicate a valid range in the string as
for <tt>substring</tt>, where the length of the string is used if
<tt><i>end</i></tt> is not supplied.

<p>
The result is the number of characters (i.e., code points) in the
string that form a Unicode grapheme cluster starting at <tt><i>start</i></tt>,
assuming that <tt><i>start</i></tt> is the start of a grapheme cluster and
extending no further than the character before <tt><i>end</i></tt>. The result
is <tt>0</tt> if <tt><i>start</i></tt> equals <tt><i>end</i></tt>.

<p>

<p><tt>(string-grapheme-span&nbsp;(string&nbsp;#\a)&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(string-grapheme-span&nbsp;(string&nbsp;#\a&nbsp;#\x300)&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2<br>

(string-grapheme-span&nbsp;(string&nbsp;#\a&nbsp;#\x300&nbsp;#\a)&nbsp;0)&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2<br>

(string-grapheme-span&nbsp;(string&nbsp;#\a&nbsp;#\x300&nbsp;#\a)&nbsp;0&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1</tt>
<p><a name="./objects:s35"></a><span class=formdef><b>procedure</b>: <tt>(string-grapheme-count&nbsp;<i>string</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(string-grapheme-count&nbsp;<i>string</i>&nbsp;<i>start</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(string-grapheme-count&nbsp;<i>string</i>&nbsp;<i>start</i>&nbsp;<i>end</i>)</tt></span>
<br>
<b>returns: </b>the number of Unicode grapheme clusters (see below)
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>start</i></tt> and <tt><i>end</i></tt> must indicate a valid range in the string as
for <tt>substring</tt>, where <tt>0</tt> is used if <tt><i>start</i></tt> is not
provided, and the length of the string is used if <tt><i>end</i></tt> is not
supplied.

<p>
The result is the number of Unicode grapheme clusters in the substring
of <tt><i>string</i></tt> selected by <tt><i>start</i></tt> and <tt><i>end</i></tt>.

<p>

<p><tt>(string-grapheme-count&nbsp;(string&nbsp;#\a)&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(string-grapheme-count&nbsp;(string&nbsp;#\a&nbsp;#\x300)&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(string-grapheme-count&nbsp;(string&nbsp;#\a&nbsp;#\x300&nbsp;#\a)&nbsp;0)&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2<br>

(string-grapheme-count&nbsp;(string&nbsp;#\a&nbsp;#\x300&nbsp;#\a)&nbsp;0&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1</tt>
<p>
<h3><a name="g53"></a><a name="./objects:h5"></a>Section 7.5. Vectors</h3>



<p>
<a name="./objects:s36"></a><a name="./objects:s37"></a><i>Chez&nbsp;Scheme</i> extends the syntax of vectors to allow the length of the
vector to be specified between the <tt>#</tt> and open parenthesis, e.g.,
<tt>#3(a&nbsp;b&nbsp;c)</tt>.
If fewer elements are supplied in the syntax than the specified length,
each element after the last printed element is the same as the last
printed element.
This extension is disabled in an input stream after <tt>#!r6rs</tt> has
been seen by the reader, unless <tt>#!chezscheme</tt> has been seen more
recently.

<p>
The length and indices of a vector in <i>Chez&nbsp;Scheme</i> are always fixnums.

<p>
<a name="./objects:s38"></a><a name="./objects:s39"></a>All vectors are mutable by default, including constants.
A program can create immutable vectors via
<a name="./objects:s40"></a><tt>vector-&gt;immutable-vector</tt>,
<a name="./objects:s41"></a><tt>immutable-vector</tt>,
and other functions.
Any attempt to modify an immutable vector causes an exception to be raised.

<p>
<a name="./objects:s42"></a><span class=formdef><b>procedure</b>: <tt>(vector-copy&nbsp;<i>vector</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(vector-copy&nbsp;<i>vector</i>&nbsp;<i>start</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>a new vector
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>vector</i></tt> must be a vector.
<tt><i>start</i></tt> and <tt><i>n</i></tt> must be exact nonnegative integers.
The sum of <tt><i>start</i></tt> and <tt><i>n</i></tt> must not exceed the length
of <tt><i>vector</i></tt>. When <tt><i>start</i></tt>
and <tt><i>n</i></tt> are not supplied, <tt>0</tt> and
<tt>(vector-length&nbsp;<i>vector</i>)</tt> are used.

<p>
<tt>vector-copy</tt> creates a new vector
that contains <tt><i>n</i></tt> consecutive elements of <tt><i>vector</i></tt>
from position <tt><i>start</i></tt>. When <tt><i>start</i></tt> and <tt><i>n</i></tt> are not
supplied, the result is a copy of <tt><i>vector</i></tt>. The vector elements
themselves are not copied.

<p>

<p><tt>(vector-copy&nbsp;'#(a&nbsp;b&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#(a&nbsp;b&nbsp;c)<br>

(vector-copy&nbsp;'#(a&nbsp;b&nbsp;c&nbsp;d)&nbsp;1&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#(b&nbsp;c)
<br>
<br>
(let&nbsp;([v&nbsp;'#(a&nbsp;b&nbsp;c)])<br>

&nbsp;&nbsp;(eq?&nbsp;v&nbsp;(vector-copy&nbsp;v)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s43"></a><span class=formdef><b>procedure</b>: <tt>(vector-append&nbsp;<i>vector</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>a new vector
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>vector-append</tt> creates a new vector whose content is the
concatenation of the given <tt><i>vector</i></tt>s in order.

<p>

<p><tt>(vector-append&nbsp;'#(a&nbsp;b&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#(a&nbsp;b&nbsp;c)<br>

(vector-append&nbsp;'#(a&nbsp;b&nbsp;c)&nbsp;'#(d&nbsp;e)&nbsp;'#(f))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e&nbsp;f)<br>

(vector-append)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#()</tt>
<p><a name="./objects:s44"></a><span class=formdef><b>procedure</b>: <tt>(vector-set/copy&nbsp;<i>vector</i>&nbsp;<i>n</i>&nbsp;<i>val</i>)</tt></span>
<br>
<b>returns: </b>a new vector with <tt><i>val</i></tt> at index <tt><i>n</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>vector</i></tt> must be a vector.
<tt><i>n</i></tt> must be exact nonnegative integer that is a valid element index
for the vector.

<p>
<tt>vector-set/copy</tt> creates a new vector whose content is the
same as <tt><i>vector</i></tt>, except that the element at index <tt><i>n</i></tt>
is changed to <tt><i>val</i></tt>.

<p>

<p><tt>(vector-set/copy&nbsp;'#(a&nbsp;b&nbsp;c)&nbsp;0&nbsp;'x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#(x&nbsp;b&nbsp;c)<br>

(vector-set/copy&nbsp;'#(a&nbsp;b&nbsp;c)&nbsp;2&nbsp;'x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#(a&nbsp;b&nbsp;x)</tt>
<p><a name="./objects:s45"></a><span class=formdef><b>procedure</b>: <tt>(vector-set-fixnum!&nbsp;<i>vector</i>&nbsp;<i>n</i>&nbsp;<i>fixnum</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>vector</i></tt> must be mutable.
<tt>vector-set-fixnum!</tt> changes the <tt><i>n</i></tt>th element of <tt><i>vector</i></tt> to <tt><i>fixnum</i></tt>.
<tt><i>n</i></tt> must be an exact nonnegative integer strictly less than
the length of <tt><i>vector</i></tt>.

<p>
It is faster to store a fixnum than an arbitrary value,
since for arbitrary values, the system has to record potential assignments from older to
younger objects to support generational garbage collection.
Care must be taken to ensure that the argument is indeed a fixnum, however;
otherwise, the collector may not properly track the assignment.
The primitive performs a fixnum check on the argument except at
optimization level&nbsp;3.

<p>
See also the description of fixnum-only vectors (fxvectors) below.

<p>

<p><tt>(let&nbsp;([v&nbsp;(vector&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)])<br>

&nbsp;&nbsp;(vector-set-fixnum!&nbsp;v&nbsp;2&nbsp;73)<br>

&nbsp;&nbsp;v)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#(1&nbsp;2&nbsp;73&nbsp;4&nbsp;5)</tt>
<p><a name="./objects:s46"></a><span class=formdef><b>procedure</b>: <tt>(vector-cas!&nbsp;<i>vector</i>&nbsp;<i>n</i>&nbsp;<i>old-obj</i>&nbsp;<i>new-obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>vector</i></tt> is changed, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>vector</i></tt> must be mutable.
<tt>vector-cas!</tt> atomically changes the <tt><i>n</i></tt>th element of <tt><i>vector</i></tt> to <tt><i>new-obj</i></tt>
if the replaced <tt><i>n</i></tt>th element is <tt>eq?</tt> to <tt><i>old-obj</i></tt>.
If the <tt><i>n</i></tt>th element of <tt><i>vector</i></tt> that would be replaced
is not <tt>eq?</tt> to <tt><i>old-obj</i></tt>, then
<tt><i>vector</i></tt> is unchanged.

<p>
On an architecture with a weak memory model, <tt>vector-cas!</tt> can
spuriously fail, leaving <tt><i>vector</i></tt> unchanged and returning
<tt>#f</tt> even if the current value of element <tt><i>n</i></tt> is
<tt><i>old-obj</i></tt>. On success, no memory ordering is implied, which means
that <tt>memory-order-acquire</tt> and/or <tt>memory-order-release</tt>
may be needed to complete an intended synchronization.

<p>

<p><tt>(define&nbsp;v&nbsp;(vector&nbsp;'old0&nbsp;'old1&nbsp;'old2))<br>

(vector-cas!&nbsp;v&nbsp;1&nbsp;'old1&nbsp;'new1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t,&nbsp;assuming&nbsp;no&nbsp;spurious&nbsp;failure<br>

(vector-ref&nbsp;v&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;'new1<br>

(vector-cas!&nbsp;v&nbsp;2&nbsp;'old1&nbsp;'new2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(vector-ref&nbsp;v&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;'old2</tt>
<p><a name="./objects:s47"></a><span class=formdef><b>procedure</b>: <tt>(mutable-vector?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a mutable vector, <tt>#f</tt> otherwise
<br><span class=formdef><b>procedure</b>: <tt>(immutable-vector?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an immutable vector, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(mutable-vector?&nbsp;(vector&nbsp;1&nbsp;2&nbsp;3))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(mutable-vector?&nbsp;(vector-&gt;immutable-vector&nbsp;(vector&nbsp;1&nbsp;2&nbsp;3)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(immutable-vector?&nbsp;(vector&nbsp;1&nbsp;2&nbsp;3))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(immutable-vector?&nbsp;(vector-&gt;immutable-vector&nbsp;(vector&nbsp;1&nbsp;2&nbsp;3)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(immutable-vector?&nbsp;(cons&nbsp;3&nbsp;4))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s48"></a><span class=formdef><b>procedure</b>: <tt>(vector-&gt;immutable-vector&nbsp;<i>vector</i>)</tt></span>
<br>
<b>returns: </b>an immutable vector equal to <tt><i>vector</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./objects:s49"></a><a name="./objects:s50"></a>The result is <tt><i>vector</i></tt> itself if <tt><i>vector</i></tt>
is immutable; otherwise, the result is an immutable vector with the same content as <tt><i>vector</i></tt>.

<p>

<p><tt>(define&nbsp;v&nbsp;(vector-&gt;immutable-vector&nbsp;(vector&nbsp;1&nbsp;2&nbsp;3)))<br>

(vector-set!&nbsp;v&nbsp;0&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;not&nbsp;mutable</i></tt>
<p><a name="./objects:s51"></a><span class=formdef><b>procedure</b>: <tt>(immutable-vector&nbsp;<i>obj</i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(immutable-vector-copy&nbsp;<i>vector</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(immutable-vector-copy&nbsp;<i>vector</i>&nbsp;<i>start</i>&nbsp;<i>n</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(immutable-vector-append&nbsp;<i>vector</i>&nbsp;...)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(vector-set/copy&nbsp;<i>vector</i>&nbsp;<i>n</i>&nbsp;<i>val</i>)</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Like <tt>vector</tt>, <tt>vector-copy</tt>,  <tt>vector-append</tt>, and
<tt>vector-set/copy</tt>, but these procedures return an immutable vector instead of a mutable
one, and they may return an existing object instead of allocating a new one.
In the case of <tt>immutable-vector-copy</tt>, <tt>immutable-vector-append</tt>, or
<tt>immutable-vector-set/copy</tt>, an argument vector can be mutable or immutable.

<p>
<a name="./objects:s52"></a><span class=formdef><b>thread parameter</b>: <tt>self-evaluating-vectors</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The default value of this parameter is <tt>#f</tt>, meaning that vector literals must be quoted, as
required by the Revised<sup>6</sup> Report.
Setting <tt>self-evaluating-vectors</tt> to a true value may be useful to provide compatibility with
R<sup>7</sup>RS, as the latter states that vectors are self-evaluating.

<p>

<p><tt>#(a&nbsp;b&nbsp;c)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;invalid&nbsp;syntax</i>
<br>
<br>
(self-evaluating-vectors&nbsp;#t)<br>

#(a&nbsp;b&nbsp;c)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#(a&nbsp;b&nbsp;c)</tt>
<p>
<h3><a name="g54"></a><a name="./objects:h6"></a>Section 7.6. Fixnum-Only Vectors<a name="SECTFXVECTORS"></a></h3>



<p>
<a name="./objects:s53"></a>Fixnum-only vectors, or "fxvectors," are like vectors but contain
only fixnums.
<a name="./objects:s54"></a><a name="./objects:s55"></a>Fxvectors are written with the <tt>#vfx</tt> prefix in place of the
<tt>#</tt> prefix for vectors, e.g., <tt>#vfx(1&nbsp;2&nbsp;3)</tt> or
<tt>#10vfx(2)</tt>.
The fxvector syntax is disabled in an input stream after <tt>#!r6rs</tt>
has been seen by the reader, unless <tt>#!chezscheme</tt> has been seen
more recently.

<p>
The length and indices of an fxvector are always fixnums.

<p>
Updating an fxvector is generally less expensive than updating a vector,
since for vectors, the system records potential assignments from older to
younger objects to support generational garbage collection.
The storage management system also takes advantage of the fact that
fxvectors contain no pointers to place them in an area of memory that
does not have to be traced during collection.

<p>
See also <tt>vector-set-fixnum!</tt> above.

<p>
<a name="./objects:s56"></a><span class=formdef><b>procedure</b>: <tt>(fxvector?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an fxvector, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(fxvector?&nbsp;#vfx())&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxvector?&nbsp;#vfx(1&nbsp;2&nbsp;3))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxvector?&nbsp;(fxvector&nbsp;1&nbsp;2&nbsp;3))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxvector?&nbsp;'#(a&nbsp;b&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(fxvector?&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(fxvector?&nbsp;"abc")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s57"></a><span class=formdef><b>procedure</b>: <tt>(fxvector&nbsp;<i>fixnum</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>an fxvector of the fixnums <tt><i>fixnum</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(fxvector)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfx()<br>

(fxvector&nbsp;1&nbsp;3&nbsp;5)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfx(1&nbsp;3&nbsp;5)</tt>
<p><a name="./objects:s58"></a><span class=formdef><b>procedure</b>: <tt>(make-fxvector&nbsp;<i>n</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-fxvector&nbsp;<i>n</i>&nbsp;<i>fixnum</i>)</tt></span>
<br>
<b>returns: </b>an fxvector of length <tt><i>n</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>n</i></tt> must be a fixnum.
If <tt><i>fixnum</i></tt> is supplied, each element of the fxvector is initialized
to <tt><i>fixnum</i></tt>; otherwise, the elements are unspecified.

<p>

<p><tt>(make-fxvector&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfx()<br>

(make-fxvector&nbsp;0&nbsp;7)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfx()<br>

(make-fxvector&nbsp;5&nbsp;7)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfx(7&nbsp;7&nbsp;7&nbsp;7&nbsp;7)</tt>
<p><a name="./objects:s59"></a><span class=formdef><b>procedure</b>: <tt>(fxvector-length&nbsp;<i>fxvector</i>)</tt></span>
<br>
<b>returns: </b>the number of elements in <tt><i>fxvector</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>(fxvector-length&nbsp;#vfx())&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(fxvector-length&nbsp;#vfx(1&nbsp;2&nbsp;3))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(fxvector-length&nbsp;#10vfx(1&nbsp;2&nbsp;3))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;10<br>

(fxvector-length&nbsp;(fxvector&nbsp;1&nbsp;2&nbsp;3&nbsp;4))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4<br>

(fxvector-length&nbsp;(make-fxvector&nbsp;300))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;300</tt>
<p><a name="./objects:s60"></a><span class=formdef><b>procedure</b>: <tt>(fxvector-ref&nbsp;<i>fxvector</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the <tt><i>n</i></tt>th element (zero-based) of <tt><i>fxvector</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>n</i></tt> must be a nonnegative fixnum strictly less than
the length of <tt><i>fxvector</i></tt>.

<p>

<p><tt>(fxvector-ref&nbsp;#vfx(-1&nbsp;2&nbsp;4&nbsp;7)&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1<br>

(fxvector-ref&nbsp;#vfx(-1&nbsp;2&nbsp;4&nbsp;7)&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2<br>

(fxvector-ref&nbsp;#vfx(-1&nbsp;2&nbsp;4&nbsp;7)&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;7</tt>
<p><a name="./objects:s61"></a><span class=formdef><b>procedure</b>: <tt>(fxvector-set!&nbsp;<i>fxvector</i>&nbsp;<i>n</i>&nbsp;<i>fixnum</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>n</i></tt> must be a nonnegative fixnum strictly less than
the length of <tt><i>fxvector</i></tt>.
<tt>fxvector-set!</tt> changes the <tt><i>n</i></tt>th element of <tt><i>fxvector</i></tt> to <tt><i>fixnum</i></tt>.

<p>

<p><tt>(let&nbsp;([v&nbsp;(fxvector&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)])<br>

&nbsp;&nbsp;(fxvector-set!&nbsp;v&nbsp;2&nbsp;(fx-&nbsp;(fxvector-ref&nbsp;v&nbsp;2)))<br>

&nbsp;&nbsp;v)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfx(1&nbsp;2&nbsp;-3&nbsp;4&nbsp;5)</tt>
<p><a name="./objects:s62"></a><span class=formdef><b>procedure</b>: <tt>(fxvector-fill!&nbsp;<i>fxvector</i>&nbsp;<i>fixnum</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>fxvector-fill!</tt> replaces each element of <tt><i>fxvector</i></tt> with <tt><i>fixnum</i></tt>.

<p>

<p><tt>(let&nbsp;([v&nbsp;(fxvector&nbsp;1&nbsp;2&nbsp;3)])<br>

&nbsp;&nbsp;(fxvector-fill!&nbsp;v&nbsp;0)<br>

&nbsp;&nbsp;v)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfx(0&nbsp;0&nbsp;0)</tt>
<p><a name="./objects:s63"></a><span class=formdef><b>procedure</b>: <tt>(fxvector-&gt;list&nbsp;<i>fxvector</i>)</tt></span>
<br>
<b>returns: </b>a list of the elements of <tt><i>fxvector</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>(fxvector-&gt;list&nbsp;(fxvector))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;()<br>

(fxvector-&gt;list&nbsp;#vfx(7&nbsp;5&nbsp;2))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(7&nbsp;5&nbsp;2)
<br>
<br>
(let&nbsp;([v&nbsp;#vfx(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)])<br>

&nbsp;&nbsp;(apply&nbsp;fx*&nbsp;(fxvector-&gt;list&nbsp;v)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;120</tt>
<p><a name="./objects:s64"></a><span class=formdef><b>procedure</b>: <tt>(list-&gt;fxvector&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>an fxvector of the elements of <tt><i>list</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>list</i></tt> must consist entirely of fixnums.

<p>

<p><tt>(list-&gt;fxvector&nbsp;'())&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfx()<br>

(list-&gt;fxvector&nbsp;'(3&nbsp;5&nbsp;7))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfx(3&nbsp;5&nbsp;7)
<br>
<br>
(let&nbsp;([v&nbsp;#vfx(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)])<br>

&nbsp;&nbsp;(let&nbsp;([ls&nbsp;(fxvector-&gt;list&nbsp;v)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list-&gt;fxvector&nbsp;(map&nbsp;fx*&nbsp;ls&nbsp;ls))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfx(1&nbsp;4&nbsp;9&nbsp;16&nbsp;25)</tt>
<p><a name="./objects:s65"></a><span class=formdef><b>procedure</b>: <tt>(fxvector-copy&nbsp;<i>fxvector</i>)</tt></span>
<br>
<b>returns: </b>a copy of <tt><i>fxvector</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>fxvector-copy</tt> creates a new fxvector with the same length and contents
as <tt><i>fxvector</i></tt>.

<p>

<p><tt>(fxvector-copy&nbsp;#vfx(3&nbsp;4&nbsp;5))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfx(3&nbsp;4&nbsp;5)
<br>
<br>
(let&nbsp;([v&nbsp;#vfx(3&nbsp;4&nbsp;5)])<br>

&nbsp;&nbsp;(eq?&nbsp;v&nbsp;(fxvector-copy&nbsp;v)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>    

<h3><a name="g55"></a><a name="./objects:h7"></a>Section 7.7. Flonum-Only Vectors<a name="SECTFLVECTORS"></a></h3>



<p>
<a name="./objects:s66"></a>Flonum-only vectors, or "flvectors," are like vectors but contain
only flonums.
<a name="./objects:s67"></a><a name="./objects:s68"></a>Flvectors are written with the <tt>#vfl</tt> prefix in place of the
<tt>#</tt> prefix for vectors, e.g., <tt>#vfl(1.0&nbsp;2.0&nbsp;3.0)</tt> or
<tt>#10vfl(2.0)</tt>.
The flvector syntax is disabled in an input stream after <tt>#!r6rs</tt>
has been seen by the reader, unless <tt>#!chezscheme</tt> has been seen
more recently.

<p>
The length and indices of an flvector are always fixnums.

<p>
Updating an flvector is generally less expensive than updating a vector,
since for vectors, the system records potential assignments from older to
younger objects to support generational garbage collection.
An flvector stores a flonum's representation directly, instead of a reference to a
flonum, so flonum identity is fresh when it is extracted from an flvector.
The storage management system also takes advantage of the fact that
flvectors contain no pointers to place them in an area of memory that
does not have to be traced during collection.

<p>
<a name="./objects:s69"></a><span class=formdef><b>procedure</b>: <tt>(flvector?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an flvector, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(flvector?&nbsp;#vfl())&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(flvector?&nbsp;#vfl(1.0&nbsp;2.0&nbsp;3.0))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(flvector?&nbsp;(flvector&nbsp;1.0&nbsp;2.0&nbsp;3.0))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(flvector?&nbsp;'#(a&nbsp;b&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(flvector?&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(flvector?&nbsp;"abc")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s70"></a><span class=formdef><b>procedure</b>: <tt>(flvector&nbsp;<i>flonum</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>an flvector of the flonums <tt><i>flonum</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(flvector)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfl()<br>

(flvector&nbsp;1.0&nbsp;3.0&nbsp;5.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfl(1.0&nbsp;3.0&nbsp;5.0)</tt>
<p><a name="./objects:s71"></a><span class=formdef><b>procedure</b>: <tt>(make-flvector&nbsp;<i>n</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-flvector&nbsp;<i>n</i>&nbsp;<i>flonum</i>)</tt></span>
<br>
<b>returns: </b>an flvector of length <tt><i>n</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>n</i></tt> must be a fixnum.
If <tt><i>flonum</i></tt> is supplied, each element of the flvector is initialized
to <tt><i>flonum</i></tt>; otherwise, the elements are unspecified.

<p>

<p><tt>(make-flvector&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfl()<br>

(make-flvector&nbsp;0&nbsp;7.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfl()<br>

(make-flvector&nbsp;5&nbsp;7.0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfl(7.0&nbsp;7.0&nbsp;7.0&nbsp;7.0&nbsp;7.0)</tt>
<p><a name="./objects:s72"></a><span class=formdef><b>procedure</b>: <tt>(flvector-length&nbsp;<i>flvector</i>)</tt></span>
<br>
<b>returns: </b>the number of elements in <tt><i>flvector</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>(flvector-length&nbsp;#vfl())&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(flvector-length&nbsp;#vfl(1.0&nbsp;2.0&nbsp;3.0))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(flvector-length&nbsp;#10vfl(1.0&nbsp;2.0&nbsp;3.0))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;10<br>

(flvector-length&nbsp;(flvector&nbsp;1.0&nbsp;2.0&nbsp;3.0&nbsp;4.0))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4<br>

(flvector-length&nbsp;(make-flvector&nbsp;300))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;300</tt>
<p><a name="./objects:s73"></a><span class=formdef><b>procedure</b>: <tt>(flvector-ref&nbsp;<i>flvector</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the <tt><i>n</i></tt>th element (zero-based) of <tt><i>flvector</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>n</i></tt> must be a nonnegative fixnum strictly less than
the length of <tt><i>flvector</i></tt>.

<p>

<p><tt>(flvector-ref&nbsp;#vfl(-1.0&nbsp;2.0&nbsp;4.0&nbsp;7.0)&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1.0<br>

(flvector-ref&nbsp;#vfl(-1.0&nbsp;2.0&nbsp;4.0&nbsp;7.0)&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2.0<br>

(flvector-ref&nbsp;#vfl(-1.0&nbsp;2.0&nbsp;4.0&nbsp;7.0)&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;7.0</tt>
<p><a name="./objects:s74"></a><span class=formdef><b>procedure</b>: <tt>(flvector-set!&nbsp;<i>flvector</i>&nbsp;<i>n</i>&nbsp;<i>flonum</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>n</i></tt> must be a nonnegative fixnum strictly less than
the length of <tt><i>flvector</i></tt>.
<tt>flvector-set!</tt> changes the <tt><i>n</i></tt>th element of <tt><i>flvector</i></tt> to <tt><i>flonum</i></tt>.

<p>

<p><tt>(let&nbsp;([v&nbsp;(flvector&nbsp;1.0&nbsp;2.0&nbsp;3.0&nbsp;4.0&nbsp;5.0)])<br>

&nbsp;&nbsp;(flvector-set!&nbsp;v&nbsp;2&nbsp;(fx-&nbsp;(flvector-ref&nbsp;v&nbsp;2)))<br>

&nbsp;&nbsp;v)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfl(1.0&nbsp;2.0&nbsp;-3.0&nbsp;4.0&nbsp;5.0)</tt>
<p><a name="./objects:s75"></a><span class=formdef><b>procedure</b>: <tt>(flvector-fill!&nbsp;<i>flvector</i>&nbsp;<i>flonum</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>flvector-fill!</tt> replaces each element of <tt><i>flvector</i></tt> with <tt><i>flonum</i></tt>.

<p>

<p><tt>(let&nbsp;([v&nbsp;(flvector&nbsp;1.0&nbsp;2.0&nbsp;3.0)])<br>

&nbsp;&nbsp;(flvector-fill!&nbsp;v&nbsp;0.0)<br>

&nbsp;&nbsp;v)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfl(0.0&nbsp;0.0&nbsp;0.0)</tt>
<p><a name="./objects:s76"></a><span class=formdef><b>procedure</b>: <tt>(flvector-&gt;list&nbsp;<i>flvector</i>)</tt></span>
<br>
<b>returns: </b>a list of the elements of <tt><i>flvector</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>(flvector-&gt;list&nbsp;(flvector))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;()<br>

(flvector-&gt;list&nbsp;#vfl(7.0&nbsp;5.0&nbsp;2.0))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(7.0&nbsp;5.0&nbsp;2.0)
<br>
<br>
(let&nbsp;([v&nbsp;#vfl(1.0&nbsp;2.0&nbsp;3.0&nbsp;4.0&nbsp;5.0)])<br>

&nbsp;&nbsp;(apply&nbsp;fl*&nbsp;(flvector-&gt;list&nbsp;v)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;120.0</tt>
<p><a name="./objects:s77"></a><span class=formdef><b>procedure</b>: <tt>(list-&gt;flvector&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>an flvector of the elements of <tt><i>list</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>list</i></tt> must consist entirely of flonums.

<p>

<p><tt>(list-&gt;flvector&nbsp;'())&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfl()<br>

(list-&gt;flvector&nbsp;'(3.0&nbsp;5.0&nbsp;7.0))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfl(3.0&nbsp;5.0&nbsp;7.0)
<br>
<br>
(let&nbsp;([v&nbsp;#vfl(1.0&nbsp;2.0&nbsp;3.0&nbsp;4.0&nbsp;5.0)])<br>

&nbsp;&nbsp;(let&nbsp;([ls&nbsp;(flvector-&gt;list&nbsp;v)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list-&gt;flvector&nbsp;(map&nbsp;fx*&nbsp;ls&nbsp;ls))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfl(1.0&nbsp;4.0&nbsp;9.0&nbsp;16.0&nbsp;25.0)</tt>
<p><a name="./objects:s78"></a><span class=formdef><b>procedure</b>: <tt>(flvector-copy&nbsp;<i>flvector</i>)</tt></span>
<br>
<b>returns: </b>a copy of <tt><i>flvector</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>flvector-copy</tt> creates a new flvector with the same length and contents
as <tt><i>flvector</i></tt>.

<p>

<p><tt>(flvector-copy&nbsp;#vfl(3.0&nbsp;4.0&nbsp;5.0))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vfl(3.0&nbsp;4.0&nbsp;5.0)
<br>
<br>
(let&nbsp;([v&nbsp;#vfl(3.0&nbsp;4.0&nbsp;5.0)])<br>

&nbsp;&nbsp;(eq?&nbsp;v&nbsp;(flvector-copy&nbsp;v)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>    

<h3><a name="g56"></a><a name="./objects:h8"></a>Section 7.8. Bytevectors<a name="SECTBYTEVECTORS"></a></h3>



<p>
As with vectors, <i>Chez&nbsp;Scheme</i> extends the syntax of bytevectors to allow
the length of the vector to be specified between the <tt>#</tt> and open
parenthesis, e.g., <tt>#3vu8(1&nbsp;105&nbsp;73)</tt>.
If fewer elements are supplied in the syntax than the specified length,
each element after the last printed element is the same as the last
printed element.
This extension is disabled in an input stream after <tt>#!r6rs</tt> has
been seen by the reader, unless <tt>#!chezscheme</tt> has been seen more
recently.

<p>
<i>Chez&nbsp;Scheme</i> also extends the set of bytevector primitives, including
primitives for loading and storing 3, 5, 6, and 7-byte quantities.

<p>
The length and indices of a bytevector in <i>Chez&nbsp;Scheme</i> are always fixnums.

<p>
<a name="./objects:s79"></a><a name="./objects:s80"></a>All bytevectors are mutable by default, including constants.
A program can create immutable bytevectors via
<a name="./objects:s81"></a><tt>bytevector-&gt;immutable-bytevector</tt>.
Any attempt to modify an immutable bytevector causes an exception to be raised.

<p>
<a name="./objects:s82"></a><span class=formdef><b>procedure</b>: <tt>(bytevector&nbsp;<i>fill</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>a new bytevector containing <tt><i>fill</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Each <tt><i>fill</i></tt> value must be an exact integer representing a signed or
unsigned 8-bit value, i.e.,
a value in the range -128 to 255 inclusive.
A negative fill value is treated as its two's complement equivalent.

<p>

<p><tt>(bytevector)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vu8()<br>

(bytevector&nbsp;1&nbsp;3&nbsp;5)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vu8(1&nbsp;3&nbsp;5)<br>

(bytevector&nbsp;-1&nbsp;-3&nbsp;-5)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vu8(255&nbsp;253&nbsp;251)</tt>
<p><a name="./objects:s83"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-&gt;s8-list&nbsp;<i>bytevector</i>)</tt></span>
<br>
<b>returns: </b>a new list of the 8-bit signed elements of <tt><i>bytevector</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The values in the returned list are exact eight-bit signed integers,
i.e., values in the range -128 to 127 inclusive.
<tt>bytevector-&gt;s8-list</tt> is similar to the Revised<sup>6</sup> Report 
<tt>bytevector-&gt;u8-list</tt> except the values in the returned list
are signed rather than unsigned.

<p>

<p><tt>(bytevector-&gt;s8-list&nbsp;(make-bytevector&nbsp;0))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;()<br>

(bytevector-&gt;s8-list&nbsp;#vu8(1&nbsp;127&nbsp;128&nbsp;255))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(1&nbsp;127&nbsp;-128&nbsp;-1)
<br>
<br>
(let&nbsp;([v&nbsp;#vu8(1&nbsp;2&nbsp;3&nbsp;255)])<br>

&nbsp;&nbsp;(apply&nbsp;*&nbsp;(bytevector-&gt;s8-list&nbsp;v)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-6</tt>
<p><a name="./objects:s84"></a><span class=formdef><b>procedure</b>: <tt>(s8-list-&gt;bytevector&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>a new bytevector of the elements of <tt><i>list</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>list</i></tt> must consist entirely of exact eight-bit signed integers, i.e.,
values in the range -128 to 127 inclusive.
<tt>s8-list-&gt;bytevector</tt> is similar to the Revised<sup>6</sup> Report 
procedure
<tt>u8-list-&gt;bytevector</tt>, except the elements of the input list
are signed rather than unsigned.

<p>

<p><tt>(s8-list-&gt;bytevector&nbsp;'())&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vu8()<br>

(s8-list-&gt;bytevector&nbsp;'(1&nbsp;127&nbsp;-128&nbsp;-1))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vu8(1&nbsp;127&nbsp;128&nbsp;255)
<br>
<br>
(let&nbsp;([v&nbsp;#vu8(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)])<br>

&nbsp;&nbsp;(let&nbsp;([ls&nbsp;(bytevector-&gt;s8-list&nbsp;v)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(s8-list-&gt;bytevector&nbsp;(map&nbsp;-&nbsp;ls))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vu8(255&nbsp;254&nbsp;253&nbsp;252&nbsp;251)</tt>
<p><a name="./objects:s85"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-truncate!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b><tt><i>bytevector</i></tt> or the empty bytevector
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>bytevector</i></tt> must be mutable.
<tt><i>n</i></tt> must be an exact nonnegative fixnum not greater than the length of
<tt><i>bytevector</i></tt>.
If <tt><i>n</i></tt> is zero, <tt>bytevector-truncate!</tt> returns the empty bytevector.
Otherwise, <tt><i>bytevector-truncate!</i></tt> destructively truncates <tt><i>bytevector</i></tt> to
its first <tt><i>n</i></tt> bytes and returns <tt><i>bytevector</i></tt>.

<p>

<p><tt>(define&nbsp;bv&nbsp;(make-bytevector&nbsp;7&nbsp;19))<br>

(bytevector-truncate!&nbsp;bv&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vu8()<br>

bv&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vu8(19&nbsp;19&nbsp;19&nbsp;19&nbsp;19&nbsp;19&nbsp;19)<br>

(bytevector-truncate!&nbsp;bv&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vu8(19&nbsp;19&nbsp;19)<br>

bv&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#vu8(19&nbsp;19&nbsp;19)</tt>
<p><a name="./objects:s86"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-u24-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>the 24-bit unsigned integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br><span class=formdef><b>procedure</b>: <tt>(bytevector-s24-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>the 24-bit signed integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br><span class=formdef><b>procedure</b>: <tt>(bytevector-u40-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>the 40-bit unsigned integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br><span class=formdef><b>procedure</b>: <tt>(bytevector-s40-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>the 40-bit signed integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br><span class=formdef><b>procedure</b>: <tt>(bytevector-u48-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>the 48-bit unsigned integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br><span class=formdef><b>procedure</b>: <tt>(bytevector-s48-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>the 48-bit signed integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br><span class=formdef><b>procedure</b>: <tt>(bytevector-u56-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>the 56-bit unsigned integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br><span class=formdef><b>procedure</b>: <tt>(bytevector-s56-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>the 56-bit signed integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer and
indexes the starting byte of the value.
The sum of <tt><i>n</i></tt> and the number of bytes occupied by the value
(3 for 24-bit values, 5 for 40-bit values, 6 for 48-bit values,
and 7 for 56-bit values) must not exceed the length of <tt><i>bytevector</i></tt>.
<tt><i>eness</i></tt> must be a valid endianness symbol naming the endianness.

<p>
The return value is an exact integer in the appropriate range for
the number of bytes occupied by the value.
Signed values are the equivalent of the stored value treated as a two's
complement value.

<p>
<a name="./objects:s87"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-u24-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>u24</i>&nbsp;<i>eness</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(bytevector-s24-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>s24</i>&nbsp;<i>eness</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(bytevector-u40-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>u40</i>&nbsp;<i>eness</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(bytevector-s40-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>s40</i>&nbsp;<i>eness</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(bytevector-u48-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>u48</i>&nbsp;<i>eness</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(bytevector-s48-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>s48</i>&nbsp;<i>eness</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(bytevector-u56-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>u56</i>&nbsp;<i>eness</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(bytevector-s56-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>s56</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>bytevector</i></tt> must be mutable.
<tt><i>n</i></tt> must be an exact nonnegative integer and
indexes the starting byte of the value.
The sum of <tt><i>n</i></tt> and the number of bytes occupied by the value must
not exceed the length of <tt><i>bytevector</i></tt>.
<tt><i>u24</i></tt> must be a 24-bit unsigned value, i.e., a value in the range
0 to 2<sup>24</sup> - 1 inclusive;
<tt><i>s24</i></tt> must be a 24-bit signed value, i.e., a value in the range
-2<sup>23</sup> to 2<sup>23</sup> - 1 inclusive;
<tt><i>u40</i></tt> must be a 40-bit unsigned value, i.e., a value in the range
0 to 2<sup>40</sup> - 1 inclusive;
<tt><i>s40</i></tt> must be a 40-bit signed value, i.e., a value in the range
-2<sup>39</sup> to 2<sup>39</sup> - 1 inclusive;
<tt><i>u48</i></tt> must be a 48-bit unsigned value, i.e., a value in the range
0 to 2<sup>48</sup> - 1 inclusive;
<tt><i>s48</i></tt> must be a 48-bit signed value, i.e., a value in the range
-2<sup>47</sup> to 2<sup>47</sup> - 1 inclusive;
<tt><i>u56</i></tt> must be a 56-bit unsigned value, i.e., a value in the range
0 to 2<sup>56</sup> - 1 inclusive; and
<tt><i>s56</i></tt> must be a 56-bit signed value, i.e., a value in the range
-2<sup>55</sup> to 2<sup>55</sup> - 1 inclusive.
<tt><i>eness</i></tt> must be a valid endianness symbol naming the endianness.

<p>
These procedures store the given value in the 3, 5, 6, or 7 bytes starting
at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt>.
Negative values are stored as their two's complement equivalent.

<p>
<a name="./objects:s88"></a><span class=formdef><b>procedure</b>: <tt>(mutable-bytevector?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a mutable bytevector, <tt>#f</tt> otherwise
<br><span class=formdef><b>procedure</b>: <tt>(immutable-bytevector?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an immutable bytevector, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(mutable-bytevector?&nbsp;(bytevector&nbsp;1&nbsp;2&nbsp;3))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(mutable-bytevector?<br>

&nbsp;&nbsp;(bytevector-&gt;immutable-bytevector&nbsp;(bytevector&nbsp;1&nbsp;2&nbsp;3)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(immutable-bytevector?&nbsp;(bytevector&nbsp;1&nbsp;2&nbsp;3))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(immutable-bytevector?<br>

&nbsp;&nbsp;(bytevector-&gt;immutable-bytevector&nbsp;(bytevector&nbsp;1&nbsp;2&nbsp;3)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(immutable-bytevector?&nbsp;(cons&nbsp;3&nbsp;4))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s89"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-&gt;immutable-bytevector&nbsp;<i>bytevector</i>)</tt></span>
<br>
<b>returns: </b>an immutable bytevector equal to <tt><i>bytevector</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./objects:s90"></a><a name="./objects:s91"></a>The result is <tt><i>bytevector</i></tt> itself if <tt><i>bytevector</i></tt>
is immutable; otherwise, the result is an immutable bytevector with the same content as <tt><i>bytevector</i></tt>.

<p>

<p><tt>(define&nbsp;bv&nbsp;(bytevector-&gt;immutable-bytevector&nbsp;(bytevector&nbsp;1&nbsp;2&nbsp;3)))<br>

(bytevector-u8-set!&nbsp;bv&nbsp;0&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;not&nbsp;mutable</i></tt>
<p><a name="./objects:s92"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-compress&nbsp;<i>bytevector</i>)</tt></span>
<br>
<b>returns: </b>a new bytevector containing compressed content of <tt><i>bytevector</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The result is the raw compressed data with a minimal header to record
the uncompressed size and the compression mode. The result does not include
the header that is written by port-based compression using the
<tt>compressed</tt> option. The compression format is determined by the
<a name="./objects:s93"></a><tt>compress-format</tt>
parameter, and the compression level is determined by the
<a name="./objects:s94"></a><tt>compress-level</tt>
parameter.


<p>
<a name="./objects:s95"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-uncompress&nbsp;<i>bytevector</i>)</tt></span>
<br>
<b>returns: </b>a bytevector containing uncompressed content of <tt><i>bytevector</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Uncompresses a <tt><i>bytevector</i></tt> produced by
<tt>bytevector-compress</tt> to a new bytevector with the same content
as the original given to <tt>bytevector-compress</tt>.


<p>

<h3><a name="g57"></a><a name="./objects:h9"></a>Section 7.9. Stencil Vectors</h3>



<p>
<a name="./objects:s96"></a>
Stencil vectors are like vectors, but also have a <i>mask</i>, accessible
via <tt>stencil-vector-mask</tt>, which is a fixnum of no more than
<tt>(stencil-vector-mask-width)</tt> bits.  The length of a stencil vector
is exactly the same as the number of bits set in its mask.  In other
words, the following expression is true for any stencil vector <tt>sv</tt>:

<p>
<tt>(fx=&nbsp;(stencil-vector-length&nbsp;sv)&nbsp;(fxpopcount&nbsp;(stencil-vector-mask&nbsp;sv)))</tt>

<p>
Since <tt>(stencil-vector-mask-width)</tt> can be no more than the number
of bits in a fixnum, the maximum size of a stencil vector is limited.

<p>
Other than the <tt>stencil-vector</tt> constructor, the mask is only
relevant to the <br>
 <tt>stencil-vector-update</tt> and
<tt>stencil-vector-truncate!</tt> procedures.

<p>
A stencil vector provides a more compact representation than a vector
with one element dedicated to the mask. It also provides more
efficient functional update through the <tt>stencil-vector-update</tt>
procedure. A stencil vector is useful, for example, to implement
sparse nodes in a trie.

<p>
<a name="./objects:s97"></a>Stencil vectors are written with the prefix
<tt>#</tt>, then a mask integer, then <tt>vs</tt>, and followed by a
parenthesized sequence of elements. Note that the mask integer
determines the length of the stencil vector, and it uses the same
position as the length of a vector, but the mask is not optional.
Also, the number of elements in the parenthesized sequence must match
exactly the number of bits set in the mask.
The stencil vector syntax is disabled in an input stream after
<tt>#!r6rs</tt> has been seen by the reader, unless
<tt>#!chezscheme</tt> has been seen more recently.

<p>
<a name="./objects:s98"></a><span class=formdef><b>procedure</b>: <tt>(stencil-vector-mask-width)</tt></span>
<br>
<b>returns: </b>a fixnum: the number of bits in a stencil vector mask
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The result is always less than <tt>(fixnum-width)</tt>.

<p>
<a name="./objects:s99"></a><span class=formdef><b>procedure</b>: <tt>(stencil-vector?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a stencil vector, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(stencil-vector?&nbsp;(stencil-vector&nbsp;#b11&nbsp;'x&nbsp;'y))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(stencil-vector?&nbsp;'#3vs(x&nbsp;y))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(stencil-vector?&nbsp;'#2(x&nbsp;y))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s100"></a><span class=formdef><b>procedure</b>: <tt>(stencil-vector&nbsp;<i>mask</i>&nbsp;<i>obj</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>a stencil vector with the given mask and content
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>mask</i></tt> must be a nonnegative fixnum less than
<tt>(fxsll&nbsp;1&nbsp;(stencil-vector-mask-width))</tt>,
and the number of supplied <tt><i>obj</i></tt>s must be the
same as <tt>(fxpopcount&nbsp;mask)</tt>.

<p>

<p><tt>(stencil-vector&nbsp;#b11&nbsp;'x&nbsp;'y)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#3vs(x&nbsp;y)<br>

(stencil-vector&nbsp;#b10101&nbsp;'x&nbsp;'y&nbsp;'z)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#21vs(x&nbsp;y&nbsp;z)</tt>
<p><a name="./objects:s101"></a><span class=formdef><b>procedure</b>: <tt>(stencil-vector-mask&nbsp;<i>stencil-vector</i>)</tt></span>
<br>
<b>returns: </b>the mask of <tt><i>stencil-vector</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./objects:s102"></a><span class=formdef><b>procedure</b>: <tt>(stencil-vector-length&nbsp;<i>stencil-vector</i>)</tt></span>
<br>
<b>returns: </b>the length of <tt><i>stencil-vector</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A stencil vector's length is determined by its mask.  (I.e., this is
equivalent to <tt>(fxpopcount&nbsp;(stencil-vector-mask&nbsp;<i>stencil-vector</i>))</tt>.)

<p>

<p><tt>(stencil-vector-mask&nbsp;'#0vs())&nbsp;;=&nbsp;0<br>

(stencil-vector-length&nbsp;'#0vs())&nbsp;;=&nbsp;0<br>

(stencil-vector-mask&nbsp;'#21vs(x&nbsp;y&nbsp;z))&nbsp;;=&nbsp;21<br>

(stencil-vector-length&nbsp;'#21vs(x&nbsp;y&nbsp;z))&nbsp;;=&nbsp;3</tt>
<p><a name="./objects:s103"></a><span class=formdef><b>procedure</b>: <tt>(stencil-vector-ref&nbsp;<i>stencil-vector</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the object at position <tt><i>n</i></tt> in <tt><i>stencil-vector</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>n</i></tt> must be a nonnegative fixnum that is less than the length of <tt><i>stencil-vector</i></tt>.

<p>
Stencil vector elements are accessed by position, unrelated to the
stencil vector's mask (except insofar as the number of valid positions is
determined by the mask).

<p>
Conceptually, each stensil vector element corresponds to a bit in the
stencil vector's mask (and vice-versa). To convert a (0-based) bit position <tt><i>bit</i></tt> to an
index, where the lowest set bit corresponds to the first element of
the stencil vector, use the following calculation:

<p>
<tt>(fxpopcount&nbsp;(fxand&nbsp;(stencil-vector-mask&nbsp;<i>stencil-vector</i>)&nbsp;(fx-&nbsp;(fxsll&nbsp;1&nbsp;<i>bit</i>)&nbsp;1)))</tt>

<p>

<p><tt>(stencil-vector-ref&nbsp;'#21vs(x&nbsp;y&nbsp;z)&nbsp;0)&nbsp;;=&nbsp;x<br>

(stencil-vector-ref&nbsp;'#21vs(x&nbsp;y&nbsp;z)&nbsp;2)&nbsp;;=&nbsp;z</tt>
<p><a name="./objects:s104"></a><span class=formdef><b>procedure</b>: <tt>(stencil-vector-set!&nbsp;<i>stencil-vector</i>&nbsp;<i>n</i>&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>n</i></tt> must be a nonnegative fixnum that is less than the length of <tt><i>stencil-vector</i></tt>.

<p>
Installs <tt><i>obj</i></tt> at position <tt><i>n</i></tt> within <tt><i>stencil-vector</i></tt>.
See <tt>stencil-vector-ref</tt> for more information about positions
in stencil vectors.

<p>

<p><tt>(define&nbsp;sv&nbsp;(stencil-vector&nbsp;#b10101&nbsp;'x&nbsp;'y&nbsp;'z))<br>

(stencil-vector-set!&nbsp;sv&nbsp;1&nbsp;'why)<br>

sv&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#21vs(x&nbsp;why&nbsp;z)</tt>
<p><a name="./objects:s105"></a><span class=formdef><b>procedure</b>: <tt>(stencil-vector-update&nbsp;<i>stencil-vector</i>&nbsp;<i>remove-bits</i>&nbsp;<i>add-bits</i>&nbsp;<i>obj</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>a new stencil vector adapted from <tt><i>stencil-vector</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>remove-bits</i></tt> and <tt><i>add-bits</i></tt> must be nonnegative fixnums less
than <br>
 <tt>(fxsll&nbsp;1&nbsp;(stencil-vector-mask-width))</tt>. Furthermore, all of
the following must be true:

<p>
<ul>

 <p>
<li><tt><i>remove-bits</i></tt>
       must be a subset of the bits in the mask of <tt><i>stencil-vector</i></tt>.
       In other words,
       <tt>(logand&nbsp;(stencil-vector-mask&nbsp;<i>stencil-vector</i>)&nbsp;<i>remove-bits</i>)</tt>
       must be equal to <tt><i>remove-bits</i></tt>.

  <p>
<li><tt><i>add-bits</i></tt> must have a set of bits that do not overlap the
        subtraction of <tt><i>remove-bits</i></tt> from the mask of
        <tt><i>stencil-vector</i></tt>.  In other words
        
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(logand<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(logand&nbsp;(stencil-vector-mask&nbsp;<i>stencil-vector</i>)&nbsp;(lognot&nbsp;<i>remove-bits</i>))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>add-bits</i>)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<p>        must be <tt>0</tt>.
        
 <p>
<li>The number of supplied <tt><i>obj</i></tt>s must match <tt>(fxpopcount&nbsp;add-bits)</tt>.

<p>
</ul>
<p>

<p>
Returns a new stencil vector that has all of the elements of
<tt><i>stencil-vector</i></tt>, except the ones identified by the bits in
<tt><i>remove-bits</i></tt>. The new stencil vector also has the given <tt><i>obj</i></tt>s at
positions determined by <tt><i>add-bits</i></tt>. Elements copied from <tt><i>stencil-vector</i></tt>
to the new vector retain their relative positions corresponding to their
bits in the <tt><i>stencil-vector</i></tt> mask. Individual bits in the mask, <tt><i>remove-bits</i></tt>,
and <tt><i>add-bits</i></tt> are mapped to element positions as described in the documentation
of <tt>stencil-vector-ref</tt>. The mask of the new stencil vector is the mask of
<tt><i>stencil-vector</i></tt> minus <tt><i>remove-bits</i></tt> plus <tt><i>add-bits</i></tt>.

<p>

<p><tt>(define&nbsp;st-vec&nbsp;(stencil-vector&nbsp;#b101&nbsp;'a&nbsp;'b))<br>

(stencil-vector-update&nbsp;st-vec&nbsp;#b0&nbsp;#b10&nbsp;'c)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#7vs(a&nbsp;c&nbsp;b)<br>

(stencil-vector-update&nbsp;st-vec&nbsp;#b0&nbsp;#b1000&nbsp;'c)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#13vs(a&nbsp;b&nbsp;c)<br>

st-vec&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#5vs(a&nbsp;b)<br>

(stencil-vector-update&nbsp;st-vec&nbsp;#b1&nbsp;#b1&nbsp;'c)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#5vs(c&nbsp;b)<br>

(stencil-vector-update&nbsp;st-vec&nbsp;#b100&nbsp;#b100&nbsp;'c)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#5vs(a&nbsp;c)<br>

(stencil-vector-update&nbsp;st-vec&nbsp;#b100&nbsp;#b0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#1vs(a)</tt>
<p><a name="./objects:s106"></a><span class=formdef><b>procedure</b>: <tt>(stencil-vector-truncate!&nbsp;<i>stencil-vector</i>&nbsp;<i>mask</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>mask</i></tt> must be a nonnegative fixnum that does not have more bits set
than bits set in the current mask of <tt><i>stencil-vector</i></tt>.

<p>
Changes the mask of <tt><i>stencil-vector</i></tt> to <tt><i>mask</i></tt>, discarding any
elements of the vector beyond the first <tt>(fxpopcount&nbsp;<i>mask</i>)</tt> elements.
There is no requirement that <tt><i>mask</i></tt> has any bits in common with
the current mask of <tt><i>stencil-vector</i></tt>.


<p>

<h3><a name="g58"></a><a name="./objects:h10"></a>Section 7.10. Boxes<a name="SECTBOXES"></a></h3>



<p>
<a name="./objects:s107"></a>Boxes are single-cell objects that are primarily useful for providing
an "extra level of indirection."
This extra level of indirection is typically used to allow more than one body
of code or data structure to share a <a name="./objects:s108"></a>reference, or <a name="./objects:s109"></a>pointer, to an object.
For example, boxes may be used to implement <a name="./objects:s110"></a><i>call-by-reference</i> semantics
in an interpreter for a language employing this parameter passing discipline.

<p>
<a name="./objects:s111"></a>Boxes are written with
the prefix <tt>#&amp;</tt> (pronounced "hash-ampersand").
For example, <tt>#&amp;(a&nbsp;b&nbsp;c)</tt> is a box holding the list <tt>(a&nbsp;b&nbsp;c)</tt>.
The box syntax is disabled in an input stream after <tt>#!r6rs</tt> has
been seen by the reader, unless <tt>#!chezscheme</tt> has been seen more
recently.

<p>
<a name="./objects:s112"></a><a name="./objects:s113"></a>All boxes are mutable by default, including constants.
A program can create immutable boxes via
<a name="./objects:s114"></a><tt>box-immutable</tt>.
Any attempt to modify an immutable box causes an exception to be raised.

<p>
<a name="./objects:s115"></a><span class=formdef><b>procedure</b>: <tt>(box?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a box, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(box?&nbsp;'#&amp;a)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(box?&nbsp;'a)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(box?&nbsp;(box&nbsp;3))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s116"></a><span class=formdef><b>procedure</b>: <tt>(box&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>a new box containing <tt><i>obj</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(box&nbsp;'a)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&amp;a<br>

(box&nbsp;(box&nbsp;'(a&nbsp;b&nbsp;c)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&amp;#&amp;(a&nbsp;b&nbsp;c)</tt>
<p><a name="./objects:s117"></a><span class=formdef><b>procedure</b>: <tt>(unbox&nbsp;<i>box</i>)</tt></span>
<br>
<b>returns: </b>contents of <tt><i>box</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(unbox&nbsp;#&amp;a)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;a<br>

(unbox&nbsp;#&amp;#&amp;(a&nbsp;b&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&amp;(a&nbsp;b&nbsp;c)
<br>
<br>
(let&nbsp;([b&nbsp;(box&nbsp;"hi")])<br>

&nbsp;&nbsp;(unbox&nbsp;b))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"hi"</tt>
<p><a name="./objects:s118"></a><span class=formdef><b>procedure</b>: <tt>(set-box!&nbsp;<i>box</i>&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>box</i></tt> must be mutable.
<tt>set-box!</tt> sets the contents of <tt><i>box</i></tt> to <tt><i>obj</i></tt>.

<p>

<p><tt>(let&nbsp;([b&nbsp;(box&nbsp;'x)])<br>

&nbsp;&nbsp;(set-box!&nbsp;b&nbsp;'y)<br>

&nbsp;&nbsp;b)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&amp;y
<br>
<br>
(let&nbsp;([incr!<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-box!&nbsp;x&nbsp;(+&nbsp;(unbox&nbsp;x)&nbsp;1)))])<br>

&nbsp;&nbsp;(let&nbsp;([b&nbsp;(box&nbsp;3)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(incr!&nbsp;b)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(unbox&nbsp;b)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4</tt>
<p><a name="./objects:s119"></a><span class=formdef><b>procedure</b>: <tt>(box-cas!&nbsp;<i>box</i>&nbsp;<i>old-obj</i>&nbsp;<i>new-obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>box</i></tt> is changed, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>box</i></tt> must be mutable.
<tt>box-cas!</tt> atomically changes the content of <tt><i>box</i></tt> to <tt><i>new-obj</i></tt>
if the replaced content is <tt>eq?</tt> to <tt><i>old-obj</i></tt>.
If the content of <tt><i>box</i></tt> that would be replaced is not <tt>eq?</tt> to <tt><i>old-obj</i></tt>, then
<tt><i>box</i></tt> is unchanged.

<p>
On an architecture with a weak memory model, <tt>box-cas!</tt> can
spuriously fail, leaving <tt><i>box</i></tt> unchanged and returning
<tt>#f</tt> even if the current value in <tt><i>box</i></tt> is <tt><i>old-obj</i></tt>.
On success, no memory ordering is implied, which means that
<tt>memory-order-acquire</tt> and/or <tt>memory-order-release</tt> may be
needed to complete an intended synchronization.

<p>

<p><tt>(define&nbsp;b&nbsp;(box&nbsp;'old))<br>

(box-cas!&nbsp;b&nbsp;'old&nbsp;'new)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t,&nbsp;assuming&nbsp;no&nbsp;spurious&nbsp;failure<br>

(unbox&nbsp;b)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;'new<br>

(box-cas!&nbsp;b&nbsp;'other&nbsp;'wrong)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(unbox&nbsp;b)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;'new</tt>
<p><a name="./objects:s120"></a><span class=formdef><b>procedure</b>: <tt>(mutable-box?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a mutable box, <tt>#f</tt> otherwise
<br><span class=formdef><b>procedure</b>: <tt>(immutable-box?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an immutable box, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(mutable-box?&nbsp;(box&nbsp;1))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(mutable-box?&nbsp;(box-immutable&nbsp;1))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(immutable-box?&nbsp;(box&nbsp;1))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(immutable-box?&nbsp;(box-immutable&nbsp;1))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(mutable-box?&nbsp;(cons&nbsp;3&nbsp;4))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s121"></a><span class=formdef><b>procedure</b>: <tt>(box-immutable&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>a new immutable box containing <tt><i>obj</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./objects:s122"></a><a name="./objects:s123"></a>Boxes are typically intended to support shared, mutable structure, so immutable boxes
are not often useful.

<p>

<p><tt>(define&nbsp;b&nbsp;(box-immutable&nbsp;1))<br>

(set-box!&nbsp;b&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;not&nbsp;mutable</i></tt>
<p>
<h3><a name="g59"></a><a name="./objects:h11"></a>Section 7.11. Symbols<a name="SECTMISCSYMBOLS"></a></h3>



<p>
<i>Chez&nbsp;Scheme</i> extends the standard symbol syntax in several ways:

<p>
<ul>
<li>Symbol names may begin with <tt>@</tt>, but <tt>,@abc</tt> is parsed
as <tt>(unquote-splicing&nbsp;abc)</tt>; to produce <tt>(unquote&nbsp;@abc)</tt>
one can type <tt>,&nbsp;@abc</tt>, <tt>\x40;abc</tt>, or <tt>,|@abc|</tt>.

<p>
<li>The single-character sequences <tt>&#123;</tt> and <tt>&#125;</tt>
are read as symbols.

<p>
<li>A symbol's name may begin with any character that might normally start a
number, including a digit, <tt>.</tt>, <tt>+</tt>, <tt>-</tt>, as long as
the delimited sequence of characters starting with that character cannot
be parsed as a number.

<p>
<li>A symbol whose name contains arbitrary characters may be written by
escaping them with <tt>\</tt> or with <tt>|</tt>.
<tt>\</tt> is used to escape a single character (except 'x', since
<tt>\x</tt> marks the start of a hex scalar value),
whereas <tt>|</tt> is used
to escape the group of characters that follow it up through the
matching <tt>|</tt>.
</ul>
<p>

<p>
The printer always prints symbols using the standard R6RS syntax, so that,
e.g., <tt>@abc</tt> prints as <tt>\x40;abc</tt> and <tt>1-</tt> prints as
<tt>\x31;-</tt>.  '

<p>
Gensyms are printed
<a name="./objects:s124"></a><tt>#&#123;</tt> and
<tt>&#125;</tt> brackets that enclose both the "pretty" and "unique"
names,
e.g., <tt>#&#123;g1426&nbsp;e5g1c94g642dssw-a&#125;</tt>.
They may also be printed using the pretty name only with the prefix
<a name="./objects:s125"></a><tt>#:</tt>, e.g.,
<tt>#:g1426</tt>.

<p>
These extensions are disabled in an input stream after <tt>#!r6rs</tt> has
been seen by the reader, unless <tt>#!chezscheme</tt> has been seen more
recently.


<p>
<a name="./objects:s126"></a><a name="desc:gensym"></a>
<span class=formdef><b>procedure</b>: <tt>(gensym)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(gensym&nbsp;<i>pretty-name</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(gensym&nbsp;<i>pretty-name</i>&nbsp;<i>unique-name</i>)</tt></span>
<br>
<b>returns: </b>a unique generated symbol
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./objects:s127"></a><a name="./objects:s128"></a>Each
call to <tt>gensym</tt> returns a unique generated symbol, or <i>gensym</i>.
Each generated symbol has two names: a "pretty" name and a
"unique" name.

<p>
In the first form above, the pretty name is formed (lazily---see
below) by combining an
internal prefix with the value of an internal counter.
After each name is formed, the internal counter is incremented.
The parameters <tt>gensym-prefix</tt> and
<tt>gensym-count</tt>, described below, may be used to access and set
the internal prefix and counter.
By default, the prefix is the single-character string <tt>"g"</tt>.
In the second and third forms, the pretty name of the new gensym
is <tt><i>pretty-name</i></tt>, which must be a string.
The pretty name of a gensym is returned by the procedure
<tt>symbol-&gt;string</tt>.

<p>
In both the first and second forms, the unique name is an
automatically generated globally unique name.
Globally unique names are constructed (lazily---see below) from the
combination of a universally unique identifier and an internal
counter.
In the third form of gensym, the unique name of the new gensym is
<tt><i>unique-name</i></tt>, which must be a string.
The unique name of a gensym may be obtained via the procedure
<tt>gensym-&gt;unique-string</tt>.

<p>
The unique name allows gensyms to be written in such a way that they
can be read back and reliably commonized on input.
<a name="./objects:s129"></a>The syntax for gensyms
includes both the pretty name and the unique name, as shown in the
example below:

<p>

<p><tt>(gensym)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&#123;g0&nbsp;bcsfg5eq4e9b3h9o-a&#125;</tt>
<p>When the parameter <a name="./objects:s130"></a><tt>print-gensym</tt> is set to <tt>pretty</tt>,
the printer prints the pretty name only, with a
<a name="./objects:s131"></a><tt>#:</tt> syntax, so

<p>

<p><tt>(parameterize&nbsp;([print-gensym&nbsp;'pretty])<br>

&nbsp;&nbsp;(write&nbsp;(gensym)))</tt>
<p>prints <tt>#:g0</tt>.

<p>
When the reader sees the <tt>#:</tt> syntax, it produces a gensym with
the given pretty name, but the original unique name is lost.

<p>
When the parameter is set to <tt>#f</tt>, the printer prints just the
pretty name, so

<p>

<p><tt>(parameterize&nbsp;([print-gensym&nbsp;#f])<br>

&nbsp;&nbsp;(write&nbsp;(gensym)))</tt>
<p>prints <tt>g0</tt>.
This is useful only when gensyms do not need to be read back in
as gensyms.

<p>
In order to reduce construction and (when threaded) synchronization
overhead when gensyms are frequently created but rarely printed or
stored in an object file, generated pretty and unique names are created
lazily, i.e., not until first requested, either by the printer, fasl
writer, or explicitly by one of the procedures <tt>symbol-&gt;string</tt>
or <tt>gensym-&gt;unique-string</tt>.
In addition, a gensym is not placed into the system's internal symbol
table (the oblist; see page&nbsp;<a href="./objects.html#desc:oblist">175</a>) until the unique name
is requested.
This allows a gensym to be reclaimed by the storage manager
if no references to the gensym exist and no unique name exists by which to
access it, even if it has a top-level binding or a nonempty property
list.

<p>

<p><tt>(define&nbsp;x&nbsp;(gensym))<br>

x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&#123;g2&nbsp;bcsfg5eq4e9b3h9o-c&#125;<br>

(symbol-&gt;string&nbsp;x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"g2"<br>

(gensym-&gt;unique-string&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"bcsfg5eq4e9b3h9o-c"</tt>
<p>Gensyms subsume the notion of <a name="./objects:s132"></a><i>uninterned
symbols</i> supported by earlier versions of <i>Chez&nbsp;Scheme</i>.
For most purposes, the predicate
<a name="./objects:s133"></a><tt>uninterned-symbol?</tt> has been replaced
by <tt>gensym?</tt>.

<p>
<a name="./objects:s134"></a><span class=formdef><b>thread parameter</b>: <tt>gensym-prefix</tt></span>
<br><span class=formdef><b>thread parameter</b>: <tt>gensym-count</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./objects:s135"></a>The parameters <tt>gensym-prefix</tt> and
<tt>gensym-count</tt> are used to access and set the internal prefix
and counter from which the pretty name of a gensym
is generated when <tt>gensym</tt> is not given an explicit string
argument.
<tt>gensym-prefix</tt> defaults to the string <tt>"g"</tt> and may be
set to any object.
<tt>gensym-count</tt> starts at 0 and may be set to any nonnegative
integer.

<p>
As described above, <i>Chez&nbsp;Scheme</i> delays the creation
of the pretty name until the name is first requested by the printer or by
an explicit call to <tt>symbol-&gt;string</tt>.
These parameters are not consulted until that time; setting them when
<tt>gensym</tt> is called thus has no effect on the generated name.

<p>

<p><tt>(let&nbsp;([x&nbsp;(parameterize&nbsp;([gensym-prefix&nbsp;"genny"]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[gensym-count&nbsp;17]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[print-gensym&nbsp;'pretty])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(gensym))])<br>

&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;x))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"#&#123;g4&nbsp;bcsfg5eq4e9b3h9o-e&#125;"<br>

(let&nbsp;([x&nbsp;(gensym)])<br>

&nbsp;&nbsp;(parameterize&nbsp;([gensym-prefix&nbsp;"genny"]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[gensym-count&nbsp;17]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[print-gensym&nbsp;#f])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;(gensym))))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"genny17"</tt>
<p><a name="./objects:s136"></a><span class=formdef><b>procedure</b>: <tt>(gensym-&gt;unique-string&nbsp;<i>gensym</i>)</tt></span>
<br>
<b>returns: </b>the unique name of <tt><i>gensym</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(gensym-&gt;unique-string&nbsp;(gensym))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"bd3kufa7ypjcuvut-g"</tt>
<p><a name="./objects:s137"></a><span class=formdef><b>procedure</b>: <tt>(gensym?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a gensym, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(gensym?&nbsp;(string-&gt;symbol&nbsp;"z"))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(gensym?&nbsp;(gensym&nbsp;"z"))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(gensym?&nbsp;'a)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(gensym?&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(gensym?&nbsp;(gensym))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(gensym?&nbsp;'#&#123;g2&nbsp;bcsfg5eq4e9b3h9o-c&#125;)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s138"></a><span class=formdef><b>procedure</b>: <tt>(string-&gt;uninterned-symbol&nbsp;<i>str</i>)</tt></span>
<br>
<b>returns: </b>a fresh uninterned symbol
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>str</i></tt> must be a string.

<p>
Returns an uninterned symbol that prints the same as a symbol
constructed from <tt><i>str</i></tt>, but which is not <tt>eq?</tt> to any
other symbol.

<p>
When an uninterned symbol is converted by the fasl writer, the fasl
reader will allocate a fresh uninterned symbol each time the fasl
stream is read. Multiple occurrences of the same uninterned symbol in
the fasl writer's argument will become multiple occurrences of the
same new uninterned symbol in the fasl reader's result for the stream.

<p>

<p><tt>
(string-&gt;uninterned-symbol&nbsp;"z")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;z<br>

(uninterned-symbol?&nbsp;(string-&gt;uninterned-symbol&nbsp;"z"))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(symbol?&nbsp;(string-&gt;uninterned-symbol&nbsp;"z"))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(gensym?&nbsp;(string-&gt;uninterned-symbol&nbsp;"z"))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s139"></a><span class=formdef><b>procedure</b>: <tt>(uninterned-symbol?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an uninterned symbol, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(uninterned-symbol?&nbsp;(string-&gt;symbol&nbsp;"z"))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(uninterned-symbol?&nbsp;(gensym&nbsp;"z"))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(uninterned-symbol?&nbsp;(string-&gt;uninterned-symbol&nbsp;"z"))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s140"></a><a name="property-lists"></a>
<span class=formdef><b>procedure</b>: <tt>(putprop&nbsp;<i>symbol</i>&nbsp;<i>key</i>&nbsp;<i>value</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><i>Chez&nbsp;Scheme</i> associates a <a name="./objects:s141"></a><i>property list</i> with
each symbol, allowing multiple <tt><i>key-value</i></tt> pairs to be stored
directly with the symbol.
New key-value pairs may be placed in the property list or retrieved in
a manner analogous to the use of association lists, using the procedures
<tt>putprop</tt> and <tt>getprop</tt>.
Property lists are often used to store information related to the symbol
itself.
For example, a natural language program might use symbols to represent
words, using their property lists to store information about use and
meaning.

<p>
<tt>putprop</tt> associates <tt><i>value</i></tt> with <tt><i>key</i></tt> on the
property list of <tt><i>symbol</i></tt>.
<tt><i>key</i></tt> and <tt><i>value</i></tt> may be any types of object, although <tt><i>key</i></tt> is
typically a symbol.

<p>
<tt>putprop</tt> may be used to establish a new property or to change
an existing property.

<p>
See the examples under <tt>getprop</tt> below.


<p>
<a name="./objects:s142"></a><span class=formdef><b>procedure</b>: <tt>(getprop&nbsp;<i>symbol</i>&nbsp;<i>key</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(getprop&nbsp;<i>symbol</i>&nbsp;<i>key</i>&nbsp;<i>default</i>)</tt></span>
<br>
<b>returns: </b>the value associated with <tt><i>key</i></tt> on the property list of <tt><i>symbol</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./objects:s143"></a><tt>getprop</tt> searches the property list of
<tt><i>symbol</i></tt> for a key identical to <tt><i>key</i></tt> (in the sense of
<tt>eq?</tt>), and returns the value associated with this key, if any.
If no value is associated with <tt><i>key</i></tt> on the property list of
<tt><i>symbol</i></tt>, <tt>getprop</tt> returns <tt><i>default</i></tt>, or <tt>#f</tt> if
the <tt><i>default</i></tt> argument is not supplied.


<p>

<p><tt>(putprop&nbsp;'fred&nbsp;'species&nbsp;'snurd)<br>

(putprop&nbsp;'fred&nbsp;'age&nbsp;4)&nbsp;&nbsp;<br>

(putprop&nbsp;'fred&nbsp;'colors&nbsp;'(black&nbsp;white))
<br>
<br>
(getprop&nbsp;'fred&nbsp;'species)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;snurd<br>

(getprop&nbsp;'fred&nbsp;'colors)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(black&nbsp;white)<br>

(getprop&nbsp;'fred&nbsp;'nonkey)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(getprop&nbsp;'fred&nbsp;'nonkey&nbsp;'unknown)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;unknown<br>

&nbsp;<br>

(putprop&nbsp;'fred&nbsp;'species&nbsp;#f)<br>

(getprop&nbsp;'fred&nbsp;'species&nbsp;'unknown)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s144"></a><span class=formdef><b>procedure</b>: <tt>(remprop&nbsp;<i>symbol</i>&nbsp;<i>key</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>remprop</tt> removes the property with key <tt><i>key</i></tt> from the property
list of <tt><i>symbol</i></tt>, if such a property exists<a name="./objects:s145"></a>.

<p>

<p><tt>(putprop&nbsp;'fred&nbsp;'species&nbsp;'snurd)<br>

(getprop&nbsp;'fred&nbsp;'species)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;snurd
<br>
<br>
(remprop&nbsp;'fred&nbsp;'species)<br>

(getprop&nbsp;'fred&nbsp;'species&nbsp;'unknown)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;unknown</tt>
<p><a name="./objects:s146"></a><span class=formdef><b>procedure</b>: <tt>(property-list&nbsp;<i>symbol</i>)</tt></span>
<br>
<b>returns: </b>a copy of the internal property list for <tt><i>symbol</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A property list is a list of alternating keys and values,
i.e., <tt>(<i>key</i>&nbsp;<i>value</i>&nbsp;...)</tt>.

<p>

<p><tt>(putprop&nbsp;'fred&nbsp;'species&nbsp;'snurd)<br>

(putprop&nbsp;'fred&nbsp;'colors&nbsp;'(black&nbsp;white))<br>

(property-list&nbsp;'fred)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(colors&nbsp;(black&nbsp;white)&nbsp;species&nbsp;snurd)</tt>
<p><a name="./objects:s147"></a><a name="desc:oblist"></a>
<span class=formdef><b>procedure</b>: <tt>(oblist)</tt></span>
<br>
<b>returns: </b>a list of interned symbols
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The system maintains an internal symbol table used
to insure that any two occurrences of the same
symbol name resolve to the same symbol object.
The <tt>oblist</tt> procedure returns a list of the symbols currently in
this symbol table.

<p>
The list of interned symbols grows when a new symbol
is introduced into the system or when the unique name of a
gensym (see page&nbsp;<a href="./objects.html#desc:gensym">171</a>) is requested.
It shrinks when the garbage collector determines that it is
safe to discard a symbol.
It is safe to discard a symbol only if the symbol is not accessible except
through the oblist,
has no top-level binding, and has no properties on its property
list.

<p>

<p><tt>(if&nbsp;(memq&nbsp;'tiger&nbsp;(oblist))&nbsp;'yes&nbsp;'no)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;yes<br>

(equal?&nbsp;(oblist)&nbsp;(oblist))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(=&nbsp;(length&nbsp;(oblist))&nbsp;(length&nbsp;(oblist)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t&nbsp;<i>or</i>&nbsp;#f</tt>
<p>The first example above follows from the property that all interned
symbols are in the oblist from the time they are read, which happens
prior to evaluation.
The second example follows from the fact that no symbols can be
removed from the oblist while references to those symbols exist, in
this case, within the list returned by the first call to
<tt>oblist</tt> (whichever call is performed first).
The expression in the third example can return <tt>#f</tt> only if a garbage
collection occurs sometime between the two calls to <tt>oblist</tt>, and only
if one or more symbols are removed from the oblist by that collection.

<p>

<h3><a name="g60"></a><a name="./objects:h12"></a>Section 7.12. Void<a name="SECTMISCVOID"></a></h3>



<p>
Many Scheme operations return an unspecified result.
<i>Chez&nbsp;Scheme</i> typically returns a special <i>void</i> object when the
value returned by an operation is unspecified.
The <i>Chez&nbsp;Scheme</i> void object is not meant to be used as a datum, and
consequently does not have a reader syntax.
As for other objects without a reader syntax, such as procedures and
ports, <i>Chez&nbsp;Scheme</i> output procedures print the void object using a
nonreadable representation, i.e., <tt>#&lt;void&gt;</tt>.
Since the void object should be returned only by operations that do not
have "interesting" values, the default waiter printer (see
<tt>waiter-write</tt>) suppresses the printing of the void object.
<tt>set!</tt>, <tt>set-car!</tt>, <tt>load</tt>, and <tt>write</tt> are examples of <i>Chez&nbsp;Scheme</i>
operations that return the void object.

<p>
<a name="./objects:s148"></a><span class=formdef><b>procedure</b>: <tt>(void)</tt></span>
<br>
<b>returns: </b>the void object
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>void</tt> is a procedure of no arguments that returns the void object.
It can be used to force expressions that are used for effect or whose
values are otherwise unspecified to evaluate to a consistent, trivial
value.
Since most <i>Chez&nbsp;Scheme</i> operations that are used for effect
return the void object, however, it is rarely necessary to explicitly
invoke the <tt>void</tt> procedure.

<p>
Since the void object is used explicitly as an "unspecified" value,
it is a bad idea to use it for any other purpose or to count on any
given expression evaluating to the void object.

<p>
The default waiter printer suppresses the void object; that is, nothing
is printed for expressions that evaluate to the void object.

<p>

<p><tt>(eq?&nbsp;(void)&nbsp;#f)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq?&nbsp;(void)&nbsp;#t)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq?&nbsp;(void)&nbsp;'())&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>
<h3><a name="g61"></a><a name="./objects:h13"></a>Section 7.13. Sorting<a name="SECTMISCSORTING"></a></h3>



<p>
<a name="./objects:s149"></a><span class=formdef><b>procedure</b>: <tt>(sort&nbsp;<i>predicate</i>&nbsp;<i>list</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(sort!&nbsp;<i>predicate</i>&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>a list containing the elements of <tt><i>list</i></tt> sorted according to <tt><i>predicate</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>sort</tt> is identical to the Revised<sup>6</sup> Report <tt>list-sort</tt>,
and <tt>sort!</tt> is a destructive version of <tt>sort</tt>, i.e., it
reuses pairs from the input list to form the output list.

<p>

<p><tt>(sort&nbsp;&lt;&nbsp;'(3&nbsp;4&nbsp;2&nbsp;1&nbsp;2&nbsp;5))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;2&nbsp;3&nbsp;4&nbsp;5)<br>

(sort!&nbsp;&lt;&nbsp;'(3&nbsp;4&nbsp;2&nbsp;1&nbsp;2&nbsp;5))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;2&nbsp;3&nbsp;4&nbsp;5)</tt>
<p><a name="./objects:s150"></a><span class=formdef><b>procedure</b>: <tt>(merge&nbsp;<i>predicate</i>&nbsp;<i>list<sub>1</sub></i>&nbsp;<i>list<sub>2</sub></i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(merge!&nbsp;<i>predicate</i>&nbsp;<i>list<sub>1</sub></i>&nbsp;<i>list<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt><i>list<sub>1</sub></i></tt> merged with <tt><i>list<sub>2</sub></i></tt> in the order specified by <tt><i>predicate</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>predicate</i></tt> should be a procedure that expects two arguments and
returns <tt>#t</tt> if its first argument must precede its second in
the merged list.
It should not have any side effects.
That is, if <tt><i>predicate</i></tt> is applied to two objects <tt><i>x</i></tt> and
<tt><i>y</i></tt>, where <tt><i>x</i></tt> is taken from the second list and <tt><i>y</i></tt>
is taken from the first list,
it should return true only if <tt><i>x</i></tt> should appear before <tt><i>y</i></tt>
in the output list.
If this constraint is met,
<tt>merge</tt> and <tt>merge!</tt> are stable, in that items from <tt><i>list<sub>1</sub></i></tt> are
placed in front of equivalent items from <tt><i>list<sub>2</sub></i></tt> in the output list.
Duplicate elements are included in the merged list.

<p>
<tt>merge!</tt> combines the lists destructively, using pairs from the input
lists to form the output list.

<p>

<p><tt>(merge&nbsp;char&lt;?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(#\a&nbsp;#\c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(#\b&nbsp;#\c&nbsp;#\d))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(#\a&nbsp;#\b&nbsp;#\c&nbsp;#\c&nbsp;#\d)<br>

(merge&nbsp;&lt;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(1/2&nbsp;2/3&nbsp;3/4)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(0.5&nbsp;0.6&nbsp;0.7))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(1/2&nbsp;0.5&nbsp;0.6&nbsp;2/3&nbsp;0.7&nbsp;3/4)</tt>
<p>
<h3><a name="g62"></a><a name="./objects:h14"></a>Section 7.14. Hashtables<a name="SECTMISCHASHTABLES"></a></h3>



<p>
<i>Chez&nbsp;Scheme</i> provides several extensions to the hashtable mechanism,
including a mechanism for directly accessing a key, value pair in a
hashtable, support for weak eq and eqv hashtables, and a set of procedures
specialized to eq and symbol hashtables.

<p>
<a name="./objects:s151"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-cell&nbsp;<i>hashtable</i>&nbsp;<i>key</i>&nbsp;<i>default</i>)</tt></span>
<br>
<b>returns: </b>a pair (see below)
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be a mutable hashtable.
<tt><i>key</i></tt> and <tt><i>default</i></tt> may be any Scheme values.

<p>
If no value is associated with <tt><i>key</i></tt> in <tt><i>hashtable</i></tt>,
<tt>hashtable-cell</tt> modifies <tt><i>hashtable</i></tt> to associate <tt><i>key</i></tt> with
<tt><i>default</i></tt>.
It returns a pair whose car is <tt><i>key</i></tt> and whose cdr is
the associated value.
Changing the cdr of this pair effectively updates the table to
associate <tt><i>key</i></tt> with a new value.
The <tt><i>key</i></tt> in the car field should not be changed.
The advantage of this procedure over the Revised<sup>6</sup> Report procedures
for manipulating hashtable entries is that the value associated with
a key may be read or written many times with only a single hashtable
lookup.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(define&nbsp;v&nbsp;(vector&nbsp;'a&nbsp;'b&nbsp;'c))<br>

(define&nbsp;cell&nbsp;(hashtable-cell&nbsp;ht&nbsp;v&nbsp;3))<br>

cell&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(#(a&nbsp;b&nbsp;c)&nbsp;.&nbsp;3)<br>

(hashtable-ref&nbsp;ht&nbsp;v&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(set-cdr!&nbsp;cell&nbsp;4)<br>

(hashtable-ref&nbsp;ht&nbsp;v&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4</tt>
<p><a name="./objects:s152"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-ref-cell&nbsp;<i>hashtable</i>&nbsp;<i>key</i>)</tt></span>
<br>
<b>returns: </b>a pair if <tt><i>key</i></tt> is in <tt><i>hashtable</i></tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be a mutable hashtable.
<tt><i>key</i></tt> may be any Scheme value.

<p>
If <tt><i>key</i></tt> is associated with a value in <tt><i>hashtable</i></tt>, then <tt>hashtable-ref-cell</tt> returns a pair
whose car is <tt><i>key</i></tt> and whose cdr is the associated value. Changing the cdr of
this pair effectively updates the table to associate <tt><i>key</i></tt> with a new value.
The <tt><i>key</i></tt> in the car field should not be changed.

<p>
If <tt><i>key</i></tt> is not in <tt><i>hashtable</i></tt>, then <tt>#f</tt> is returned.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(define&nbsp;v&nbsp;(vector&nbsp;'a&nbsp;'b&nbsp;'c))<br>

(hashtable-ref-cell&nbsp;ht&nbsp;v)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(hashtable-set!&nbsp;ht&nbsp;v&nbsp;3)<br>

(define&nbsp;cell&nbsp;(hashtable-ref-cell&nbsp;ht&nbsp;v))<br>

cell&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;((#a&nbsp;b&nbsp;c)&nbsp;.&nbsp;3)<br>

(hashtable-ref&nbsp;ht&nbsp;v&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(set-cdr!&nbsp;cell&nbsp;4)<br>

(hashtable-ref&nbsp;ht&nbsp;v&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4</tt>
<p><a name="./objects:s153"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-keys&nbsp;<i>hashtable</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(hashtable-keys&nbsp;<i>hashtable</i>&nbsp;<i>size</i>)</tt></span>
<br>
<b>returns: </b>a vector containing the keys in <tt><i>hashtable</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Identical to the Revised<sup>6</sup> Report counterpart, but allowing an optional
<tt><i>size</i></tt> argument.
If <tt><i>size</i></tt> is specified, then it must be an exact, nonnegative integer; the
result vector will contain <tt>(min&nbsp;<i>size</i>&nbsp;(hashtable-size&nbsp;<i>hashtable</i>))</tt> elements.
Different calls to <tt>hashtable-keys</tt>
with a <tt><i>size</i></tt> less than <tt>(hashtable-size&nbsp;<i>hashtable</i>)</tt>
may return different subsets of <tt><i>hashtable</i></tt>'s keys.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(hashtable-set!&nbsp;ht&nbsp;'a&nbsp;"one")<br>

(hashtable-set!&nbsp;ht&nbsp;'b&nbsp;"two")<br>

(hashtable-set!&nbsp;ht&nbsp;'c&nbsp;"three")<br>

(hashtable-keys&nbsp;ht)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#(a&nbsp;b&nbsp;c)&nbsp;<i>or&nbsp;any&nbsp;permutation</i><br>

(hashtable-keys&nbsp;ht&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#(a)&nbsp;<i>or</i>&nbsp;#(b)&nbsp;<i>or</i>&nbsp;#(c)</tt>
<p><a name="./objects:s154"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-values&nbsp;<i>hashtable</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(hashtable-values&nbsp;<i>hashtable</i>&nbsp;<i>size</i>)</tt></span>
<br>
<b>returns: </b>a vector containing the values in <tt><i>hashtable</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Each value is the value of one of the keys in <tt><i>hashtable</i></tt>.
Duplicate values are not removed.
The values may appear in any order in the returned vector.
If <tt><i>size</i></tt> is specified, then it must be an exact, nonnegative integer; the
result vector will contain <tt>(min&nbsp;<i>size</i>&nbsp;(hashtable-size&nbsp;<i>hashtable</i>))</tt> elements.
Different calls to <tt>hashtable-values</tt>
with a <tt><i>size</i></tt> less than <tt>(hashtable-size&nbsp;<i>hashtable</i>)</tt>
may return different subsets of <tt><i>hashtable</i></tt>'s values.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(define&nbsp;p1&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(define&nbsp;p2&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(hashtable-set!&nbsp;ht&nbsp;p1&nbsp;"one")<br>

(hashtable-set!&nbsp;ht&nbsp;p2&nbsp;"two")<br>

(hashtable-set!&nbsp;ht&nbsp;'q&nbsp;"two")<br>

(hashtable-values&nbsp;ht)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#("one"&nbsp;"two"&nbsp;"two")&nbsp;<i>or&nbsp;any&nbsp;permutation</i><br>

(hashtable-values&nbsp;ht&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#("one")&nbsp;<i>or</i>&nbsp;#("two")</tt>
<p>This procedure is equivalent to calling <tt>hashtable-entries</tt> and returning only
the second result, but it is more efficient since the separate vector of keys need
not be created.

<p>
<a name="./objects:s155"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-entries&nbsp;<i>hashtable</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(hashtable-entries&nbsp;<i>hashtable</i>&nbsp;<i>size</i>)</tt></span>
<br>
<b>returns: </b>two vectors containing the keys and values in <tt><i>hashtable</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Identical to the Revised<sup>6</sup> Report counterpart, but allowing an optional
<tt><i>size</i></tt> argument.
If <tt><i>size</i></tt> is specified, then it must be an exact, nonnegative integer; the
result vectors will each contain <tt>(min&nbsp;<i>size</i>&nbsp;(hashtable-size&nbsp;<i>hashtable</i>))</tt> elements.
Different calls to <tt>hashtable-entries</tt>
with a <tt><i>size</i></tt> less than <tt>(hashtable-size&nbsp;<i>hashtable</i>)</tt>
may return different subsets of <tt><i>hashtable</i></tt>'s entries.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(hashtable-set!&nbsp;ht&nbsp;'a&nbsp;"one")<br>

(hashtable-set!&nbsp;ht&nbsp;'b&nbsp;"two")<br>

(hashtable-entries&nbsp;ht)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#(a&nbsp;b)&nbsp;#("one"&nbsp;"two")&nbsp;<i>or&nbsp;the&nbsp;other&nbsp;permutation</i><br>

(hashtable-entries&nbsp;ht&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#(a)&nbsp;#("one")&nbsp;<i>or</i>&nbsp;#(b)&nbsp;#("two")&nbsp;</tt>
<p><a name="./objects:s156"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-cells&nbsp;<i>hashtable</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(hashtable-cells&nbsp;<i>hashtable</i>&nbsp;<i>size</i>)</tt></span>
<br>
<b>returns: </b>a vector of up to <tt><i>size</i></tt> elements containing the cells of <tt><i>hashtable</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be a mutable hashtable.

<p>
Each element of the result vector is the value of one of the cells in <tt><i>hashtable</i></tt>.
The cells may appear in any order in the returned vector.
If <tt><i>size</i></tt> is specified, then it must be an exact, nonnegative integer; the
result vector will contain <tt>(min&nbsp;<i>size</i>&nbsp;(hashtable-size&nbsp;<i>hashtable</i>))</tt> elements.
If <tt><i>size</i></tt> is not specified, then the result vector has <tt>(hashtable-size&nbsp;<i>hashtable</i>)</tt> elements.
Different calls to <tt>hashtable-cells</tt>
with a <tt><i>size</i></tt> less than <tt>(hashtable-size&nbsp;<i>hashtable</i>)</tt>
may return different subsets of <tt><i>hashtable</i></tt>'s cells.

<p>
Changing the cdr of a pair in the result vector effectively updates
the table to associate car of the pair with a new value. The car of a
pair in the result vector should not be changed.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eqv-hashtable))<br>

(hashtable-set!&nbsp;ht&nbsp;1&nbsp;'one)<br>

(hashtable-set!&nbsp;ht&nbsp;2&nbsp;'two)<br>

(hashtable-cells&nbsp;ht)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#((1&nbsp;.&nbsp;one)&nbsp;(2&nbsp;.&nbsp;two))&nbsp;<i>or</i>&nbsp;#((2&nbsp;.&nbsp;two)&nbsp;(1&nbsp;.&nbsp;one))<br>

(hashtable-cells&nbsp;ht&nbsp;1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#((1&nbsp;.&nbsp;one))&nbsp;<i>or</i>&nbsp;#((2&nbsp;.&nbsp;two))<br>

(hashtable-cells&nbsp;ht&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#()</tt>
<p><a name="./objects:s157"></a><span class=formdef><b>procedure</b>: <tt>(make-weak-eq-hashtable)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-weak-eq-hashtable&nbsp;<i>size</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-weak-eqv-hashtable)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-weak-eqv-hashtable&nbsp;<i>size</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-weak-hashtable&nbsp;<i>hash</i>&nbsp;<i>equiv?</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-weak-hashtable&nbsp;<i>hash</i>&nbsp;<i>equiv?</i>&nbsp;<i>size</i>)</tt></span>
<br>
<b>returns: </b>a new weak hashtable
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Like the Revised<sup>6</sup> Report procedures <tt>make-eq-hashtable</tt>,
<tt>make-eqv-hashtable</tt>, and <tt>make-hashtable</tt>,
except the keys of the hashtable are held weakly, i.e., they are not
protected from the garbage collector.
Keys reclaimed by the garbage collector are removed from the table,
and their associated values are dropped the next time the table
is modified, if not sooner.

<p>
Values in the hashtable are referenced normally as long as the key is
not reclaimed, since keys are paired values using weak pairs. Consequently,
if a value in the hashtable refers to its own key, then
garbage collection is prevented from reclaiming the key. See
<tt>make-ephemeron-hashtable</tt> and related functions.

<p>
A copy of a weak hashtable created by <tt>hashtable-copy</tt> is
also weak.
If the copy is immutable, inaccessible keys may still be dropped from the
hashtable, even though the contents of the table is otherwise unchanging.
The effect of this can be observed via <tt>hashtable-keys</tt> and
<tt>hashtable-entries</tt>.

<p>

<p><tt>(define&nbsp;ht1&nbsp;(make-weak-eq-hashtable))<br>

(define&nbsp;ht2&nbsp;(make-weak-eq-hashtable&nbsp;32))</tt>
<p><a name="./objects:s158"></a><span class=formdef><b>procedure</b>: <tt>(make-ephemeron-eq-hashtable)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-ephemeron-eq-hashtable&nbsp;<i>size</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-ephemeron-eqv-hashtable)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-ephemeron-eqv-hashtable&nbsp;<i>size</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-ephemeron-hashtable&nbsp;<i>hash</i>&nbsp;<i>equiv?</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-ephemeron-hashtable&nbsp;<i>hash</i>&nbsp;<i>equiv?</i>&nbsp;<i>size</i>)</tt></span>
<br>
<b>returns: </b>a new ephemeron hashtable
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Like <tt>make-weak-eq-hashtable</tt>,
<tt>make-weak-eqv-hashtable</tt>, and <tt>make-weak-hashtable</tt>,
but a value in the hashtable can refer to a
key in the hashtable (directly or indirectly) without preventing garbage collection from
reclaiming the key, because keys are paired with values using ephemeron pairs.

<p>
A copy of an ephemeron hashtable created by
<tt>hashtable-copy</tt> is also an ephemeron table, and an inaccessible
key can be dropped from an immutable ephemeron hashtable in the same
way as for an immutable weak hashtable.

<p>

<p><tt>(define&nbsp;ht1&nbsp;(make-ephemeron-eq-hashtable))<br>

(define&nbsp;ht2&nbsp;(make-ephemeron-eq-hashtable&nbsp;32))</tt>
<p><a name="./objects:s159"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-weak?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a weak hashtable, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>(define&nbsp;ht1&nbsp;(make-weak-eq-hashtable))<br>

(define&nbsp;ht2&nbsp;(hashtable-copy&nbsp;ht1))<br>

(hashtable-weak?&nbsp;ht2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s160"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-ephemeron?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an ephemeron hashtable, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>(define&nbsp;ht1&nbsp;(make-ephemeron-eq-hashtable))<br>

(define&nbsp;ht2&nbsp;(hashtable-copy&nbsp;ht1))<br>

(hashtable-ephemeron?&nbsp;ht2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s161"></a><span class=formdef><b>procedure</b>: <tt>(eq-hashtable?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an eq hashtable, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>
<p><tt>
(eq-hashtable?&nbsp;(make-eq-hashtable))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(eq-hashtable?&nbsp;'(not&nbsp;a&nbsp;hash&nbsp;table))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s162"></a><span class=formdef><b>procedure</b>: <tt>(eq-hashtable-weak?&nbsp;<i>hashtable</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>hashtable</i></tt> is weak, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be an eq hashtable.

<p>

<p><tt>(eq-hashtable-weak?&nbsp;(make-eq-hashtable))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq-hashtable-weak?&nbsp;(make-weak-eq-hashtable))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s163"></a><span class=formdef><b>procedure</b>: <tt>(eq-hashtable-ephemeron?&nbsp;<i>hashtable</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>hashtable</i></tt> uses ephemeron pairs, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be an eq hashtable.

<p>

<p><tt>(eq-hashtable-ephemeron?&nbsp;(make-eq-hashtable))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq-hashtable-ephemeron?&nbsp;(make-ephemeron-eq-hashtable))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s164"></a><span class=formdef><b>procedure</b>: <tt>(eq-hashtable-set!&nbsp;<i>hashtable</i>&nbsp;<i>key</i>&nbsp;<i>value</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be a mutable eq hashtable.
<tt><i>key</i></tt> and <tt><i>value</i></tt> may be any Scheme values.

<p>
<tt>eq-hashtable-set!</tt> associates the value
<tt><i>value</i></tt> with the key <tt><i>key</i></tt> in <tt><i>hashtable</i></tt>.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(eq-hashtable-set!&nbsp;ht&nbsp;'a&nbsp;73)</tt>
<p><a name="./objects:s165"></a><span class=formdef><b>procedure</b>: <tt>(eq-hashtable-ref&nbsp;<i>hashtable</i>&nbsp;<i>key</i>&nbsp;<i>default</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be an eq hashtable.
<tt><i>key</i></tt> and <tt><i>default</i></tt> may be any Scheme values.

<p>
<tt>eq-hashtable-ref</tt> returns the value
associated with <tt><i>key</i></tt> in <tt><i>hashtable</i></tt>.
If no value is associated with <tt><i>key</i></tt> in <tt><i>hashtable</i></tt>,
<tt>eq-hashtable-ref</tt> returns <tt><i>default</i></tt>.


<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(define&nbsp;p1&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(define&nbsp;p2&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(eq-hashtable-set!&nbsp;ht&nbsp;p1&nbsp;73)<br>

(eq-hashtable-ref&nbsp;ht&nbsp;p1&nbsp;55)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;73<br>

(eq-hashtable-ref&nbsp;ht&nbsp;p2&nbsp;55)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;55</tt>
<p><a name="./objects:s166"></a><span class=formdef><b>procedure</b>: <tt>(eq-hashtable-contains?&nbsp;<i>hashtable</i>&nbsp;<i>key</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if an association for <tt><i>key</i></tt> exists in <tt><i>hashtable</i></tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be an eq hashtable.
<tt><i>key</i></tt> may be any Scheme value.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(define&nbsp;p1&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(define&nbsp;p2&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(eq-hashtable-set!&nbsp;ht&nbsp;p1&nbsp;73)<br>

(eq-hashtable-contains?&nbsp;ht&nbsp;p1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(eq-hashtable-contains?&nbsp;ht&nbsp;p2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s167"></a><span class=formdef><b>procedure</b>: <tt>(eq-hashtable-update!&nbsp;<i>hashtable</i>&nbsp;<i>key</i>&nbsp;<i>procedure</i>&nbsp;<i>default</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be a mutable eq hashtable.
<tt><i>key</i></tt> and <tt><i>default</i></tt> may be any Scheme values.
<tt><i>procedure</i></tt> should accept one argument, should return one value, and
should not modify <tt><i>hashtable</i></tt>.

<p>
<tt>eq-hashtable-update!</tt> applies <tt><i>procedure</i></tt> to the value associated with
<tt><i>key</i></tt> in <tt><i>hashtable</i></tt>, or to <tt><i>default</i></tt> if no value is associated with
<tt><i>key</i></tt> in <tt><i>hashtable</i></tt>.
If <tt><i>procedure</i></tt> returns, <tt>eq-hashtable-update!</tt> associates <tt><i>key</i></tt>
with the value returned by <tt><i>procedure</i></tt>, replacing the old association,
if any.

<p>
A version of <tt>eq-hashtable-update!</tt> that does not verify that it receives
arguments of the proper type might be defined as follows.

<p>

<p><tt>(define&nbsp;eq-hashtable-update!<br>

&nbsp;&nbsp;(lambda&nbsp;(ht&nbsp;key&nbsp;proc&nbsp;value)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(eq-hashtable-set!&nbsp;ht&nbsp;key<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(proc&nbsp;(eq-hashtable-ref&nbsp;ht&nbsp;key&nbsp;value)))))</tt>
<p>An implementation may, however, be able to implement
<tt>eq-hashtable-update!</tt> more efficiently by avoiding multiple
hash computations and hashtable lookups.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(eq-hashtable-update!&nbsp;ht&nbsp;'a<br>

&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(*&nbsp;x&nbsp;2))<br>

&nbsp;&nbsp;55)<br>

(eq-hashtable-ref&nbsp;ht&nbsp;'a&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;110<br>

(eq-hashtable-update!&nbsp;ht&nbsp;'a<br>

&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(*&nbsp;x&nbsp;2))<br>

&nbsp;&nbsp;0)<br>

(eq-hashtable-ref&nbsp;ht&nbsp;'a&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;220</tt>
<p><a name="./objects:s168"></a><span class=formdef><b>procedure</b>: <tt>(eq-hashtable-cell&nbsp;<i>hashtable</i>&nbsp;<i>key</i>&nbsp;<i>default</i>)</tt></span>
<br>
<b>returns: </b>a pair (see below)
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be a mutable eq hashtable.
<tt><i>key</i></tt> and <tt><i>default</i></tt> may be any Scheme values.

<p>
If no value is associated with <tt><i>key</i></tt> in <tt><i>hashtable</i></tt>,
<tt>eq-hashtable-cell</tt> modifies <tt><i>hashtable</i></tt> to associate <tt><i>key</i></tt> with
<tt><i>default</i></tt>.
It returns a pair whose car is <tt><i>key</i></tt> and whose cdr is
the associated value.
Changing the cdr of this pair effectively updates the table to
associate <tt><i>key</i></tt> with a new value.
The <tt><i>key</i></tt> should not be changed.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(define&nbsp;v&nbsp;(vector&nbsp;'a&nbsp;'b&nbsp;'c))<br>

(define&nbsp;cell&nbsp;(eq-hashtable-cell&nbsp;ht&nbsp;v&nbsp;3))<br>

cell&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(#(a&nbsp;b&nbsp;c)&nbsp;.&nbsp;3)<br>

(eq-hashtable-ref&nbsp;ht&nbsp;v&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(set-cdr!&nbsp;cell&nbsp;4)<br>

(eq-hashtable-ref&nbsp;ht&nbsp;v&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4</tt>
<p><a name="./objects:s169"></a><span class=formdef><b>procedure</b>: <tt>(eq-hashtable-try-atomic-cell&nbsp;<i>hashtable</i>&nbsp;<i>key</i>&nbsp;<i>default</i>)</tt></span>
<br>
<b>returns: </b>a pair or <tt>#f</tt> (see below)
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Like <tt>eq-hashtable-cell</tt>, but safe for use from multiple
threads at the same time as long as only this function,
<tt>eq-hashtable-ref</tt>, <tt>eq-hashtable-ref-cell</tt>,
and <tt>eq-hashtable-contains?</tt> are used on a
particular hash table by any thread. To handle certain forms of
contention, the result may be <tt>#f</tt>, in which case the operation
might be retried. An even more significant constraint is that the hash
table will not be resized interally as needed to provide constant-time
behavior. Use <tt>eq-hashtable-set!</tt> or a similar operation from a
single thread (e.g., during a collect-reqest handler) to allow the
opportunity of resizing.

<p>
<a name="./objects:s170"></a><span class=formdef><b>procedure</b>: <tt>(eq-hashtable-ref-cell&nbsp;<i>hashtable</i>&nbsp;<i>key</i>)</tt></span>
<br>
<b>returns: </b>a pair if <tt><i>key</i></tt> is in <tt><i>hashtable</i></tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be a mutable eq hashtable.
<tt><i>key</i></tt> may be any Scheme value.

<p>
If <tt><i>key</i></tt> is associated with a value in <tt><i>hashtable</i></tt>, then <tt>eq-hashtable-ref-cell</tt> returns a pair
whose car is <tt><i>key</i></tt> and whose cdr is the associated value. Changing the cdr of
this pair effectively updates the table to associate <tt><i>key</i></tt> with a new value.
The <tt><i>key</i></tt> in the car field should not be changed.

<p>
If <tt><i>key</i></tt> is not in <tt><i>hashtable</i></tt>, then <tt>#f</tt> is returned.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(define&nbsp;v&nbsp;(vector&nbsp;'a&nbsp;'b&nbsp;'c))<br>

(eq-hashtable-ref-cell&nbsp;ht&nbsp;v)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq-hashtable-set!&nbsp;ht&nbsp;v&nbsp;3)<br>

(define&nbsp;cell&nbsp;(eq-hashtable-ref-cell&nbsp;ht&nbsp;v))<br>

cell&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;((#a&nbsp;b&nbsp;c)&nbsp;.&nbsp;3)<br>

(eq-hashtable-ref&nbsp;ht&nbsp;v&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(set-cdr!&nbsp;cell&nbsp;4)<br>

(eq-hashtable-ref&nbsp;ht&nbsp;v&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4</tt>
<p><a name="./objects:s171"></a><span class=formdef><b>procedure</b>: <tt>(eq-hashtable-delete!&nbsp;<i>hashtable</i>&nbsp;<i>key</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be a mutable eq hashtable.
<tt><i>key</i></tt> may be any Scheme value.

<p>
<tt>eq-hashtable-delete!</tt> drops any association
for <tt><i>key</i></tt> from <tt><i>hashtable</i></tt>.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(define&nbsp;p1&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(define&nbsp;p2&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(eq-hashtable-set!&nbsp;ht&nbsp;p1&nbsp;73)<br>

(eq-hashtable-contains?&nbsp;ht&nbsp;p1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(eq-hashtable-delete!&nbsp;ht&nbsp;p1)<br>

(eq-hashtable-contains?&nbsp;ht&nbsp;p1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq-hashtable-contains?&nbsp;ht&nbsp;p2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq-hashtable-delete!&nbsp;ht&nbsp;p2)</tt>
<p><a name="./objects:s172"></a><span class=formdef><b>procedure</b>: <tt>(symbol-hashtable?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a symbol hashtable, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A symbol hashtable is a hashtable created with hash function <tt>symbol-hash</tt>
and equivalence function <tt>eq?</tt>, <tt>eqv?</tt>, <tt>equal?</tt>, or
<tt>symbol=?</tt>.

<p>

<p><tt>(symbol-hashtable?&nbsp;(make-hashtable&nbsp;symbol-hash&nbsp;eq?))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(symbol-hashtable?&nbsp;(make-eq-hashtable))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s173"></a><span class=formdef><b>procedure</b>: <tt>(symbol-hashtable-set!&nbsp;<i>hashtable</i>&nbsp;<i>key</i>&nbsp;<i>value</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be a mutable symbol hashtable.
(A symbol hashtable is a hashtable created with hash function <tt>symbol-hash</tt>
and equivalence function <tt>eq?</tt>, <tt>eqv?</tt>, <tt>equal?</tt>, or <tt>symbol=?</tt>.)
<tt><i>key</i></tt> must be a symbol, and <tt><i>value</i></tt> may be any Scheme value.

<p>
<tt>symbol-hashtable-set!</tt> associates the value
<tt><i>value</i></tt> with the key <tt><i>key</i></tt> in <tt><i>hashtable</i></tt>.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-hashtable&nbsp;symbol-hash&nbsp;eq?))<br>

(symbol-hashtable-ref&nbsp;ht&nbsp;'a&nbsp;#f)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(symbol-hashtable-set!&nbsp;ht&nbsp;'a&nbsp;73)<br>

(symbol-hashtable-ref&nbsp;ht&nbsp;'a&nbsp;#f)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;73</tt>
<p><a name="./objects:s174"></a><span class=formdef><b>procedure</b>: <tt>(symbol-hashtable-ref&nbsp;<i>hashtable</i>&nbsp;<i>key</i>&nbsp;<i>default</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be a symbol hashtable.
(A symbol hashtable is a hashtable created with hash function <tt>symbol-hash</tt>
and equivalence function <tt>eq?</tt>, <tt>eqv?</tt>, <tt>equal?</tt>, or <tt>symbol=?</tt>.)
<tt><i>key</i></tt> must be a symbol, and <tt><i>default</i></tt> may be any Scheme value.

<p>
<tt>symbol-hashtable-ref</tt> returns the value
associated with <tt><i>key</i></tt> in <tt><i>hashtable</i></tt>.
If no value is associated with <tt><i>key</i></tt> in <tt><i>hashtable</i></tt>,
<tt>symbol-hashtable-ref</tt> returns <tt><i>default</i></tt>.


<p>

<p><tt>(define&nbsp;ht&nbsp;(make-hashtable&nbsp;symbol-hash&nbsp;eq?))<br>

(define&nbsp;k1&nbsp;'abcd)<br>

(define&nbsp;k2&nbsp;'not-abcd)<br>

(symbol-hashtable-set!&nbsp;ht&nbsp;k1&nbsp;"hi")<br>

(symbol-hashtable-ref&nbsp;ht&nbsp;k1&nbsp;"bye")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"hi"<br>

(symbol-hashtable-ref&nbsp;ht&nbsp;k2&nbsp;"bye")&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"bye"</tt>
<p><a name="./objects:s175"></a><span class=formdef><b>procedure</b>: <tt>(symbol-hashtable-contains?&nbsp;<i>hashtable</i>&nbsp;<i>key</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if an association for <tt><i>key</i></tt> exists in <tt><i>hashtable</i></tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be a symbol hashtable.
(A symbol hashtable is a hashtable created with hash function <tt>symbol-hash</tt>
and equivalence function <tt>eq?</tt>, <tt>eqv?</tt>, <tt>equal?</tt>, or <tt>symbol=?</tt>.)
<tt><i>key</i></tt> must be a symbol.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-hashtable&nbsp;symbol-hash&nbsp;eq?))<br>

(define&nbsp;k1&nbsp;'abcd)<br>

(define&nbsp;k2&nbsp;'not-abcd)<br>

(symbol-hashtable-set!&nbsp;ht&nbsp;k1&nbsp;"hi")<br>

(symbol-hashtable-contains?&nbsp;ht&nbsp;k1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(symbol-hashtable-contains?&nbsp;ht&nbsp;k2&nbsp;)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s176"></a><span class=formdef><b>procedure</b>: <tt>(symbol-hashtable-update!&nbsp;<i>hashtable</i>&nbsp;<i>key</i>&nbsp;<i>procedure</i>&nbsp;<i>default</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be a mutable symbol hashtable.
(A symbol hashtable is a hashtable created with hash function <tt>symbol-hash</tt>
and equivalence function <tt>eq?</tt>, <tt>eqv?</tt>, <tt>equal?</tt>, or <tt>symbol=?</tt>.)
<tt><i>key</i></tt> must be a symbol, and <tt><i>default</i></tt> may be any Scheme value.
<tt><i>procedure</i></tt> should accept one argument, should return one value, and
should not modify <tt><i>hashtable</i></tt>.

<p>
<tt>symbol-hashtable-update!</tt> applies <tt><i>procedure</i></tt> to the value associated with
<tt><i>key</i></tt> in <tt><i>hashtable</i></tt>, or to <tt><i>default</i></tt> if no value is associated with
<tt><i>key</i></tt> in <tt><i>hashtable</i></tt>.
If <tt><i>procedure</i></tt> returns, <tt>symbol-hashtable-update!</tt> associates <tt><i>key</i></tt>
with the value returned by <tt><i>procedure</i></tt>, replacing the old association,
if any.

<p>
A version of <tt>symbol-hashtable-update!</tt> that does not verify that it receives
arguments of the proper type might be defined as follows.

<p>

<p><tt>(define&nbsp;symbol-hashtable-update!<br>

&nbsp;&nbsp;(lambda&nbsp;(ht&nbsp;key&nbsp;proc&nbsp;value)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(symbol-hashtable-set!&nbsp;ht&nbsp;key<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(proc&nbsp;(symbol-hashtable-ref&nbsp;ht&nbsp;key&nbsp;value)))))</tt>
<p>An implementation may, however, be able to implement
<tt>symbol-hashtable-update!</tt> more efficiently by avoiding multiple
hash computations and hashtable lookups.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-hashtable&nbsp;symbol-hash&nbsp;eq?))<br>

(symbol-hashtable-update!&nbsp;ht&nbsp;'a<br>

&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(*&nbsp;x&nbsp;2))<br>

&nbsp;&nbsp;55)<br>

(symbol-hashtable-ref&nbsp;ht&nbsp;'a&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;110<br>

(symbol-hashtable-update!&nbsp;ht&nbsp;'a<br>

&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(*&nbsp;x&nbsp;2))<br>

&nbsp;&nbsp;0)<br>

(symbol-hashtable-ref&nbsp;ht&nbsp;'a&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;220</tt>
<p><a name="./objects:s177"></a><span class=formdef><b>procedure</b>: <tt>(symbol-hashtable-cell&nbsp;<i>hashtable</i>&nbsp;<i>key</i>&nbsp;<i>default</i>)</tt></span>
<br>
<b>returns: </b>a pair (see below)
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be a mutable symbol hashtable.
(A symbol hashtable is a hashtable created with hash function <tt>symbol-hash</tt>
and equivalence function <tt>eq?</tt>, <tt>eqv?</tt>, <tt>equal?</tt>, or <tt>symbol=?</tt>.)
<tt><i>key</i></tt> must be a symbol, and <tt><i>default</i></tt> may be any Scheme value.

<p>
If no value is associated with <tt><i>key</i></tt> in <tt><i>hashtable</i></tt>,
<tt>symbol-hashtable-cell</tt> modifies <tt><i>hashtable</i></tt> to associate <tt><i>key</i></tt> with
<tt><i>default</i></tt>.
It returns a pair whose car is <tt><i>key</i></tt> and whose cdr is
the associated value.
Changing the cdr of this pair effectively updates the table to
associate <tt><i>key</i></tt> with a new value.
The <tt><i>key</i></tt> should not be changed.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-hashtable&nbsp;symbol-hash&nbsp;eq?))<br>

(define&nbsp;k&nbsp;'a-key)<br>

(define&nbsp;cell&nbsp;(symbol-hashtable-cell&nbsp;ht&nbsp;k&nbsp;3))<br>

cell&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(a-key&nbsp;.&nbsp;3)<br>

(symbol-hashtable-ref&nbsp;ht&nbsp;k&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(set-cdr!&nbsp;cell&nbsp;4)<br>

(symbol-hashtable-ref&nbsp;ht&nbsp;k&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4</tt>
<p><a name="./objects:s178"></a><span class=formdef><b>procedure</b>: <tt>(symbol-hashtable-ref-cell&nbsp;<i>hashtable</i>&nbsp;<i>key</i>)</tt></span>
<br>
<b>returns: </b>a pair if <tt><i>key</i></tt> is in <tt><i>hashtable</i></tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be a mutable symbol hashtable.
(A symbol hashtable is a hashtable created with hash function <tt>symbol-hash</tt>
and equivalence function <tt>eq?</tt>, <tt>eqv?</tt>, <tt>equal?</tt>, or <tt>symbol=?</tt>.)
<tt><i>key</i></tt> must be a symbol.

<p>
If <tt><i>key</i></tt> is associated with a value in <tt><i>hashtable</i></tt>, then it returns a pair
whose car is <tt><i>key</i></tt> and whose cdr is the associated value. Changing the cdr of
this pair effectively updates the table to associate <tt><i>key</i></tt> with a new value.
The <tt><i>key</i></tt> in the car field should not be changed.

<p>
If <tt><i>key</i></tt> is not in <tt><i>hashtable</i></tt>, then <tt>#f</tt> is returned.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-hashtable&nbsp;symbol-hash&nbsp;eq?))<br>

(define&nbsp;k&nbsp;'a-key)<br>

(symbol-hashtable-ref-cell&nbsp;ht&nbsp;k)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(symbol-hashtable-set!&nbsp;ht&nbsp;k&nbsp;3)<br>

(define&nbsp;cell&nbsp;(symbol-hashtable-ref-cell&nbsp;ht&nbsp;k))<br>

cell&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(a-key&nbsp;.&nbsp;3)<br>

(symbol-hashtable-ref&nbsp;ht&nbsp;k&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(set-cdr!&nbsp;cell&nbsp;4)<br>

(symbol-hashtable-ref&nbsp;ht&nbsp;k&nbsp;0)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;4</tt>
<p><a name="./objects:s179"></a><span class=formdef><b>procedure</b>: <tt>(symbol-hashtable-delete!&nbsp;<i>hashtable</i>&nbsp;<i>key</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>hashtable</i></tt> must be a mutable symbol hashtable.
(A symbol hashtable is a hashtable created with hash function <tt>symbol-hash</tt>
and equivalence function <tt>eq?</tt>, <tt>eqv?</tt>, <tt>equal?</tt>, or <tt>symbol=?</tt>.)
<tt><i>key</i></tt> must be a symbol.

<p>
<tt>symbol-hashtable-delete!</tt> drops any association
for <tt><i>key</i></tt> from <tt><i>hashtable</i></tt>.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-hashtable&nbsp;symbol-hash&nbsp;eq?))<br>

(define&nbsp;k1&nbsp;(gensym))<br>

(define&nbsp;k2&nbsp;(gensym))<br>

(symbol-hashtable-set!&nbsp;ht&nbsp;k1&nbsp;73)<br>

(symbol-hashtable-contains?&nbsp;ht&nbsp;k1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(symbol-hashtable-delete!&nbsp;ht&nbsp;k1)<br>

(symbol-hashtable-contains?&nbsp;ht&nbsp;k1)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(symbol-hashtable-contains?&nbsp;ht&nbsp;k2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(symbol-hashtable-delete!&nbsp;ht&nbsp;k2)</tt>
<p>
<h3><a name="g63"></a><a name="./objects:h15"></a>Section 7.15. Record Types<a name="SECTR6RSRECORDS"></a></h3>



<p>
<a name="./objects:s180"></a><a name="./objects:s181"></a>Chez Scheme extends the Revised<sup>6</sup> Report's <tt>define-record-type</tt>
syntax in one way, which is that it allows a generative record type
to be declared explicitly as such (in a double-negative sort of way)
by including a <tt>nongenerative</tt> clause with <tt>#f</tt> as the
uid, i.e.:

<p>

<p><tt>(nongenerative&nbsp;#f)</tt>
<p>This can be used in conjunction with the parameter
<tt>require-nongenerative-clause</tt> to catch the accidental use of
generative record types while avoiding spurious errors for record types
that must be generative.
Generative record types are rarely needed and are generally less
efficient since a run-time representation of the type is created each
time the <tt>define-record-clause</tt> is evaluated, rather than once
at compile (expansion) time.

<p>
<a name="./objects:s182"></a><span class=formdef><b>thread parameter</b>: <tt>require-nongenerative-clause</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This parameter holds a boolean value that determines whether
<a name="./objects:s183"></a><tt>define-record-type</tt>
requires a nongenerative clause.
The default value is <tt>#f</tt>.
The lead-in above describes why one might want to set this to <tt>#t</tt>.

<p>

<h3><a name="g64"></a><a name="./objects:h16"></a>Section 7.16. Record Equality and Hashing<a name="SECTRECORDEQUALTYANDHASHING"></a></h3>



<p>
<a name="./objects:s184"></a><a name="./objects:s185"></a>By default, the <a name="./objects:s186"></a><tt>equal?</tt> primitive
compares record instances using <tt>eq?</tt>, i.e., it distinguishes
non-eq? instances even if they are of the same type and have equal
contents.
A program can override this behavior for instances of a
record type (and its subtypes that do not have their own equality
procedures) by using
<a name="./objects:s187"></a><tt>record-type-equal-procedure</tt>
to associate an equality procedure with the record-type descriptor
(<tt><i>rtd</i></tt>) that describes the record type.

<p>
When comparing two eq? instances, <tt>equal?</tt> always returns
<tt>#t</tt>.
When comparing two non-eq? instances that share an equality procedure
<tt><i>equal-proc</i></tt>, <tt>equal?</tt> uses <tt><i>equal-proc</i></tt> to compare
the instances.
Two instances <tt><i>x</i></tt> and <tt><i>y</i></tt> share an equality procedure if
they inherit an equality procedure from the same point in the inheritance
chain, i.e., if
<a name="./objects:s188"></a><tt>(record-equal-procedure&nbsp;<i>x</i>&nbsp;<i>y</i>)</tt>
returns a procedure (<tt><i>equal-proc</i></tt>) rather
than <tt>#f</tt>.
<tt><i>equal?</i></tt> passes <tt><i>equal-proc</i></tt> three arguments: the two
instances plus a <tt><i>eql?</i></tt> procedure that should be used for
recursive comparison of values within the two instances.
Use of <tt><i>eql?</i></tt> for recursive comparison is necessary to allow
comparison of potentially cyclic structure.
When comparing two non-eq? instances that do not share an equality
procedure, <tt>equal?</tt> returns <tt>#f</tt>.

<p>
A default equality procedure to be used for all record types (including
opaque types) can be specified via the parameter
<a name="./objects:s189"></a><tt>default-record-equal-procedure</tt>.
The default equality procedure is used only if neither instance's type has or inherits
a type-specific record equality procedure.

<p>
<a name="./objects:s190"></a><a name="./objects:s191"></a>Similarly, when the <a name="./objects:s192"></a><tt>equal-hash</tt>
primitive hashes a record instance, it defaults to a value that is
independent of the record type and contents of the instance.
A program can override this behavior for instances of a
record type by using <a name="./objects:s193"></a><tt>record-type-hash-procedure</tt>
to associate a hash procedure with the record-type descriptor (<tt><i>rtd</i></tt>)
that describes the record type.
The procedure <a name="./objects:s194"></a><tt>record-hash-procedure</tt> can be used to find
the hash procedure for a given record instance, following the inheritance
chain.
<tt><i>equal-hash</i></tt> passes the hash procedure two arguments: the
instance plus a <tt><i>hash</i></tt> procedure that should be used for
recursive hashing of values within the instance.
Use of <tt><i>hash</i></tt> for recursive hashing is necessary to allow
hashing of potentially cyclic structure and to make the hashing
of shared structure more efficient.

<p>
A default hash procedure to be used for all record types (including
opaque types) can be specified via the parameter
<a name="./objects:s195"></a><tt>default-record-hash-procedure</tt>.
The default hash procedure is used only if an instance's type does not have or inherit
a type-specific hash procedure.

<p>
The following example illustrates the setting of equality and hash
procedures.

<p>

<p><tt>(define-record-type&nbsp;marble<br>

&nbsp;&nbsp;(nongenerative)<br>

&nbsp;&nbsp;(fields&nbsp;color&nbsp;quality))
<br>
<br>
(record-type-equal-procedure&nbsp;(record-type-descriptor&nbsp;marble))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(equal?&nbsp;(make-marble&nbsp;'blue&nbsp;'medium)&nbsp;(make-marble&nbsp;'blue&nbsp;'medium))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(equal?&nbsp;(make-marble&nbsp;'blue&nbsp;'medium)&nbsp;(make-marble&nbsp;'blue&nbsp;'high))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
;&nbsp;Treat&nbsp;marbles&nbsp;as&nbsp;equal&nbsp;when&nbsp;they&nbsp;have&nbsp;the&nbsp;same&nbsp;color<br>

(record-type-equal-procedure&nbsp;(record-type-descriptor&nbsp;marble)<br>

&nbsp;&nbsp;(lambda&nbsp;(m1&nbsp;m2&nbsp;eql?)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(eql?&nbsp;(marble-color&nbsp;m1)&nbsp;(marble-color&nbsp;m2))))<br>

(record-type-hash-procedure&nbsp;(record-type-descriptor&nbsp;marble)<br>

&nbsp;&nbsp;(lambda&nbsp;(m&nbsp;hash)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(hash&nbsp;(marble-color&nbsp;m))))
<br>
<br>
(equal?&nbsp;(make-marble&nbsp;'blue&nbsp;'medium)&nbsp;(make-marble&nbsp;'blue&nbsp;'high))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(equal?&nbsp;(make-marble&nbsp;'red&nbsp;'high)&nbsp;(make-marble&nbsp;'blue&nbsp;'high))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(define&nbsp;ht&nbsp;(make-hashtable&nbsp;equal-hash&nbsp;equal?))<br>

(hashtable-set!&nbsp;ht&nbsp;(make-marble&nbsp;'blue&nbsp;'medium)&nbsp;"glass")<br>

(hashtable-ref&nbsp;ht&nbsp;(make-marble&nbsp;'blue&nbsp;'high)&nbsp;#f)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"glass"
<br>
<br>
(define-record-type&nbsp;shooter<br>

&nbsp;&nbsp;(nongenerative)<br>

&nbsp;&nbsp;(parent&nbsp;marble)<br>

&nbsp;&nbsp;(fields&nbsp;size))
<br>
<br>
(equal?&nbsp;(make-marble&nbsp;'blue&nbsp;'medium)&nbsp;(make-shooter&nbsp;'blue&nbsp;'large&nbsp;17))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(equal?&nbsp;(make-shooter&nbsp;'blue&nbsp;'large&nbsp;17)&nbsp;(make-marble&nbsp;'blue&nbsp;'medium))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(hashtable-ref&nbsp;ht&nbsp;(make-shooter&nbsp;'blue&nbsp;'high&nbsp;17)&nbsp;#f)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"glass"</tt>
<p>This example illustrates the application of equality and hash procedures
to cyclic record structures.

<p>

<p><tt>(define-record-type&nbsp;node<br>

&nbsp;&nbsp;(nongenerative)<br>

&nbsp;&nbsp;(fields&nbsp;(mutable&nbsp;left)&nbsp;(mutable&nbsp;right)))
<br>
<br>
(record-type-equal-procedure&nbsp;(record-type-descriptor&nbsp;node)<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y&nbsp;e?)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(and<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e?&nbsp;(node-left&nbsp;x)&nbsp;(node-left&nbsp;y))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e?&nbsp;(node-right&nbsp;x)&nbsp;(node-right&nbsp;y)))))<br>

(record-type-hash-procedure&nbsp;(record-type-descriptor&nbsp;node)<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;hash)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(hash&nbsp;(node-left&nbsp;x))&nbsp;(hash&nbsp;(node-right&nbsp;x))&nbsp;23)))
<br>
<br>
(define&nbsp;graph1<br>

&nbsp;&nbsp;(let&nbsp;([x&nbsp;(make-node&nbsp;"a"&nbsp;(make-node&nbsp;#f&nbsp;"b"))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(node-left-set!&nbsp;(node-right&nbsp;x)&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;x))<br>

(define&nbsp;graph2<br>

&nbsp;&nbsp;(let&nbsp;([x&nbsp;(make-node&nbsp;"a"&nbsp;(make-node&nbsp;(make-node&nbsp;"a"&nbsp;#f)&nbsp;"b"))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(node-right-set!&nbsp;(node-left&nbsp;(node-right&nbsp;x))&nbsp;(node-right&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;x))<br>

(define&nbsp;graph3<br>

&nbsp;&nbsp;(let&nbsp;([x&nbsp;(make-node&nbsp;"a"&nbsp;(make-node&nbsp;#f&nbsp;"c"))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(node-left-set!&nbsp;(node-right&nbsp;x)&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;x))
<br>
<br>
(equal?&nbsp;graph1&nbsp;graph2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(equal?&nbsp;graph1&nbsp;graph3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(equal?&nbsp;graph2&nbsp;graph3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(define&nbsp;h&nbsp;(make-hashtable&nbsp;equal-hash&nbsp;equal?))<br>

(hashtable-set!&nbsp;h&nbsp;graph1&nbsp;#t)<br>

(hashtable-ref&nbsp;h&nbsp;graph1&nbsp;#f)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(hashtable-ref&nbsp;h&nbsp;graph2&nbsp;#f)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(hashtable-ref&nbsp;h&nbsp;graph3&nbsp;#f)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s196"></a><span class=formdef><b>procedure</b>: <tt>(record-type-equal-procedure&nbsp;<i>rtd</i>&nbsp;<i>equal-proc</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br><span class=formdef><b>procedure</b>: <tt>(record-type-equal-procedure&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>equality procedure associated with <tt><i>rtd</i></tt>, if any, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>In the first form, <tt><i>equal-proc</i></tt> must be a procedure or <tt>#f</tt>.
If <tt><i>equal-proc</i></tt> is a procedure, a new association between
<tt><i>rtd</i></tt> and <tt><i>equal-proc</i></tt> is established, replacing any existing
such association.
If <tt><i>equal-proc</i></tt> is <tt>#f</tt>, any existing association between
<tt><i>rtd</i></tt> and an equality procedure is dropped.

<p>
In the second form, <tt>record-type-equal-procedure</tt> returns
the equality procedure associated with <tt><i>rtd</i></tt>, if any, otherwise <tt>#f</tt>.

<p>
When changing a record type's equality procedure, the record type's
hash procedure, if any, should be updated if necessary to maintain
the property that it produces the same hash value for any two
instances the equality procedure considers equal.

<p>
<a name="./objects:s197"></a><span class=formdef><b>procedure</b>: <tt>(record-equal-procedure&nbsp;<i>record<sub>1</sub></i>&nbsp;<i>record<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the shared equality procedure for <tt><i>record<sub>1</sub></i></tt> and <tt><i>record<sub>2</sub></i></tt>, if there is one, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>record-equal-procedure</tt> traverses the inheritance chains
for both record instances in an attempt to find the most specific
type for each that is associated with an equality procedure, if any.
If such type is found and is the same for both instances, the
equality procedure associated with the type is returned.
Otherwise, <tt>#f</tt> is returned.

<p>
<a name="./objects:s198"></a><span class=formdef><b>procedure</b>: <tt>(record-type-hash-procedure&nbsp;<i>rtd</i>&nbsp;<i>hash-proc</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br><span class=formdef><b>procedure</b>: <tt>(record-type-hash-procedure&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>hash procedure associated with <tt><i>rtd</i></tt>, if any, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>In the first form, <tt><i>hash-proc</i></tt> must be a procedure or <tt>#f</tt>.
If <tt><i>hash-proc</i></tt> is a procedure, a new association between
<tt><i>rtd</i></tt> and <tt><i>hash-proc</i></tt> is established, replacing any existing
such association.
If <tt><i>hash-proc</i></tt> is <tt>#f</tt>, any existing association between
<tt><i>rtd</i></tt> and a hash procedure is dropped.

<p>
In the second form, <tt>record-type-hash-procedure</tt> returns
the hash procedure associated with <tt><i>rtd</i></tt>, if any, otherwise <tt>#f</tt>.

<p>
The procedure <tt><i>hash-proc</i></tt> should accept two arguments, the
instance for which it should compute a hash value and a hash procedure
to use to compute hash values for arbitrary fields of the instance,
and it returns a nonnegative exact integer.
A record type's hash procedure should produce the same hash value
for any two instances the record type's equality procedure considers
equal.

<p>
<a name="./objects:s199"></a><span class=formdef><b>procedure</b>: <tt>(record-hash-procedure&nbsp;<i>record</i>)</tt></span>
<br>
<b>returns: </b>the hash procedure for <tt><i>record</i></tt>, if there is one, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>record-hash-procedure</tt> traverses the inheritance chain
for the record instance in an attempt to find the most specific
type that is associated with a hash procedure, if any.
If such type is found, the hash procedure associated with the type
is returned.
Otherwise, <tt>#f</tt> is returned.

<p>
<a name="./objects:s200"></a><span class=formdef><b>thread parameter</b>: <tt>default-record-equal-procedure</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This parameter determines how two record instances are compared by
<tt>equal?</tt> if neither has a type-specific equality procedure.
When the parameter has the value <tt>#f</tt> (the default), <tt>equal?</tt>
compares the instances with <tt>eq?</tt>, i.e., there is no attempt at
determining structural equivalence.
Otherwise, the parameter's value must be a procedure, and <tt>equal?</tt>
invokes that procedure to compare the instances, passing it three arguments:
the two instances and a procedure that should be used to recursively
compare arbitrary values within the instances.

<p>
<a name="./objects:s201"></a><span class=formdef><b>thread parameter</b>: <tt>default-record-hash-procedure</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This parameter determines the hash procedure used when <tt>equal-hash</tt>
is called on a record instance and the instance does not have a type-specific
hash procedure.
When the parameter has the value <tt>#f</tt> (the default), <tt>equal-hash</tt>
returns a value that is independent of the record type and contents
of the instance.
Otherwise, the parameter's value must be a procedure, and <tt>equal-hash</tt>
invokes the procedure to compute the instance's hash value, passing it
the record instance and a procedure to invoke to recursively compute
hash values for arbitrary values contained within the record.
The procedure should return a nonnegative exact integer, and the
return value should be the same for any two instances the default
equal procedure considers equivalent.

<p>

<h3><a name="g65"></a><a name="./objects:h17"></a>Section 7.17. Legacy Record Types<a name="SECTCSV7RECORDS"></a></h3>



<p>
<a name="./objects:s202"></a><a name="./objects:s203"></a><a name="./objects:s204"></a>In addition to the Revised<sup>6</sup> Report record-type creation and definition
mechanisms, which are described in Chapter&nbsp;<a href="http://scheme.com/tspl4/./records.html#g138">9</a> of <i>The Scheme Programming Language, 4th Edition</i>,
<i>Chez&nbsp;Scheme</i> continues to support pre-R6RS mechanisms for creating new
data types, or <i>record types</i>, with fixed sets of named fields.
Many of the procedures described in this section are available only when
imported from the <tt>(chezscheme&nbsp;csv7)</tt> library.

<p>
Code intended to be portable should use the R6RS mechanism instead.

<p>
Records may be defined via the <tt>define-record</tt> syntactic form or
via the <tt>make-record-type</tt> procedure.
The underlying representation of records and record-type descriptors is the
same for the Revised<sup>6</sup> Report mechanism and the alternative mechanism.
Record types created by one can be used as parent record types for the
other via the procedural mechanisms, though not via the syntactic mechanisms.


<p>
The syntactic (<tt>define-record</tt>)
interface is the most commonly used interface.
Each <tt>define-record</tt> form defines a constructor
procedure for records of the new type, a type predicate that returns
true only for records of the new type, an access procedure for each field,
and an assignment procedure for each mutable field.
For example,

<p>

<p><tt>(define-record&nbsp;point&nbsp;(x&nbsp;y))</tt>
<p>creates a new <tt>point</tt> record type with two fields, <tt>x</tt>
and <tt>y</tt>, and defines the following procedures:

<p>
<TABLE><TR><TD nowrap align="left">
<tt>(make-point&nbsp;<i>x</i>&nbsp;<i>y</i>)</tt> </TD><TD nowrap align="left"> constructor</TD></TR><TR><TD nowrap align="left">
<tt>(point?&nbsp;<i>obj</i>)</tt> </TD><TD nowrap align="left"> predicate</TD></TR><TR><TD nowrap align="left">
<tt>(point-x&nbsp;<i>p</i>)</tt> </TD><TD nowrap align="left"> accessor for field <tt>x</tt></TD></TR><TR><TD nowrap align="left">
<tt>(point-y&nbsp;<i>p</i>)</tt> </TD><TD nowrap align="left"> accessor for field <tt>y</tt></TD></TR><TR><TD nowrap align="left">
<tt>(set-point-x!&nbsp;<i>p</i>&nbsp;<i>obj</i>)</tt> </TD><TD nowrap align="left"> mutator for field <tt>x</tt></TD></TR><TR><TD nowrap align="left">
<tt>(set-point-y!&nbsp;<i>p</i>&nbsp;<i>obj</i>)</tt> </TD><TD nowrap align="left"> mutator for field <tt>y</tt>
</TD></TR></TABLE>

<p>
The names of these procedures follow a regular naming convention by
default, but the programmer can override the defaults if desired.
<tt>define-record</tt> allows the programmer to control which fields
are arguments to the generated constructor procedure and which 
are explicitly initialized by the constructor procedure.
Fields are mutable by default, but may be declared immutable.
Fields can generally contain any Scheme value, but the internal
representation of each field may be specified, which places implicit
constraints on the type of value that may be stored there.
These customization options are covered in the formal description
of <tt>define-record</tt> later in this section.

<p>
The procedural (<tt>make-record-type</tt>) interface may be used to
implement interpreters that must handle <tt>define-record</tt> forms.
Each call to <tt>make-record-type</tt> returns a <i>record-type
descriptor</i> representing the record type.
Using this record-type descriptor, programs may generate constructors,
type predicates, field accessors, and field mutators dynamically.
The following code demonstrates how the procedural interface might
be used to create a similar <tt>point</tt> record type and associated
definitions.

<p>

<p><tt>(define&nbsp;point&nbsp;(make-record-type&nbsp;"point"&nbsp;'(x&nbsp;y)))<br>

(define&nbsp;make-point&nbsp;(record-constructor&nbsp;point))<br>

(define&nbsp;point?&nbsp;(record-predicate&nbsp;point))<br>

(define&nbsp;point-x&nbsp;(record-field-accessor&nbsp;point&nbsp;'x))<br>

(define&nbsp;point-y&nbsp;(record-field-accessor&nbsp;point&nbsp;'y))<br>

(define&nbsp;set-point-x!&nbsp;(record-field-mutator&nbsp;point&nbsp;'x))<br>

(define&nbsp;set-point-y!&nbsp;(record-field-mutator&nbsp;point&nbsp;'y))</tt>
<p>The procedural interface is more flexible than the syntactic interface,
but this flexibility can lead to less readable programs and
compromises the compiler's ability to generate efficient code.
Programmers should use the syntactic interface whenever it suffices.

<p>
A record-type descriptor may also be extracted from an instance
of a record type, whether the record type was produced by
<tt>define-record</tt> or <tt>make-record-type</tt>, and the extracted
descriptor may also be used to produce constructors, predicates,
accessors, and mutators, with a few limitations noted in the description
of <tt>record-type-descriptor</tt> below.
This is a powerful feature that permits the coding of portable printers
and object inspectors.
For example, the printer employs this feature in its default record
printer, and the inspector uses it to allow inspection and mutation of
system- and user-defined records during debugging.

<p>
<a name="./objects:s205"></a><a name="./objects:s206"></a>A parent record
may be specified in the <tt>define-record</tt> syntax or as an optional
argument to <tt>make-record-type</tt>.
A new record inherits the parent record's fields, and each instance
of the new record type is considered to be an instance of the parent
type as well, so that accessors and mutators for the parent type may
be used on instances of the new type.

<p>
<a name="./objects:s207"></a><a name="./objects:s208"></a>Record
type definitions may be classified as either generative or nongenerative.
A new type results for each <i>generative</i> record definition,
while only one type results for all occurrences of a given
<i>nongenerative</i> record definition.
This distinction is important semantically since record accessors
and setters are applicable only to objects with the same type.

<p>
Syntactic (<tt>define-record</tt>) record definitions are
<a name="./objects:s209"></a><i>expand-time generative</i> by default, which means that a new
record is created when the code is expanded.
Expansion happens once for each form prior to compilation or
interpretation, as when it is entered interactively, loaded from source,
or compiled by <tt>compile-file</tt>.
As a result, multiple evaluations of a single <tt>define-record</tt>
form, e.g., in the body of a procedure called multiple times, always
produce the same record type.

<p>
<a name="./objects:s210"></a>Separate <tt>define-record</tt> forms
usually produce different types, even if the forms are textually
identical.
The only exception occurs when the name of a record is specified as
a generated symbol, or <i>gensym</i> (page&nbsp;<a href="./objects.html#desc:gensym">171</a>).
Multiple copies of a record definition whose name is given by a gensym
always produce the same record type; i.e., such definitions are
nongenerative.
Each copy of the record definition must contain the same fields and field
modifiers in the same order; an exception is raised with condition-type
<tt>&amp;assertion</tt> when two differing
record types with the same generated name are loaded into the same
Scheme process.

<p>
Procedural (<tt>make-record-type</tt>) record definitions are
<a name="./objects:s211"></a><i>run-time generative</i> by default.
That is, each call to <tt>make-record-type</tt> usually produces a new
record type.
As with the syntactic interface,
the only exception occurs when the name of the record is specified
as a gensym, in which case the record type is
fully nongenerative.

<p>
By default, a record is printed with the syntax

<p>

<p><tt>#[<i>type-name</i>&nbsp;<i>field</i>&nbsp;...]</tt>
<p>where <tt><i>field</i>&nbsp;...</tt> are the printed representations of
the contents of the fields of the record, and
<tt><i>type-name</i></tt> is a generated symbol, or <i>gensym</i>
(page&nbsp;<a href="./objects.html#desc:gensym">171</a>), that uniquely identifies the record type.
For nongenerative records, <tt><i>type-name</i></tt> is the gensym
provided by the program.
Otherwise, it is a gensym whose "pretty" name
(page&nbsp;<a href="./objects.html#desc:gensym">171</a>) is the name given to the record by
<tt>define-record</tt> or <tt>make-record-type</tt>.

<p>
The default printing of records of a given type may be overridden
with <tt>record-writer</tt>.

<p>
The default syntax may be used as input to the reader as well, as long
as the corresponding record type has already been defined in the Scheme
session in which the read occurs.
The parameter <tt>record-reader</tt> may be used to specify a
different name to be recognized by the reader in place of the
generated name.
Specifying a different name in this manner also changes the name used
when the record is printed.
This reader extension is disabled in an input stream after <tt>#!r6rs</tt>
has been seen by the reader, unless <tt>#!chezscheme</tt> has been seen
more recently.

<p>
The mark (<tt>#<i>n</i>=</tt>) and reference (<tt>#<i>n</i>#</tt>)
syntaxes may be used within the record syntax, with the result
of creating shared or cyclic structure as desired.
All cycles must be resolvable, however, without mutation of an
immutable record field.
That is, any cycle must contain at least one pointer through a
mutable field, whether it is a mutable record field or a mutable
field of a built-in object type such as a pair or vector.

<p>
When the parameter <tt>print-record</tt> is set to <tt>#f</tt>, records
are printed using the simpler syntax

<p>

<p><tt>#&lt;record&nbsp;of&nbsp;type&nbsp;<i>name</i>&gt;</tt>
<p>where <tt><i>name</i></tt> is the "pretty" name of the record (not the full
gensym) or the reader name first assigned to the record
type.



<p>
<a name="./objects:s212"></a><span class=formdef><b>syntax</b>: <tt>(define-record&nbsp;<i>name</i>&nbsp;(<i>fld<sub>1</sub></i>&nbsp;...)&nbsp;((<i>fld<sub>2</sub></i>&nbsp;<i>init</i>)&nbsp;...)&nbsp;(<i>opt</i>&nbsp;...))</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>(define-record&nbsp;<i>name</i>&nbsp;<i>parent</i>&nbsp;(<i>fld<sub>1</sub></i>&nbsp;...)&nbsp;((<i>fld<sub>2</sub></i>&nbsp;<i>init</i>)&nbsp;...)&nbsp;(<i>opt</i>&nbsp;...))</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A <tt>define-record</tt> form is a definition and may appear anywhere
and only where other definitions may appear.

<p>
<tt>define-record</tt> creates a new record type containing a specified
set of named fields and defines a set of procedures for creating and
manipulating instances of the record type.

<p>
<tt><i>name</i></tt> must be an identifier.
If <tt><i>name</i></tt> is a generated symbol (gensym), the record definition is
<i>nongenerative</i>, otherwise it is <i>expand-time generative</i>.
(See the discussion of generativity earlier in this section.)

<p>
Each <tt><i>fld</i></tt> must be an identifier <tt><i>field-name</i></tt>, or it must take
the form

<p>

<p><tt>(<i>class</i>&nbsp;<i>type</i>&nbsp;<i>field-name</i>)</tt>
<p>where <tt><i>class</i></tt> and <tt><i>type</i></tt> are optional and
<tt><i>field-name</i></tt> is an identifier.
<tt><i>class</i></tt>, if present, must be the keyword <tt>immutable</tt>
or the keyword <tt>mutable</tt>.
If the <tt>immutable</tt> class specifier is present, the field is
immutable; otherwise, the field is mutable.
<tt><i>type</i></tt>, if present, specifies how the field is represented,
as described below.
 
<p>
<TABLE><TR><TD nowrap align="left"><a name="record-field-types"></a>
<tt>ptr</tt> </TD><TD nowrap align="left">            any Scheme object</TD></TR><TR><TD nowrap align="left">
<tt>scheme-object</tt> </TD><TD nowrap align="left">  same as <tt>ptr</tt></TD></TR><TR><TD nowrap align="left">
<tt>int</tt> </TD><TD nowrap align="left">            a C <tt>int</tt></TD></TR><TR><TD nowrap align="left">
<tt>unsigned</tt> </TD><TD nowrap align="left">       a C <tt>unsigned&nbsp;int</tt></TD></TR><TR><TD nowrap align="left">
<tt>short</tt> </TD><TD nowrap align="left">          a C <tt>short</tt></TD></TR><TR><TD nowrap align="left">
<tt>unsigned-short</tt> </TD><TD nowrap align="left"> a C <tt>unsigned&nbsp;short</tt></TD></TR><TR><TD nowrap align="left">
<tt>long</tt> </TD><TD nowrap align="left">           a C <tt>long</tt></TD></TR><TR><TD nowrap align="left">
<tt>unsigned-long</tt> </TD><TD nowrap align="left">  a C <tt>unsigned&nbsp;long</tt></TD></TR><TR><TD nowrap align="left">
<tt>iptr</tt> </TD><TD nowrap align="left">           a signed integer the size of a <tt>ptr</tt></TD></TR><TR><TD nowrap align="left">
<tt>uptr</tt> </TD><TD nowrap align="left">           an unsigned integer the size of a <tt>ptr</tt></TD></TR><TR><TD nowrap align="left">
<tt>float</tt> </TD><TD nowrap align="left">          a C <tt>float</tt></TD></TR><TR><TD nowrap align="left">
<tt>double</tt> </TD><TD nowrap align="left">         a C <tt>double</tt></TD></TR><TR><TD nowrap align="left">
<tt>integer-8</tt> </TD><TD nowrap align="left">      an eight-bit signed integer</TD></TR><TR><TD nowrap align="left">
<tt>unsigned-8</tt> </TD><TD nowrap align="left">     an eight-bit unsigned integer</TD></TR><TR><TD nowrap align="left">
<tt>integer-16</tt> </TD><TD nowrap align="left">     a 16-bit signed integer</TD></TR><TR><TD nowrap align="left">
<tt>unsigned-16</tt> </TD><TD nowrap align="left">    a 16-bit unsigned integer</TD></TR><TR><TD nowrap align="left">
<tt>integer-32</tt> </TD><TD nowrap align="left">     a 32-bit signed integer</TD></TR><TR><TD nowrap align="left">
<tt>unsigned-32</tt> </TD><TD nowrap align="left">    a 32-bit unsigned integer</TD></TR><TR><TD nowrap align="left">
<tt>integer-64</tt> </TD><TD nowrap align="left">     a 64-bit signed integer</TD></TR><TR><TD nowrap align="left">
<tt>unsigned-64</tt> </TD><TD nowrap align="left">    a 64-bit unsigned integer</TD></TR><TR><TD nowrap align="left">
<tt>single-float</tt> </TD><TD nowrap align="left">   a 32-bit single floating point number</TD></TR><TR><TD nowrap align="left">
<tt>double-float</tt> </TD><TD nowrap align="left">   a 64-bit double floating point number
</TD></TR></TABLE>

<p>
If a type is specified, the field can contain objects only of the
specified type.
If no type is specified, the field is of type <tt>ptr</tt>,
meaning that it can contain any Scheme object.

<p>
The field identifiers name the fields of the record.
The values of the <i>n</i> fields described by <tt><i>fld<sub>1</sub></i>&nbsp;...</tt> are
specified by the <i>n</i> arguments to the generated constructor procedure.
The values of the remaining fields, <tt><i>fld<sub>2</sub></i>&nbsp;...</tt>, are
given by the corresponding expressions, <tt><i>init</i>&nbsp;...</tt>.
Each <tt><i>init</i></tt> is evaluated within the scope of the set of field names
given by <tt><i>fld<sub>1</sub></i>&nbsp;...</tt> and each field in
<tt><i>fld<sub>2</sub></i>&nbsp;...</tt> that precedes it, as if within a
<tt>let*</tt> expression.
Each of these field names is bound to the value of the corresponding field
during initialization.

<p>
<a name="./objects:s213"></a><a name="./objects:s214"></a>If
<tt><i>parent</i></tt> is present, the record type named by <tt><i>parent</i></tt>
is the parent of the record.
The new record type inherits each of the parent record's fields,
and records of the new type are considered records of the
parent type.
If <tt><i>parent</i></tt> is not present, the parent record type is
a base record type with no fields.

<p>
The following procedures are defined by <tt>define-record</tt>:

<p>
<ul>
<li>a constructor procedure whose name is <tt>make-<i>name</i></tt>,

<p>
<li>a type predicate whose name is <tt><i>name</i>?</tt>,

<p>
<li>an access procedure whose name is <tt><i>name</i>-<i>fieldname</i></tt>
for each noninherited field, and

<p>
<li>an assignment procedure whose name is
<tt>set-<i>name</i>-<i>fieldname</i>!</tt>
for each noninherited mutable field.
</ul>
<p>

<p>
If no parent record type is specified,
the constructor behaves as if defined as

<p>

<p><tt>(define&nbsp;make-<i>name</i><br>

&nbsp;&nbsp;(lambda&nbsp;(<i>id<sub>1</sub></i>&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;([<i>id<sub>2</sub></i>&nbsp;<i>init</i>]&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>body</i>)))</tt>
<p>where <tt><i>id<sub>1</sub></i>&nbsp;...</tt> are the names of the fields defined by
<tt><i>fld<sub>1</sub></i>&nbsp;...</tt>,
<tt><i>id<sub>2</sub></i>&nbsp;...</tt> are the names of the fields defined by
<tt><i>fld<sub>2</sub></i>&nbsp;...</tt>,
and <tt><i>body</i></tt> builds the record from the values of the identifiers
<tt><i>id<sub>1</sub></i>&nbsp;...</tt> and <tt><i>id<sub>2</sub></i>&nbsp;...</tt>.

<p>
If a parent record type is specified, the parent arguments appear first,
and the parent fields are inserted into the record before the child
fields.

<p>
The options <tt><i>opt</i>&nbsp;...</tt> control the selection of names
of the generated constructor, predicate, accessors, and mutators.

<p>

<p><tt>(constructor&nbsp;<i>id</i>)<br>

(predicate&nbsp;<i>id</i>)<br>

(prefix&nbsp;<i>string</i>)</tt>
<p>The option
<tt>(constructor&nbsp;<i>id</i>)</tt> causes the generated constructor's name
to be <tt><i>id</i></tt> rather than <tt>make-<i>name</i></tt>.
The option <tt>(predicate&nbsp;<i>id</i>)</tt> likewise causes the generated
predicate's name to be <tt><i>id</i></tt> rather than <tt><i>name</i>?</tt>.
The option <tt>(prefix&nbsp;<i>string</i>)</tt> determines the prefix
to be used in the generated accessor and mutator names in place of
<tt><i>name</i>-</tt>.

<p>
If no options are needed, the third subexpression,
<tt>(<i>opt</i>&nbsp;...)</tt>, may be omitted.
If no options and no fields other than those initialized by the arguments
to the
constructor procedure are needed, both the second and third subexpressions
may be omitted.
If options are specified, the second subexpression must be present,
even if it contains no field specifiers.

<p>
Here is a simple example with no inheritance and no options.

<p>

<p><tt>(define-record&nbsp;marble&nbsp;(color&nbsp;quality))<br>

(define&nbsp;x&nbsp;(make-marble&nbsp;'blue&nbsp;'medium))<br>

(marble?&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(pair?&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(vector?&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(marble-color&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;blue<br>

(marble-quality&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;medium<br>

(set-marble-quality!&nbsp;x&nbsp;'low)<br>

(marble-quality&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;low
<br>
<br>
(define-record&nbsp;marble&nbsp;((immutable&nbsp;color)&nbsp;(mutable&nbsp;quality))<br>

&nbsp;&nbsp;(((mutable&nbsp;shape)&nbsp;(if&nbsp;(eq?&nbsp;quality&nbsp;'high)&nbsp;'round&nbsp;'unknown))))<br>

(marble-shape&nbsp;(make-marble&nbsp;'blue&nbsp;'high))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;round<br>

(marble-shape&nbsp;(make-marble&nbsp;'blue&nbsp;'low))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;unknown<br>

(define&nbsp;x&nbsp;(make-marble&nbsp;'blue&nbsp;'high))<br>

(set-marble-quality!&nbsp;x&nbsp;'low)<br>

(marble-shape&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;round<br>

(set-marble-shape!&nbsp;x&nbsp;'half-round)<br>

(marble-shape&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;half-round</tt>
<p>The following example illustrates inheritance.

<p>

<p><tt>(define-record&nbsp;shape&nbsp;(x&nbsp;y))<br>

(define-record&nbsp;point&nbsp;shape&nbsp;())<br>

(define-record&nbsp;circle&nbsp;shape&nbsp;(radius))
<br>
<br>
(define&nbsp;a&nbsp;(make-point&nbsp;7&nbsp;-3))<br>

(shape?&nbsp;a)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(point?&nbsp;a)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(circle?&nbsp;a)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(shape-x&nbsp;a)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;7<br>

(set-shape-y!&nbsp;a&nbsp;(-&nbsp;(shape-y&nbsp;a)&nbsp;1))<br>

(shape-y&nbsp;a)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-4
<br>
<br>
(define&nbsp;b&nbsp;(make-circle&nbsp;7&nbsp;-3&nbsp;1))<br>

(shape?&nbsp;b)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(point?&nbsp;b)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(circle?&nbsp;b)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(circle-radius&nbsp;b)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(circle-radius&nbsp;a)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;not&nbsp;of&nbsp;type&nbsp;circle</i>
<br>
<br>
(define&nbsp;c&nbsp;(make-shape&nbsp;0&nbsp;0))<br>

(shape?&nbsp;c)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(point?&nbsp;c)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(circle?&nbsp;c)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>This example demonstrates the use of options:

<p>

<p><tt>(define-record&nbsp;pair&nbsp;(car&nbsp;cdr)<br>

&nbsp;&nbsp;()<br>

&nbsp;&nbsp;((constructor&nbsp;cons)<br>

&nbsp;&nbsp;&nbsp;(prefix&nbsp;"")))
<br>
<br>
(define&nbsp;x&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(car&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;a<br>

(cdr&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;b<br>

(pair?&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(pair?&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

x&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#[#&#123;pair&nbsp;bdhavk1bwafxyss1-a&#125;&nbsp;a&nbsp;b]</tt>
<p>This example illustrates the use a specified reader name, immutable
fields, and the graph mark and reference syntax.

<p>

<p><tt>(define-record&nbsp;triple&nbsp;((immutable&nbsp;x1)&nbsp;(mutable&nbsp;x2)&nbsp;(immutable&nbsp;x3)))<br>

(record-reader&nbsp;'triple&nbsp;(type-descriptor&nbsp;triple))
<br>
<br>
(let&nbsp;([t&nbsp;'#[triple&nbsp;#1=(1&nbsp;2)&nbsp;(3&nbsp;4)&nbsp;#1#]])<br>

&nbsp;&nbsp;(eq?&nbsp;(triple-x1&nbsp;t)&nbsp;(triple-x3&nbsp;t)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;'(#1=(1&nbsp;2)&nbsp;.&nbsp;#[triple&nbsp;#1#&nbsp;b&nbsp;c])])<br>

&nbsp;&nbsp;(eq?&nbsp;(car&nbsp;x)&nbsp;(triple-x1&nbsp;(cdr&nbsp;x))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([t&nbsp;#[triple&nbsp;#1#&nbsp;(3&nbsp;4)&nbsp;#1=(1&nbsp;2)]])<br>

&nbsp;&nbsp;(eq?&nbsp;(triple-x1&nbsp;t)&nbsp;(triple-x3&nbsp;t)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([t&nbsp;'#1=#[triple&nbsp;a&nbsp;#1#&nbsp;c]])<br>

&nbsp;&nbsp;(eq?&nbsp;t&nbsp;(triple-x2&nbsp;t)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([t&nbsp;'#1=(#[triple&nbsp;#1#&nbsp;b&nbsp;#1#])])<br>

&nbsp;&nbsp;(and&nbsp;(eq?&nbsp;t&nbsp;(triple-x1&nbsp;(car&nbsp;t)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eq?&nbsp;t&nbsp;(triple-x1&nbsp;(car&nbsp;t)))))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p>Cycles established with the mark and reference syntax can be
resolved only if a mutable record field or mutable location
of some other object is involved the cycle, as in the last
two examples above.
An exception is raised with condition type <tt>&amp;lexical</tt> if only
immutable fields are involved.

<p>

<p><tt>'#1=#[triple&nbsp;#1#&nbsp;(3&nbsp;4)&nbsp;#1#]&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception</i></tt>
<p><a name="./objects:s215"></a>The following example demonstrates
the use of nongenerative record definitions.

<p>

<p><tt>(module&nbsp;A&nbsp;(point-disp)<br>

&nbsp;&nbsp;(define-record&nbsp;#&#123;point&nbsp;bdhavk1bwafxyss1-b&#125;&nbsp;(x&nbsp;y))<br>

&nbsp;&nbsp;(define&nbsp;square&nbsp;(lambda&nbsp;(x)&nbsp;(*&nbsp;x&nbsp;x)))<br>

&nbsp;&nbsp;(define&nbsp;point-disp<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(p1&nbsp;p2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sqrt&nbsp;(+&nbsp;(square&nbsp;(-&nbsp;(point-x&nbsp;p1)&nbsp;(point-x&nbsp;p2)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(square&nbsp;(-&nbsp;(point-y&nbsp;p1)&nbsp;(point-y&nbsp;p2))))))))
<br>
<br>
(module&nbsp;B&nbsp;(base-disp)<br>

&nbsp;&nbsp;(define-record&nbsp;#&#123;point&nbsp;bdhavk1bwafxyss1-b&#125;&nbsp;(x&nbsp;y))<br>

&nbsp;&nbsp;(import&nbsp;A)<br>

&nbsp;&nbsp;(define&nbsp;base-disp<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(point-disp&nbsp;(make-point&nbsp;0&nbsp;0)&nbsp;p))))
<br>
<br>
(let&nbsp;()<br>

&nbsp;&nbsp;(import&nbsp;B)<br>

&nbsp;&nbsp;(define-record&nbsp;#&#123;point&nbsp;bdhavk1bwafxyss1-b&#125;&nbsp;(x&nbsp;y))<br>

&nbsp;&nbsp;(base-disp&nbsp;(make-point&nbsp;3&nbsp;4)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;5</tt>
<p>This works even if the different program components are loaded from
different source files or are compiled separately and loaded from
different object files.

<p>
<a name="./objects:s216"></a><span class=formdef><b>syntax</b>: <tt>predicate</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>prefix</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>constructor</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./objects:s217"></a><a name="./objects:s218"></a>These identifiers are auxiliary keywords for <tt>define-record</tt>.
It is a syntax violation to reference these identifiers except in
contexts where they are recognized as auxiliary keywords.
<tt>mutable</tt> and <tt>immutable</tt> are also auxiliary keywords for
<tt>define-record</tt>, shared with the Revised<sup>6</sup> Report
<tt>define-record-type</tt>.


<p>
<a name="./objects:s219"></a><span class=formdef><b>syntax</b>: <tt>(type-descriptor&nbsp;<i>name</i>)</tt></span>
<br>
<b>returns: </b>the record-type descriptor associated with <tt><i>name</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>name</i></tt> must name a record type defined by <tt>define-record</tt>
or <tt>define-record-type</tt>.

<p>
This form is equivalent to the Revised<sup>6</sup> Report
<tt>record-type-descriptor</tt> form.

<p>
The record-type descriptor is useful for overriding the default
read and write syntax using <tt>record-reader</tt> and
<tt>record-writer</tt> and may also be used with the procedural
interface routines described later in this section.

<p>

<p><tt>(define-record&nbsp;frob&nbsp;())<br>

(type-descriptor&nbsp;frob)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;record&nbsp;type&nbsp;frob&gt;</tt>
<p><a name="./objects:s220"></a><span class=formdef><b>procedure</b>: <tt>(record-reader&nbsp;<i>name</i>)</tt></span>
<br>
<b>returns: </b>the record-type descriptor associated with <tt><i>name</i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(record-reader&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>the first name associated with <tt><i>rtd</i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(record-reader&nbsp;<i>name</i>&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br><span class=formdef><b>procedure</b>: <tt>(record-reader&nbsp;<i>name</i>&nbsp;#f)</tt></span>
<br>
<b>returns: </b>unspecified
<br><span class=formdef><b>procedure</b>: <tt>(record-reader&nbsp;<i>rtd</i>&nbsp;#f)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>name</i></tt> must be a symbol, and <tt><i>rtd</i></tt> must be a
record-type descriptor.

<p>
With one argument, <tt>record-reader</tt> is used to retrieve the record
type associated with a name or name associated with a record type.
If no association has been created, <tt>record-reader</tt> returns
<tt>#f</tt>

<p>
With arguments <tt><i>name</i></tt> and <tt><i>rtd</i></tt>, <tt>record-reader</tt> registers
<tt><i>rtd</i></tt> as the record-type descriptor to be used whenever the
<tt>read</tt> procedure encounters a record named by <tt><i>name</i></tt> and
printed in the default record syntax.

<p>
With arguments <tt><i>name</i></tt> and <tt>#f</tt>, <tt>record-reader</tt> removes
any association for <tt><i>name</i></tt> to a record-type descriptor.
Similarly, with arguments <tt><i>rtd</i></tt> and <tt>#f</tt>, <tt>record-reader</tt>
removes any association for <tt><i>rtd</i></tt> to a name.

<p>

<p><tt>(define-record&nbsp;marble&nbsp;(color&nbsp;quality))<br>

(define&nbsp;m&nbsp;(make-marble&nbsp;'blue&nbsp;'perfect))<br>

m&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#[#&#123;marble&nbsp;bdhavk1bwafxyss1-c&#125;&nbsp;blue&nbsp;perfect]
<br>
<br>
(record-reader&nbsp;(type-descriptor&nbsp;marble))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(record-reader&nbsp;'marble)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(record-reader&nbsp;'marble&nbsp;(type-descriptor&nbsp;marble))<br>

(marble-color&nbsp;'#[marble&nbsp;red&nbsp;miserable])&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;red
<br>
<br>
(record-reader&nbsp;(type-descriptor&nbsp;marble))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;marble<br>

(record-reader&nbsp;'marble)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;record&nbsp;type&nbsp;marble&gt;
<br>
<br>
(record-reader&nbsp;(type-descriptor&nbsp;marble)&nbsp;#f)<br>

(record-reader&nbsp;(type-descriptor&nbsp;marble))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(record-reader&nbsp;'marble)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(record-reader&nbsp;'marble&nbsp;(type-descriptor&nbsp;marble))<br>

(record-reader&nbsp;'marble&nbsp;#f)<br>

(record-reader&nbsp;(type-descriptor&nbsp;marble))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(record-reader&nbsp;'marble)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>The introduction of a record reader also changes the default
printing of records.
The printer always chooses the reader name first assigned
to the record, if any, in place of the unique record name, as this
continuation of the example above demonstrates.

<p>

<p><tt>(record-reader&nbsp;'marble&nbsp;(type-descriptor&nbsp;marble))<br>

(make-marble&nbsp;'pink&nbsp;'splendid)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#[marble&nbsp;pink&nbsp;splendid]</tt>
<p><a name="./objects:s221"></a><span class=formdef><b>procedure</b>: <tt>(record-writer&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>the record writer associated with <tt><i>rtd</i></tt>
<br><span class=formdef><b>procedure</b>: <tt>(record-writer&nbsp;<i>rtd</i>&nbsp;<i>procedure</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>rtd</i></tt> must be a record-type descriptor, and <tt><i>procedure</i></tt> should
accept three arguments, as described below.

<p>
When passed only one argument, <tt>record-writer</tt> returns the
record writer associated with <tt><i>rtd</i></tt>, which is initially the
default record writer for all records.
The default print method prints all records in a uniform syntax that
includes the generated name for the record 
and the values of each of the fields, as described in the introduction
to this section.

<p>
When passed two arguments, <tt>record-writer</tt> establishes a
new association between <tt><i>rtd</i></tt> and <tt><i>procedure</i></tt> so that
<tt><i>procedure</i></tt> will be used by the printer in place of the default
printer for records of the given type.
The printer passes <tt><i>procedure</i></tt> three arguments:
the record <tt><i>r</i></tt>, a port <tt><i>p</i></tt>, and a procedure <tt><i>wr</i></tt> that
should be used to write out the values of arbitrary Scheme objects that
the print method chooses to include in the printed representation of the
record, e.g., values of the record's fields.

<p>

<p><tt>(define-record&nbsp;marble&nbsp;(color&nbsp;quality))<br>

(define&nbsp;m&nbsp;(make-marble&nbsp;'blue&nbsp;'medium))
<br>
<br>
m&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#[#&#123;marble&nbsp;bdhavk1bwafxyss1-d&#125;&nbsp;blue&nbsp;medium]
<br>
<br>
(record-writer&nbsp;(type-descriptor&nbsp;marble)<br>

&nbsp;&nbsp;(lambda&nbsp;(r&nbsp;p&nbsp;wr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"#&lt;"&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(wr&nbsp;(marble-quality&nbsp;r)&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"&nbsp;quality&nbsp;"&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(wr&nbsp;(marble-color&nbsp;r)&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"&nbsp;marble&gt;"&nbsp;p)))
<br>
<br>
m&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;medium&nbsp;quality&nbsp;blue&nbsp;marble&gt;</tt>
<p>The record writer is used only when <tt>print-record</tt> is true
(the default).
When the parameter <tt>print-record</tt> is set to <tt>#f</tt>, records
are printed using a compressed syntax that identifies only the type
of record.

<p>

<p><tt>(parameterize&nbsp;([print-record&nbsp;#f])<br>

&nbsp;&nbsp;(format&nbsp;"~s"&nbsp;m))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"#&lt;record&nbsp;of&nbsp;type&nbsp;marble&gt;"</tt>
<p>A print method may be called more than once during the printing of a
single record to support cycle detection and graph printing
(see <a name="./objects:s222"></a><tt>print-graph</tt>),
so print
methods that perform side effects other than printing to the given
port are discouraged.
Whenever a print method is called more than once during the printing
of a single record, in all but one call, a generic "bit sink" port
is used to suppress output automatically so that only one copy of
the object appears on the actual port.
In order to avoid confusing the cycle detection and graph printing
algorithms, a print method should always produce the same printed
representation for each object.
Furthermore, a print method should normally use the supplied procedure
<tt><i>wr</i></tt> to print subobjects, though atomic values, such as strings
or numbers, may be printed by direct calls to <tt>display</tt> or
<tt>write</tt> or by other means.

<p>

<p><tt>(let&nbsp;()<br>

&nbsp;&nbsp;(define-record&nbsp;ref&nbsp;()&nbsp;((contents&nbsp;'nothing)))<br>

&nbsp;&nbsp;(record-writer&nbsp;(type-descriptor&nbsp;ref)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(r&nbsp;p&nbsp;wr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"&lt;"&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(wr&nbsp;(ref-contents&nbsp;r)&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"&gt;"&nbsp;p)))<br>

&nbsp;&nbsp;(let&nbsp;([ref-lexive&nbsp;(make-ref)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set-ref-contents!&nbsp;ref-lexive&nbsp;ref-lexive)<br>

&nbsp;&nbsp;&nbsp;&nbsp;ref-lexive))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#0=&lt;#0#&gt;</tt>
<p>Print methods need not be concerned with handling nonfalse values of
the parameters
<a name="./objects:s223"></a><tt>print-level</tt>.
The printer handles <tt>print-level</tt> automatically even when
user-defined print procedures are used.
Since records typically contain a small, fixed number of fields, it
is usually possible to ignore nonfalse values of
<a name="./objects:s224"></a><tt>print-length</tt> as well.

<p>

<p><tt>(print-level&nbsp;3)<br>

(let&nbsp;()<br>

&nbsp;&nbsp;(define-record&nbsp;ref&nbsp;()&nbsp;((contents&nbsp;'nothing)))<br>

&nbsp;&nbsp;(record-writer&nbsp;(type-descriptor&nbsp;ref)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(r&nbsp;p&nbsp;wr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"&lt;"&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(wr&nbsp;(ref-contents&nbsp;r)&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"&gt;"&nbsp;p)))<br>

&nbsp;&nbsp;(let&nbsp;([ref-lexive&nbsp;(make-ref)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set-ref-contents!&nbsp;ref-lexive&nbsp;ref-lexive)<br>

&nbsp;&nbsp;&nbsp;&nbsp;ref-lexive))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;&lt;&lt;&lt;&lt;#[...]&gt;&gt;&gt;&gt;</tt>
<p><a name="./objects:s225"></a><span class=formdef><b>thread parameter</b>: <tt>print-record</tt></span>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This parameter controls the printing of records.
If set to true (the default) the record writer associated with a
record type is used to print records of that type.
If set to false, all records are printed with the syntax
<tt>#&lt;record&nbsp;of&nbsp;type&nbsp;<i>name</i>&gt;</tt>, where <tt><i>name</i></tt> is the
name of the record type as returned by <tt>record-type-name</tt>.


<p>
<a name="./objects:s226"></a><span class=formdef><b>procedure</b>: <tt>(make-record-type&nbsp;<i>type-name</i>&nbsp;<i>fields</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-record-type&nbsp;<i>parent-rtd</i>&nbsp;<i>type-name</i>&nbsp;<i>fields</i>)</tt></span>
<br>
<b>returns: </b>a record-type descriptor for a new record type
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>make-record-type</tt> creates a new data type and returns a
record-type descriptor, a value representing the new data type.
The new type is disjoint from all others.

<p>
If present, <tt><i>parent-rtd</i></tt> must be a record-type descriptor.

<p>
<tt><i>type-name</i></tt> must be a string or gensym.
If <tt><i>type-name</i></tt> is a string, a new record type is generated.
If <tt><i>type-name</i></tt> is a gensym, a new record type is generated only
if one with the same gensym has not already been defined.
If one has already been defined, the parent and fields must be identical
to those of the existing record type, and the
existing record type is used.
If the parent and fields are not identical, an exception is raised with
condition-type <tt>&amp;assertion</tt>.

<p>
<tt><i>fields</i></tt> must be a list of field descriptors, each of which
describes one field of instances of the new record type.
A field descriptor is either a symbol or a list in the following form:

<p>

<p><tt>(<i>class</i>&nbsp;<i>type</i>&nbsp;<i>field-name</i>)</tt>
<p>where <tt><i>class</i></tt> and <tt><i>type</i></tt> are optional.
<tt><i>field-name</i></tt> must be a symbol.
<tt><i>class</i></tt>, if present, must be the symbol <tt>immutable</tt> or
the symbol <tt>mutable</tt>.
If the <tt>immutable</tt> class-specifier is present, the field is
immutable; otherwise, the field is mutable.
<tt><i>type</i></tt>, if present, specifies how the field is represented.
The types are the same as those given in the description
of <tt>define-record</tt> on page&nbsp;<a href="./objects.html#record-field-types">196</a>.

<p>
If a type is specified, the field can contain objects only of the
specified type.
If no type is specified, the field is of type <tt>ptr</tt>,
meaning that it can contain any Scheme object.

<p>
The behavior of a program that modifies the string <tt><i>type-name</i></tt>
or the list <tt><i>fields</i></tt> or any of its sublists is unspecified.

<p>
The record-type descriptor may be passed as an argument to any of the
Revised<sup>6</sup> Report procedures

<p>
<ul>
<li><tt>record-constructor</tt>,
<li><tt>record-predicate</tt>,
<li><tt>record-accessor</tt>, and
<li><tt>record-mutator</tt>,
</ul>
<p>

<p>
or to the <i>Chez&nbsp;Scheme</i> variants

<p>
<ul>
<li><tt>record-constructor</tt>,
<li><tt>record-field-accessor</tt>, and
<li><tt>record-field-mutator</tt>
</ul>
<p>

<p>
to obtain procedures for creating and manipulating records of the
new type.

<p>

<p><tt>(define&nbsp;marble<br>

&nbsp;&nbsp;(make-record-type&nbsp;"marble"<br>

&nbsp;&nbsp;&nbsp;&nbsp;'(color&nbsp;quality)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(r&nbsp;p&nbsp;wr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"#&lt;"&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(wr&nbsp;(marble-quality&nbsp;r)&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"&nbsp;quality&nbsp;"&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(wr&nbsp;(marble-color&nbsp;r)&nbsp;p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"&nbsp;marble&gt;"&nbsp;p))))<br>

(define&nbsp;make-marble<br>

&nbsp;&nbsp;(record-constructor&nbsp;marble))<br>

(define&nbsp;marble?<br>

&nbsp;&nbsp;(record-predicate&nbsp;marble))<br>

(define&nbsp;marble-color<br>

&nbsp;&nbsp;(record-field-accessor&nbsp;marble&nbsp;'color))<br>

(define&nbsp;marble-quality<br>

&nbsp;&nbsp;(record-field-accessor&nbsp;marble&nbsp;'quality))<br>

(define&nbsp;set-marble-quality!<br>

&nbsp;&nbsp;(record-field-mutator&nbsp;marble&nbsp;'quality))<br>

(define&nbsp;x&nbsp;(make-marble&nbsp;'blue&nbsp;'high))<br>

(marble?&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(marble-quality&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;high<br>

(set-marble-quality!&nbsp;x&nbsp;'low)<br>

(marble-quality&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;low<br>

x&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;low&nbsp;quality&nbsp;blue&nbsp;marble&gt;</tt>
<p>The order in which the fields appear in <tt><i>fields</i></tt> is important.
While field names are generally distinct, it is permissible for one field
name to be the same as another in the list of fields or the same as
an inherited name.
In this case, <a name="./objects:s227"></a><a name="./objects:s228"></a>field ordinals
must be used to select fields in calls to <tt>record-field-accessor</tt>
and <tt>record-field-mutator</tt>.
Ordinals range from zero through one less than the number of fields.
Parent fields come first, if any, followed by the fields in
<tt><i>fields</i></tt>, in the order given.

<p>

<p><tt>(define&nbsp;r1&nbsp;(make-record-type&nbsp;"r1"&nbsp;'(t&nbsp;t)))<br>

(define&nbsp;r2&nbsp;(make-record-type&nbsp;r1&nbsp;"r2"&nbsp;'(t)))<br>

(define&nbsp;r3&nbsp;(make-record-type&nbsp;r2&nbsp;"r3"&nbsp;'(t&nbsp;t&nbsp;t)))
<br>
<br>
(define&nbsp;x&nbsp;((record-constructor&nbsp;r3)&nbsp;'a&nbsp;'b&nbsp;'c&nbsp;'d&nbsp;'e&nbsp;'f))<br>

((record-field-accessor&nbsp;r3&nbsp;0)&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;a<br>

((record-field-accessor&nbsp;r3&nbsp;2)&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;c<br>

((record-field-accessor&nbsp;r3&nbsp;4)&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;e<br>

((record-field-accessor&nbsp;r3&nbsp;'t)&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i></tt>
<p><a name="./objects:s229"></a><span class=formdef><b>procedure</b>: <tt>(record-constructor&nbsp;<i>rcd</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(record-constructor&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>a constructor for records of the type represented by <tt><i>rtd</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Like the Revised<sup>6</sup> Report version of this procedure, this procedure
may be passed a record-constructor descriptor, <tt><i>rcd</i></tt>, which determines
the behavior of the constructor.
It may also be passed a record-type descriptor, <tt><i>rtd</i></tt>, in which
case the constructor accepts as many arguments as there are fields in the
record; these arguments are the initial values of the fields in the
order given when the record-type descriptor was created.


<p>
<a name="./objects:s230"></a><span class=formdef><b>procedure</b>: <tt>(record-field-accessor&nbsp;<i>rtd</i>&nbsp;<i>field-id</i>)</tt></span>
<br>
<b>returns: </b>an accessor for the identified field
<br>
<b>libraries: </b><tt>(chezscheme&nbsp;csv7)</tt>

<p><tt><i>rtd</i></tt> must be a record-type descriptor, <tt><i>field-id</i></tt> must be
a symbol or field ordinal, i.e., a nonnegative exact integer less than
the number of fields of the given record type.
The specified field must be accessible.

<p>
The generated accessor expects one argument, which must be a record of
the type represented by <tt><i>rtd</i></tt>.
It returns the contents of the specified field of the record.


<p>
<a name="./objects:s231"></a><span class=formdef><b>procedure</b>: <tt>(record-field-accessible?&nbsp;<i>rtd</i>&nbsp;<i>field-id</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the specified field is accessible, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme&nbsp;csv7)</tt>

<p><tt><i>rtd</i></tt> must be a record-type descriptor, <tt><i>field-id</i></tt> must be
a symbol or field ordinal, i.e., a nonnegative exact integer less than
the number of fields of the given record type.

<p>
The compiler is free to eliminate a record field if it can prove that
the field is not accessed.
In making this determination, the compiler is free to ignore the
possibility that an accessor might be created from a record-type
descriptor obtained by calling <tt>record-type-descriptor</tt> on an
instance of the record type.


<p>
<a name="./objects:s232"></a><span class=formdef><b>procedure</b>: <tt>(record-field-mutator&nbsp;<i>rtd</i>&nbsp;<i>field-id</i>)</tt></span>
<br>
<b>returns: </b>a mutator for the identified field
<br>
<b>libraries: </b><tt>(chezscheme&nbsp;csv7)</tt>

<p><tt><i>rtd</i></tt> must be a record-type descriptor, <tt><i>field-id</i></tt> must be
a symbol or field ordinal, i.e., a nonnegative exact integer less than
the number of fields of the given record type.
The specified field must be mutable.

<p>
The mutator expects two arguments, <tt><i>r</i></tt> and <tt><i>obj</i></tt>.
<tt><i>r</i></tt> must be a record of the type represented by <tt><i>rtd</i></tt>.
<tt><i>obj</i></tt> must be a value that is compatible with the type declared for
the specified field when the record-type descriptor was created.
<tt><i>obj</i></tt> is stored in the specified field of the record.


<p>
<a name="./objects:s233"></a><span class=formdef><b>procedure</b>: <tt>(record-field-mutable?&nbsp;<i>rtd</i>&nbsp;<i>field-id</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the specified field is mutable, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme&nbsp;csv7)</tt>

<p><tt><i>rtd</i></tt> must be a record-type descriptor, <tt><i>field-id</i></tt> must be
a symbol or field ordinal, i.e., a nonnegative exact integer less than
the number of fields of the given record type.

<p>
Any field declared immutable is immutable.
In addition,
the compiler is free to treat a field as immutable if it can prove that
the field is never assigned.
In making this determination, the compiler is free to ignore the
possibility that a mutator might be created from a record-type
descriptor obtained by calling <tt>record-type-descriptor</tt> on an
instance of the record type.


<p>
<a name="./objects:s234"></a><span class=formdef><b>procedure</b>: <tt>(record-type-name&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>the name of the record-type represented by <tt><i>rtd</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme&nbsp;csv7)</tt>

<p><tt><i>rtd</i></tt> must be a record-type descriptor.

<p>
The name is a always a string.
If a gensym is provided as the record-type name in a
<tt>define-record</tt> form or <tt>make-record-type</tt> call, the result
is the "pretty" name of the gensym (see&nbsp;<a href="./objects.html#g59">7.11</a>).

<p>

<p><tt>(record-type-name&nbsp;(make-record-type&nbsp;"empty"&nbsp;'()))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"empty"
<br>
<br>
(define-record&nbsp;#&#123;point&nbsp;bdhavk1bwafxyss1-b&#125;&nbsp;(x&nbsp;y))<br>

(define&nbsp;p&nbsp;(type-descriptor&nbsp;#&#123;point&nbsp;bdhavk1bwafxyss1-b&#125;))<br>

(record-type-name&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"point"</tt>
<p><a name="./objects:s235"></a><span class=formdef><b>procedure</b>: <tt>(record-type-symbol&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>the generated symbol associated with <tt><i>rtd</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme&nbsp;csv7)</tt>

<p><tt><i>rtd</i></tt> must be a record-type descriptor.

<p>

<p><tt>(define&nbsp;e&nbsp;(make-record-type&nbsp;"empty"&nbsp;'()))<br>

(record-type-symbol&nbsp;e)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&#123;empty&nbsp;bdhavk1bwafxyss1-e&#125;
<br>
<br>
(define-record&nbsp;#&#123;point&nbsp;bdhavk1bwafxyss1-b&#125;&nbsp;(x&nbsp;y))<br>

(define&nbsp;p&nbsp;(type-descriptor&nbsp;#&#123;point&nbsp;bdhavk1bwafxyss1-b&#125;))<br>

(record-type-symbol&nbsp;p)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&#123;point&nbsp;bdhavk1bwafxyss1-b&#125;</tt>
<p><a name="./objects:s236"></a><span class=formdef><b>procedure</b>: <tt>(record-type-field-names&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>a list of field names of the type represented by <tt><i>rtd</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme&nbsp;csv7)</tt>

<p><tt><i>rtd</i></tt> must be a record-type descriptor.
The field names are symbols.

<p>
See also the Revised<sup>6</sup> Report version of this prodecure (exported from
the <tt>(chezscheme)</tt> library) which returns a vector.

<p>

<p><tt>(define-record&nbsp;triple&nbsp;((immutable&nbsp;x1)&nbsp;(mutable&nbsp;x2)&nbsp;(immutable&nbsp;x3)))<br>

(record-type-field-names&nbsp;(type-descriptor&nbsp;triple))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(x1&nbsp;x2&nbsp;x3)</tt>
<p><a name="./objects:s237"></a><span class=formdef><b>procedure</b>: <tt>(record-type-field-decls&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>a list of field declarations of the type represented by <tt><i>rtd</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme&nbsp;csv7)</tt>

<p><tt><i>rtd</i></tt> must be a record-type descriptor.
Each field declaration has the following form:

<p>

<p><tt>(<i>class</i>&nbsp;<i>type</i>&nbsp;<i>field-name</i>)</tt>
<p>where <tt><i>class</i></tt>, <tt><i>type</i></tt>, and <tt><i>field-name</i></tt> are as described
under <tt>make-record-type</tt>.

<p>

<p><tt>(define-record&nbsp;shape&nbsp;(x&nbsp;y))<br>

(define-record&nbsp;circle&nbsp;shape&nbsp;(radius))
<br>
<br>
(record-type-field-decls<br>

&nbsp;&nbsp;(type-descriptor&nbsp;circle))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;((mutable&nbsp;ptr&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;(mutable&nbsp;ptr&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;(mutable&nbsp;ptr&nbsp;radius))</tt>
<p><a name="./objects:s238"></a><span class=formdef><b>procedure</b>: <tt>(record?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a record, otherwise <tt>#f</tt>
<br><span class=formdef><b>procedure</b>: <tt>(record?&nbsp;<i>obj</i>&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a record of the given type, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>If present, <tt><i>rtd</i></tt> must be a record-type descriptor.

<p>
A record is "of the given type" if it is an instance of the record
type or one of its ancestors.
The predicate generated by <tt>record-predicate</tt> for a
record-type descriptor <tt><i>rtd</i></tt> is equivalent to the following.

<p>

<p><tt>(lambda&nbsp;(x)&nbsp;(record?&nbsp;x&nbsp;<i>rtd</i>))</tt>
<p><a name="./objects:s239"></a><span class=formdef><b>procedure</b>: <tt>(record-instance?&nbsp;<i>obj</i>&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a record of the given type, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>obj</i></tt> must be a record, and <tt><i>rtd</i></tt> must be a record-type descriptor.

<p>
The result is the same as for a two-argument <tt>record?</tt> call,
but <tt><i>obj</i></tt> is constrained to be a record. In unsafe mode,
<tt>record-instance?</tt> might be faster than <tt>record?</tt>.

<p>
<a name="./objects:s240"></a><span class=formdef><b>procedure</b>: <tt>(record-type-descriptor&nbsp;<i>rec</i>)</tt></span>
<br>
<b>returns: </b>the record-type descriptor of <tt><i>rec</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme&nbsp;csv7)</tt>

<p><tt><i>rec</i></tt> must be a record.
This procedure is intended for use in the definition of portable printers
and debuggers.
For records created with <tt>make-record-type</tt>,
it may not be the same as the descriptor returned by
<tt>make-record-type</tt>.
See the comments about field accessibility and mutability under
<tt>record-field-accessible?</tt> and
<tt>record-field-mutable?</tt> above.

<p>
This procedure is equivalent to the Revised<sup>6</sup> Report <tt>record-rtd</tt>
procedure.

<p>

<p><tt>(define&nbsp;rtd&nbsp;(make-record-type&nbsp;"frob"&nbsp;'(blit&nbsp;blat)))<br>

rtd&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;record&nbsp;type&nbsp;frob&gt;<br>

(define&nbsp;x&nbsp;((record-constructor&nbsp;rtd)&nbsp;1&nbsp;2))<br>

(record-type-descriptor&nbsp;x)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#&lt;record&nbsp;type&nbsp;frob&gt;<br>

(eq?&nbsp;(record-type-descriptor&nbsp;x)&nbsp;rtd)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i></tt>
<p><a name="./objects:s241"></a><span class=formdef><b>procedure</b>: <tt>(make-record-type-descriptor&nbsp;<i>name</i>&nbsp;<i>parent</i>&nbsp;<i>uid</i>&nbsp;<i>s?</i>&nbsp;<i>o?</i>&nbsp;<i>fields</i>)</tt></span>
<br>
<b>returns: </b>a record-type descriptor for a new record type
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Like the Revised<sup>6</sup> Report version of this procedure, but <tt><i>fields</i></tt>
is also allowed to be a pair of non-negative integers, in which case the
new record type has anonymous fields. The <tt>car</tt> of <tt><i>fields</i></tt>
is a field count, and it is added to any fields present in
<tt><i>parent</i></tt> to determine the record type's total number of fields.
The <tt>cdr</tt> of <tt><i>fields</i></tt> must be an exact non-negative integer
that is treated as a bit array; a <tt>1</tt> bit indicates the the
corresponding field among new fields is mutable. The total number of
fields in a record type must be a fixnum.

<p>
If <tt><i>parent</i></tt> is a record type descriptor, it must also have
anonymous fields. The resulting anonymous-field record type can only
be the parent of a record type with anonymous fields.

<p>
When a function like <tt>record-type-field-names</tt> is applied to an
anonymous-field record type, the field names are all reported as
<tt>field</tt>.

<p>
<a name="./objects:s242"></a><span class=formdef><b>procedure</b>: <tt>(record-type-has-named-fields?&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>a boolean indicating whether <tt><i>rtd</i></tt> has named fields
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>rtd</i></tt> must be a record-type descriptor.


<p>

<h3><a name="g66"></a><a name="./objects:h18"></a>Section 7.18. Procedures</h3>



<p>
<a name="./objects:s243"></a><span class=formdef><b>procedure</b>: <tt>(procedure-arity-mask&nbsp;<i>proc</i>)</tt></span>
<br>
<b>returns: </b>an exact integer bitmask identifying the accepted argument counts of <tt><i>proc</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The bitmask is represented as two's complement number with the bit
at each index <tt><i>n</i></tt> set if and only if <tt><i>proc</i></tt> accepts <tt><i>n</i></tt>
arguments.

<p>
The two's complement encoding implies that if <tt><i>proc</i></tt> accepts
<tt><i>n</i></tt> or more arguments, the encoding is a negative number,
since all the bits from <tt><i>n</i></tt> and up are set. For example, if
<tt><i>proc</i></tt> accepts any number of arguments, the two's complement
encoding of all bits set is <tt>-1</tt>.

<p>

<p><tt>(procedure-arity-mask&nbsp;(lambda&nbsp;()&nbsp;'none))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1<br>

(procedure-arity-mask&nbsp;car)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2<br>

(procedure-arity-mask&nbsp;(case-lambda&nbsp;[()&nbsp;'none]&nbsp;[(x)&nbsp;x]))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(procedure-arity-mask&nbsp;(lambda&nbsp;x&nbsp;x))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-1<br>

(procedure-arity-mask&nbsp;(case-lambda&nbsp;[()&nbsp;'none]&nbsp;[(x&nbsp;y&nbsp;.&nbsp;z)&nbsp;x]))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;-3<br>

(procedure-arity-mask&nbsp;(case-lambda))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(logbit?&nbsp;1&nbsp;(procedure-arity-mask&nbsp;pair?))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t<br>

(logbit?&nbsp;2&nbsp;(procedure-arity-mask&nbsp;pair?))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(logbit?&nbsp;2&nbsp;(procedure-arity-mask&nbsp;cons))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s244"></a><span class=formdef><b>procedure</b>: <tt>(make-wrapper-procedure&nbsp;<i>proc</i>&nbsp;<i>arity-mask</i>&nbsp;<i>data</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-arity-wrapper-procedure&nbsp;<i>proc</i>&nbsp;<i>arity-mask</i>&nbsp;<i>data</i>)</tt></span>
<br>
<b>returns: </b>a procedure that behaves like <tt><i>proc</i></tt>, but with the given <tt><i>arity-mask</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>proc</i></tt> must be a procedure, and <tt><i>arity-mask</i></tt> must be an exact
integer representing an arity mask in the sense of <tt>procedure-arity-mask</tt>.

<p>
The resulting procedure behaves the same as <tt><i>proc</i></tt>, except that
<tt>procedure-arity-mask</tt> on the result procedure returns
<tt><i>arity-mask</i></tt>. When the result of <tt>make-arity-wrapper-procedure</tt>
is called, the given arguments are compared to the given arity mask, and an error is reported
if the argument count does not match. The result of <tt>make-wrapper-procedure</tt>,
in contrast, does not enforce the given arity mask.

<p>
The <tt><i>data</i></tt> argument can be any value, and it can be retrieved from
the result procedure with <tt>wrapper-procedure-data</tt>.

<p>

<p><tt>(define&nbsp;vector3&nbsp;(make-wrapper-procedure&nbsp;vector&nbsp;8&nbsp;#f))<br>

(procedure-arity-mask&nbsp;vector)&nbsp;;&nbsp;=&gt;&nbsp;-1<br>

(procedure-arity-mask&nbsp;vector3)&nbsp;;&nbsp;=&gt;&nbsp;8<br>

(vector3&nbsp;1&nbsp;2&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#(1&nbsp;2&nbsp;3)<br>

(vector3&nbsp;1&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#(1&nbsp;2)<br>

(define&nbsp;vector3/check&nbsp;(make-arity-wrapper-procedure&nbsp;vector&nbsp;8&nbsp;#f))<br>

(vector3/check&nbsp;1&nbsp;2&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;&nbsp;#(1&nbsp;2&nbsp;3)<br>

(vector3/check&nbsp;1&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception</i></tt>
<p><a name="./objects:s245"></a><span class=formdef><b>procedure</b>: <tt>(wrapper-procedure?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a wrapper procedure, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Determines whether <tt><i>obj</i></tt> is a wrapper procedure produced by either
<tt>make-wrapper-procedure</tt> or <tt>make-arity-wrapper-procedure</tt>.

<p>

<p><tt>(wrapper-procedure?&nbsp;vector)&nbsp;;&nbsp;=&gt;&nbsp;#f<br>

(define&nbsp;vector3&nbsp;(make-wrapper-procedure&nbsp;vector&nbsp;8&nbsp;#f))<br>

(wrapper-procedure?&nbsp;vector3)&nbsp;;&nbsp;=&gt;&nbsp;#t</tt>
<p><a name="./objects:s246"></a><span class=formdef><b>procedure</b>: <tt>(wrapper-procedure-procedure&nbsp;<i>w-proc</i>)</tt></span>
<br>
<b>returns: </b>the procedure wrapped by the wrapper procedure <tt><i>proc</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>w-proc</i></tt> must be a wrapper procedure produced by either
<tt>make-wrapper-procedure</tt> or <tt>make-arity-wrapper-procedure</tt>.


<p>

<p><tt>(define&nbsp;vector3&nbsp;(make-wrapper-procedure&nbsp;vector&nbsp;8&nbsp;'my-data))<br>

(wrapper-procedure-procedure&nbsp;vector3)&nbsp;;&nbsp;=&gt;&nbsp;#&lt;procedure&nbsp;vector&gt;</tt>
<p><a name="./objects:s247"></a><span class=formdef><b>procedure</b>: <tt>(wrapper-procedure-data&nbsp;<i>w-proc</i>)</tt></span>
<br>
<b>returns: </b>the data stored with the wrapper procedure <tt><i>proc</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>w-proc</i></tt> must be a wrapper procedure produced by either
<tt>make-wrapper-procedure</tt> or <tt>make-arity-wrapper-procedure</tt>.


<p>

<p><tt>(define&nbsp;vector3&nbsp;(make-wrapper-procedure&nbsp;vector&nbsp;8&nbsp;'my-data))<br>

(wrapper-procedure-data&nbsp;vector3)&nbsp;;&nbsp;=&gt;&nbsp;'my-data</tt>
<p><a name="./objects:s248"></a><span class=formdef><b>procedure</b>: <tt>(set-wrapper-procedure-data!&nbsp;<i>w-proc</i>&nbsp;<i>data</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>w-proc</i></tt> must be a wrapper procedure produced by either
<tt>make-wrapper-procedure</tt> or <tt>make-arity-wrapper-procedure</tt>.

<p>
Changes the data stored in <tt><i>w-proc</i></tt> to <tt><i>data</i></tt>.

<p>

<p><tt>(define&nbsp;vector3&nbsp;(make-wrapper-procedure&nbsp;vector&nbsp;8&nbsp;'my-data))<br>

(wrapper-procedure-data&nbsp;vector3)&nbsp;;&nbsp;=&gt;&nbsp;'my-data<br>

(set-wrapper-procedure-data!&nbsp;vector3&nbsp;'my-new-data)<br>

(wrapper-procedure-data&nbsp;vector3)&nbsp;;&nbsp;=&gt;&nbsp;'my-new-data</tt>
<p><a name="./objects:s249"></a><span class=formdef><b>procedure</b>: <tt>(set-wrapper-procedure-procedure!&nbsp;<i>w-proc</i>&nbsp;<i>proc</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>w-proc</i></tt> must be a wrapper procedure produced by either
<tt>make-wrapper-procedure</tt> or
<tt>make-arity-wrapper-procedure</tt>, and <tt><i>proc</i></tt> must be
a procedure.

<p>
Changes <tt><i>w-proc</i></tt> so that it behaves the same as <tt><i>proc</i></tt>, leaving the
results of <br>
 <tt>(procedure-arity-mask&nbsp;<i>w-proc</i>)</tt> and
<tt>(wrapper-procedure-data&nbsp;<i>w-proc</i>)</tt> unchanged.


<p>

<p><tt>(define&nbsp;vector3&nbsp;(make-wrapper-procedure&nbsp;vector&nbsp;8&nbsp;'my-data))<br>

(vector3&nbsp;1&nbsp;2&nbsp;3)&nbsp;;&nbsp;=&gt;&nbsp;#(1&nbsp;2&nbsp;3)<br>

(set-wrapper-procedure-procedure!&nbsp;vector3&nbsp;list)<br>

(vector3&nbsp;1&nbsp;2&nbsp;3)&nbsp;;&nbsp;=&gt;&nbsp;(1&nbsp;2&nbsp;3)</tt>
<p><a name="./objects:s250"></a><span class=formdef><b>procedure</b>: <tt>(procedure-known-single-valued?&nbsp;<i>proc</i>)</tt></span>
<br>
<b>returns: </b>a boolean indicating whether <tt><i>proc</i></tt> is known to always produce a single value
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Returns an approximate classification of <tt><i>proc</i></tt> as always having a
single result value or not. The result may be <tt>#f</tt> for a procedure
that always returns a single value, but with an implementation that was too
complex for the compiler to prove that fact. The result is <tt>#t</tt> only
for a procedure that always produces a single result value.




<hr class=copyright align=left>
<p>
<a class=plain href="index.html">Chez Scheme Version 10 User's Guide</a><br>
Copyright &copy; 2024 Cisco Systems, Inc.<br>
Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License Version 2.0</a>
(<a class=plain href="canned/copyright.html">full copyright notice.</a>).</br>
Revised November 2024 for Chez Scheme Version 10.1.0<br>
<a class=plain href="canned/about.html">about this book</a>
</tr></table>
</body>
</html>
