<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Thread System</title>
<link href="csug.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g142"></a>
<a name="./threads:h0"></a>

<h1>Chapter 15. Thread System<a name="CHPTTHREADS"></a></h1>





<p>
<a name="./threads:s0"></a>This chapter describes the <i>Chez Scheme</i> thread-system procedures
and syntactic forms.
With the exception of locks, locked increment, and locked decrement,
the features of the thread system are implemented on top of the Posix
thread system (pthreads) on non-Windows-based system and directly using
the Windows API on Windows-based systems.
Consult the appropriate documentation on your system for basic details
of thread creation and interaction.

<p>
Most primitive Scheme procedures are <a name="./threads:s1"></a><i>thread-safe</i>, meaning
that they can be called concurrently from multiple threads.
This includes allocation operations like <tt><i>cons</i></tt> and <tt>make-string</tt>,
accessors like <tt>car</tt> and <tt>vector-ref</tt>,
numeric operators like <tt>+</tt> and <tt>sqrt</tt>, and nondestructive
higher-level primitive operators like <tt>append</tt> and <tt>map</tt>.

<p>
Simple mutation operators, like <tt>set-car!</tt>, <tt>vector-set!</tt>,
and record field mutators are thread-safe.
Likewise, assignments to local variables, including assignments to
(unexported) library and top-level program variables are thread-safe.

<p>
Other destructive operators are thread safe only if they are used to
operate on different objects from those being read or modified by other
threads.
For example, assignments to global variables are thread-safe only as
long as one thread does not assign the same variable another thread
references or assigns.
Similarly, <tt>putprop</tt> can be called in one thread while another
concurrently calls <tt>putprop</tt> or <tt>getprop</tt> if the symbols
whose property lists are being modified or accessed differ.

<p>
In this context, most I/O operations should be considered destructive,
since they might modify a port's internal structure; see also
Section&nbsp;<a href="./threads.html#g151">15.9</a> for information on buffered ports.

<p>
Use of operators that are not thread-safe without proper synchronization
can corrupt the objects upon which they operate.
This corruption can lead to incorrect behavior, memory faults, and even
unrecoverable errors that cause the system to abort.

<p>
The compiler and interpreter are thread-safe to the extent that user code
evaluated during the compilation and evaluation process is thread-safe or
properly synchronized.
Thus, two or more threads
can call any of the compiler or interpreter entry points, i.e.,
<tt>compile</tt>, <tt>compile-file</tt>, <tt>compile-program</tt>, <tt>compile-script</tt>,
<tt>compile-port</tt>, or <tt>interpret</tt> at the same time.
Naturally, the object-file targets of two file compilation operations that
run at the same time should be different.
The same is true for <tt>eval</tt> and <tt>load</tt> as long as
the default evaluator is used or is set explicitly to <tt>compile</tt>,
<tt>interpret</tt>, or some other thread-safe evaluator.

<p>
One restriction should be observed when one of multiple threads creates or
loads compiled code, however, which is that only that thread or
subsequently created children, or children of subsequently created
children, etc., should run the code.
This is because multiple-processor systems upon which threaded code may
run might not guarantee that the data and instruction caches are
synchronized across processors.

<p>

<h3><a name="g143"></a><a name="./threads:h1"></a>Section 15.1. Thread Creation</h3>



<p>
<a name="./threads:s2"></a><span class=formdef><b>procedure</b>: <tt>(fork-thread&nbsp;<i>thunk</i>)</tt></span>
<br>
<b>returns: </b>a thread object
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>thunk</i></tt> must be a procedure that accepts zero arguments.

<p>
<tt>fork-thread</tt> invokes <tt><i>thunk</i></tt> in a new thread and returns
a thread object.

<p>
Threads created by foreign code using some means other than
<tt>fork-thread</tt> must call <tt>Sactivate_thread</tt>
(Section&nbsp;<a href="./foreign.html#g35">4.9</a>) before touching any Scheme data
or calling any Scheme procedures.

<p>
<a name="./threads:s3"></a><span class=formdef><b>procedure</b>: <tt>(thread-join&nbsp;<i>thread</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Waits until <tt><i>thread</i></tt> has completed.

<p>
<a name="./threads:s4"></a><span class=formdef><b>procedure</b>: <tt>(get-initial-thread)</tt></span>
<br>
<b>returns: </b>a thread object for the initial thread
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./threads:s5"></a><span class=formdef><b>procedure</b>: <tt>(thread?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a thread object, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./threads:s6"></a><span class=formdef><b>procedure</b>: <tt>(get-thread-id)</tt></span>
<br>
<b>returns: </b>the thread id of the current thread
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The thread id is a thread number assigned by thread id, and has no
relationship to the process id returned by
<a name="./threads:s7"></a><tt>get-process-id</tt>, which is the same
in all threads.

<p>
<a name="./threads:s8"></a><span class=formdef><b>procedure</b>: <tt>(thread-preserve-ownership!)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(thread-preserve-ownership!&nbsp;<i>thread</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Provides a hint to the storage manager that <tt><i>thread</i></tt> (which
defaults to the current thread if not supplied) can particularly
benefit from tracking the objects that it allocates for parallel
collection.

<p>

<h3><a name="g144"></a><a name="./threads:h2"></a>Section 15.2. Mutexes</h3>



<p>
<a name="./threads:s9"></a><span class=formdef><b>procedure</b>: <tt>(make-mutex)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-mutex&nbsp;<i>name</i>)</tt></span>
<br>
<b>returns: </b>a new mutex object
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>name</i></tt>, if supplied, must be a symbol which identifies the mutex, or
<tt>#f</tt> for no name. The name is printed every time the mutex is
printed, which is useful for debugging.

<p>
<a name="./threads:s10"></a><span class=formdef><b>procedure</b>: <tt>(mutex?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a mutex, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./threads:s11"></a><span class=formdef><b>procedure</b>: <tt>(mutex-acquire&nbsp;<i>mutex</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(mutex-acquire&nbsp;<i>mutex</i>&nbsp;<i>block?</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>mutex</i></tt> must be a mutex.

<p>
<tt><i>mutex-acquire</i></tt> acquires the mutex identified by <tt><i>mutex</i></tt>.
The optional boolean argument <tt><i>block?</i></tt> defaults to
<tt>#t</tt> and specifies whether the thread should block
waiting for the mutex.
If <tt><i>block?</i></tt> is omitted or is true, the thread
blocks until the mutex has been acquired, and an unspecified
value is returned.

<p>
If <tt>block?</tt> is false and the mutex currently belongs
to a different thread, the current thread does not block.
Instead, <tt>mutex-acquire</tt> returns
immediately with the value <tt>#f</tt> to
indicate that the mutex is not available.
If <tt><i>block?</i></tt> is false and the mutex is successfully
acquired, <tt>mutex-acquire</tt> returns <tt>#t</tt>.

<p>
Mutexes are <i>recursive</i> in Posix threads terminology, which
means that the calling thread can use <tt>mutex-acquire</tt> to
(re)acquire a mutex it already has.
In this case, an equal number of <tt>mutex-release</tt> calls
is necessary to release the mutex.

<p>
<a name="./threads:s12"></a><span class=formdef><b>procedure</b>: <tt>(mutex-release&nbsp;<i>mutex</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>mutex</i></tt> must be a mutex.

<p>
<tt>mutex-release</tt> releases the mutex identified by <tt><i>mutex</i></tt>.
Unpredictable behavior results if the mutex is not owned by the
calling thread.

<p>
<a name="./threads:s13"></a><span class=formdef><b>syntax</b>: <tt>(with-mutex&nbsp;<i>mutex</i>&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the values of the body <tt><i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>with-mutex</tt> evaluates the expression <tt><i>mutex</i></tt>, which must
evaluate to a mutex, acquires the mutex, evaluates the body
<tt><i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...</tt>, and releases the mutex.
The mutex is released whether the body returns normally or
via a control operation (that is, throw to a continuation, perhaps because
of an error) that results in
a nonlocal exit from the <tt>with-mutex</tt> form.
If control subsequently returns to the body via a
continuation invocation, the mutex is reacquired.

<p>
Using <tt>with-mutex</tt> is generally more convenient and safer than using
<tt>mutex-acquire</tt> and <tt>mutex-release</tt> directly.

<p>
<a name="./threads:s14"></a><span class=formdef><b>procedure</b>: <tt>(mutex-name&nbsp;<i>mutex</i>)</tt></span>
<br>
<b>returns: </b>the name associated with <tt><i>mutex</i></tt>, if any; otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>mutex</i></tt> must be a mutex.

<p>

<h3><a name="g145"></a><a name="./threads:h3"></a>Section 15.3. Conditions</h3>



<p>
<a name="./threads:s15"></a><span class=formdef><b>procedure</b>: <tt>(make-condition)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-condition&nbsp;<i>name</i>)</tt></span>
<br>
<b>returns: </b>a new condition object
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>name</i></tt>, if supplied, must be a symbol which identifies the condition
object, or <tt>#f</tt> for no name. The name is printed every time the
condition is printed, which is useful for debugging.

<p>
<a name="./threads:s16"></a><span class=formdef><b>procedure</b>: <tt>(thread-condition?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a condition object, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><a name="./threads:s17"></a><span class=formdef><b>procedure</b>: <tt>(condition-wait&nbsp;<i>cond</i>&nbsp;<i>mutex</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(condition-wait&nbsp;<i>cond</i>&nbsp;<i>mutex</i>&nbsp;<i>timeout</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the calling thread was awakened by the condition, <tt>#f</tt> if the calling thread timed out waiting
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>cond</i></tt> must be a condition object, and
<tt><i>mutex</i></tt> must be a mutex.
The optional argument <tt><i>timeout</i></tt> is a time record of type
<tt>time-duration</tt> or <tt>time-utc</tt>, or <tt>#f</tt> for no
timeout. It defaults to <tt>#f</tt>.

<p>
<tt>condition-wait</tt> waits up to the specified <tt><i>timeout</i></tt> for
the condition identified by the condition object <tt><i>cond</i></tt>.
The calling thread must have acquired the mutex identified by the mutex
<tt><i>mutex</i></tt> at the time <tt>condition-wait</tt> is
called.
<tt><i>mutex</i></tt> is released as a side effect of the call to
<tt>condition-wait</tt>.
When a thread is later released from the condition variable by one of
the procedures described below or the timeout expires, <tt><i>mutex</i></tt> is
reacquired and <tt>condition-wait</tt> returns.


<p>
<a name="./threads:s18"></a><span class=formdef><b>procedure</b>: <tt>(condition-signal&nbsp;<i>cond</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>cond</i></tt> must be a condition object.

<p>
<tt>condition-signal</tt> releases one of the threads waiting for the
condition identified by <tt><i>cond</i></tt>.


<p>
<a name="./threads:s19"></a><span class=formdef><b>procedure</b>: <tt>(condition-broadcast&nbsp;<i>cond</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>cond</i></tt> must be a condition object.

<p>
<tt>condition-broadcast</tt> releases all of the threads waiting for the
condition identified by <tt><i>cond</i></tt>.

<p>
<a name="./threads:s20"></a><span class=formdef><b>procedure</b>: <tt>(condition-name&nbsp;<i>condition</i>)</tt></span>
<br>
<b>returns: </b>the name associated with <tt><i>condition</i></tt>, if any; otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>condition</i></tt> must be a condition.

<p>

<h3><a name="g146"></a><a name="./threads:h4"></a>Section 15.4. Locks<a name="SECTTHREADLOCKS"></a></h3>



<p>
<a name="./threads:s21"></a>Locks are more primitive but more flexible and efficient than mutexes
and can be used in situations where the added mutex functionality
is not needed or desired.
They can also be used independently of the thread system
(including in nonthreaded versions of <i>Chez&nbsp;Scheme</i>)
to synchronize operations running in separate Scheme processes
as long as the lock is allocated in memory shared by the processes.

<p>
A lock is simply a word-sized integer, i.e., an <tt>iptr</tt> or
<tt>uptr</tt> foreign type (Section&nbsp;<a href="./foreign.html#g31">4.5</a>) with the native
endianness of the target machine, possibly part of a larger structure
defined using <tt>define-ftype</tt> (page&nbsp;<a href="./foreign.html#defn:define-ftype">78</a>).
It must be explicitly allocated in memory that resides outside the Scheme
heap and, when appropriate, explicitly deallocated.
When just threads are involved (i.e., when multiple processes are not 
involved), the memory can be allocated via <tt>foreign-alloc</tt>.
When multiple processes are involved, the lock should be allocated in
some area shared by the processes that will interact with the lock.

<p>
Once initialized using <tt>ftype-init-lock!</tt>, a process or thread
can attempt to lock the lock via <tt>ftype-lock!</tt> or <tt>ftype-spin-lock!</tt>.
Once the lock has been locked and before it is unlocked, further
attempts to lock the lock fail, even by the process or thread that
most recently locked it.
Locks can be unlocked, via <tt>ftype-unlock!</tt>, by any process or thread,
not just by the process or thread that most recently locked the lock.

<p>
The lock mechanism provides little structure, and mistakes
in allocation and use can lead to memory faults, deadlocks,
and other problems. Furthermore, no memory ordering is implied by a lock
operation, which means that <tt>memory-order-acquire</tt> and
<tt>memory-order-release</tt> may be needed to complete the intended
synchronization of a lock.
Thus, it is usually advisable to use locks only as part of a
higher-level abstraction that ensures locks are used in a
disciplined manner.

<p>

<p><tt>(define&nbsp;lock<br>

&nbsp;&nbsp;(make-ftype-pointer&nbsp;uptr<br>

&nbsp;&nbsp;&nbsp;&nbsp;(foreign-alloc&nbsp;(ftype-sizeof&nbsp;uptr))))
<br>
<br>
(ftype-init-lock!&nbsp;uptr&nbsp;()&nbsp;lock)<br>

(ftype-lock!&nbsp;uptr&nbsp;()&nbsp;lock)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#t,&nbsp;assuming&nbsp;no&nbsp;spurious&nbsp;failure<br>

(ftype-lock!&nbsp;uptr&nbsp;()&nbsp;lock)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(ftype-unlock!&nbsp;uptr&nbsp;()&nbsp;lock)<br>

(ftype-spin-lock!&nbsp;uptr&nbsp;()&nbsp;lock)<br>

(ftype-lock!&nbsp;uptr&nbsp;()&nbsp;lock)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;#f<br>

(ftype-unlock!&nbsp;uptr&nbsp;()&nbsp;lock)</tt>
<p><a name="./threads:s22"></a><span class=formdef><b>syntax</b>: <tt>(ftype-init-lock!&nbsp;<i>ftype-name</i>&nbsp;(<i>a</i>&nbsp;...)&nbsp;<i>fptr-expr</i>)</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>(ftype-init-lock!&nbsp;<i>ftype-name</i>&nbsp;(<i>a</i>&nbsp;...)&nbsp;<i>fptr-expr</i>&nbsp;<i>index</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br><span class=formdef><b>syntax</b>: <tt>(ftype-lock!&nbsp;<i>ftype-name</i>&nbsp;(<i>a</i>&nbsp;...)&nbsp;<i>fptr-expr</i>)</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>(ftype-lock!&nbsp;<i>ftype-name</i>&nbsp;(<i>a</i>&nbsp;...)&nbsp;<i>fptr-expr</i>&nbsp;<i>index</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the lock is not already locked, <tt>#f</tt> otherwise
<br><span class=formdef><b>syntax</b>: <tt>(ftype-spin-lock!&nbsp;<i>ftype-name</i>&nbsp;(<i>a</i>&nbsp;...)&nbsp;<i>fptr-expr</i>)</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>(ftype-spin-lock!&nbsp;<i>ftype-name</i>&nbsp;(<i>a</i>&nbsp;...)&nbsp;<i>fptr-expr</i>&nbsp;<i>index</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br><span class=formdef><b>syntax</b>: <tt>(ftype-unlock!&nbsp;<i>ftype-name</i>&nbsp;(<i>a</i>&nbsp;...)&nbsp;<i>fptr-expr</i>)</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>(ftype-unlock!&nbsp;<i>ftype-name</i>&nbsp;(<i>a</i>&nbsp;...)&nbsp;<i>fptr-expr</i>&nbsp;<i>index</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Each of these has a syntax like and behaves similarly to
<tt>ftype-set!</tt> (page&nbsp;<a href="./foreign.html#defn:ftype-set!">86</a>), though with an implicit
<tt><i>val-expr</i></tt>.
In particular, the restrictions on and handling of <tt><i>fptr-expr</i></tt>
and the accessors <tt><i>a</i>&nbsp;...</tt> is similar, with one important
restriction: the field specified by the last accessor, upon which
the form operates,  must be a word-size integer, i.e., an
<tt>iptr</tt>, <tt>uptr</tt>, or the equivalent, with the native
endianness.

<p>
<tt>ftype-init-lock!</tt> should be used to initialize the lock prior
to the use of any of the other operators; if this is not done, the
behavior of the other operators is undefined.

<p>
<tt>ftype-lock!</tt> can be used to lock the lock.
If it finds the lock unlocked at the time of the operation, it (normally) locks
the lock and returns <tt>#t</tt>; if it finds the lock already locked,
it returns <tt>#f</tt> without changing the lock. On an architecture with a weak memory model,
<tt>ftype-lock!</tt> can spuriously fail, leaving a lock unchanged and returning
<tt>#f</tt> even if the lock is currently unlocked. On success, no memory ordering is implied,
which means that <tt>memory-order-acquire</tt> may be
needed to complete an intended synchronization.

<p>
<tt>ftype-spin-lock!</tt> can also be used to lock the lock.
If it finds the lock unlocked at the time of the operation, it locks the
lock and returns; if it finds the lock already locked, it waits until
the lock is unlocked, then locks the lock and returns.
If no other thread or process unlocks the lock, the operation does
not return and cannot be interrupted by normal means, including by the
storage manager for the purpose of initiating a garbage collection.
There are also no guarantees of fairness, so a process might hang
indefinitely even if other processes are actively locking and unlocking
the lock.

<p>
<tt>ftype-unlock!</tt> is used to unlock a lock.
If it finds the lock locked, it unlocks the lock and returns.
Otherwise, it returns without changing the lock.
On an architecture with a weak memory model,
no memory ordering is implied, and <tt>memory-order-release</tt> may be
needed to complete an intended synchronization.

<p>

<h3><a name="g147"></a><a name="./threads:h5"></a>Section 15.5. Locked increment and decrement<a name="SECTTHREADLOCKEDINCRDECR"></a></h3>



<p>
The locked operations described here can be used when just an atomic
increment or decrement is required.

<p>
<a name="./threads:s23"></a><span class=formdef><b>syntax</b>: <tt>(ftype-locked-incr!&nbsp;<i>ftype-name</i>&nbsp;(<i>a</i>&nbsp;...)&nbsp;<i>fptr-expr</i>)</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>(ftype-locked-incr!&nbsp;<i>ftype-name</i>&nbsp;(<i>a</i>&nbsp;...)&nbsp;<i>fptr-expr</i>&nbsp;<i>index</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the updated value is 0, <tt>#f</tt> otherwise
<br><span class=formdef><b>syntax</b>: <tt>(ftype-locked-decr!&nbsp;<i>ftype-name</i>&nbsp;(<i>a</i>&nbsp;...)&nbsp;<i>fptr-expr</i>)</tt></span>
<br><span class=formdef><b>syntax</b>: <tt>(ftype-locked-decr!&nbsp;<i>ftype-name</i>&nbsp;(<i>a</i>&nbsp;...)&nbsp;<i>fptr-expr</i>&nbsp;<i>index</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the updated value is 0, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Each of these has a syntax like and behaves similarly to
<tt>ftype-set!</tt> (page&nbsp;<a href="./foreign.html#defn:ftype-set!">86</a>), though with an implicit
<tt><i>val-expr</i></tt>.
In particular, the restrictions on and handling of <tt><i>fptr-expr</i></tt>
and the accessors <tt><i>a</i>&nbsp;...</tt> is similar, with one important
restriction: the field specified by the last accessor, upon which
the form operates,  must be a word-size integer, i.e., an
<tt>iptr</tt>, <tt>uptr</tt>, or the equivalent, with the native
endianness.

<p>
<tt>ftype-locked-incr!</tt> atomically reads the value of the specified
field, adds 1 to the value, and writes the new value back into the
field.
Similarly, <tt>ftype-locked-decr!</tt> atomically reads the value of
the specified field, subtracts 1 from the value, and writes the new
value back into the field.
Both return <tt>#t</tt> if the new value is 0, otherwise <tt>#f</tt>.

<p>

<h3><a name="g148"></a><a name="./threads:h6"></a>Section 15.6. Reference counting with ftype guardians<a name="SECTTHREADFTYPEGUARDIANS"></a></h3>



<p>
<a name="./threads:s24"></a>Applications that manage memory outside the Scheme heap can leverage
the Scheme storage management system to help perform reference
counting via <i>ftype guardians</i>.
In a reference-counted memory management system, each object holds
a count of pointers to it.
The count is incremented when a new pointer is created and decremented
when a pointer is dropped.
When the count reaches zero, the object is no longer needed and the
memory it formerly occupied can be made available for some other
purpose.

<p>
Ftype guardians are similar to guardians created by
<a name="./threads:s25"></a><tt>make-guardian</tt>
(Section&nbsp;<a href="./smgmt.html#g133">13.2</a>).
The <a name="./threads:s26"></a><tt>guardian?</tt> procedure returns
true for both, and the
<a name="./threads:s27"></a><tt>unregister-guardian</tt>
procedure can be used to unregister objects registered with either.

<p>
<a name="./threads:s28"></a><span class=formdef><b>syntax</b>: <tt>(ftype-guardian&nbsp;<i>ftype-name</i>)</tt></span>
<br>
<b>returns: </b>a new ftype guardian
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>ftype-name</i></tt> must name an ftype.
The first base field of the ftype (or one of the first base fields
in the case of unions) must be a word-sized integer (iptr or uptr)
with native endianness.
This field is assumed to hold a reference count.

<p>
The return value is a new ftype guardian <tt><i>g</i></tt>, with which
ftype-pointers of type <tt><i>ftype-name</i></tt> (or some subtype of
<tt><i>ftype-name</i></tt>) can be registered.
An ftype pointer is registered with <tt><i>g</i></tt> by invoking <tt><i>g</i></tt>
with the ftype pointer as an argument.

<p>
An ftype guardian does not automatically protect from collection
the ftype pointers registered with it,  as a normal guardian would
do.
Instead, for each registered ftype pointer that becomes inaccessible
via normal (non-weak, non-guardian pointers), the guardian decrements
the reference count of the object to which the ftype pointer points.
If the resulting reference-count value is zero, the ftype pointer
is preserved and can be retrieved from the guardian.
If the resulting reference-count value is non-zero, however, the
ftype pointer is not preserved.
Objects retrieved from an ftype guardian (by calling it without
arguments) are guaranteed to have zero reference counts, assuming
reference counts are maintained properly by code outside the
collector.

<p>
The collector decrements the reference count using the equivalent
of <a name="./threads:s29"></a><tt>ftype-locked-decr!</tt>
to support systems in which non-Scheme objects are stored in memory
shared by multiple processes.
In such systems, programs should themselves use
<a name="./threads:s30"></a><tt>ftype-locked-incr!</tt> and
<tt>ftype-locked-decr!</tt> or non-Scheme equivalents (e.g., the C
<a name="./threads:s31"></a><tt>LOCKED_INCR</tt> and
<a name="./threads:s32"></a><tt>LOCKED_DECR</tt> macros in scheme.h,
which are described in Section&nbsp;<a href="./foreign.html#g35">4.9</a>) to maintain
reference counts.

<p>
The following example defines a simple ftype and an allocator for
objects of that ftype that frees any objects of that ftype that were
previously allocated and no longer accessible.

<p>

<p><tt>(module&nbsp;(A&nbsp;make-A&nbsp;free-dropped-As)<br>

&nbsp;&nbsp;(define-ftype&nbsp;A<br>

&nbsp;&nbsp;&nbsp;&nbsp;(struct<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[refcount&nbsp;uptr]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[data&nbsp;int]))<br>

&nbsp;&nbsp;(define&nbsp;g&nbsp;(ftype-guardian&nbsp;A))<br>

&nbsp;&nbsp;(define&nbsp;free-dropped-As<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([a&nbsp;(g)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;a<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(printf&nbsp;"freeing&nbsp;~s\n"&nbsp;(ftype-ref&nbsp;A&nbsp;(data)&nbsp;a))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(foreign-free&nbsp;(ftype-pointer-address&nbsp;a))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(free-dropped-As)))))<br>

&nbsp;&nbsp;(define&nbsp;make-A<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(free-dropped-As)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([a&nbsp;(make-ftype-pointer&nbsp;A&nbsp;(foreign-alloc&nbsp;(ftype-sizeof&nbsp;A)))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ftype-set!&nbsp;A&nbsp;(refcount)&nbsp;a&nbsp;1)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ftype-set!&nbsp;A&nbsp;(data)&nbsp;a&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(g&nbsp;a)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a))))</tt>
<p>We can test this by allocating, dropping, and immediately collecting
ftype pointers to A.

<p>

<p><tt>&gt;&nbsp;(do&nbsp;([i&nbsp;10&nbsp;(fx-&nbsp;i&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((fx=&nbsp;i&nbsp;0))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(make-A&nbsp;i)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(collect))<br>

freeing&nbsp;10<br>

freeing&nbsp;9<br>

freeing&nbsp;8<br>

freeing&nbsp;7<br>

freeing&nbsp;6<br>

freeing&nbsp;5<br>

freeing&nbsp;4<br>

freeing&nbsp;3<br>

freeing&nbsp;2<br>

&gt;&nbsp;(free-dropped-As)<br>

freeing&nbsp;1</tt>
<p>Objects guarded by an ftype guardian might contain pointers to other
objects whose reference counts should also be incremented upon
allocation of the containing object and decremented upon freeing
of the containing object.



<p>

<h3><a name="g149"></a><a name="./threads:h7"></a>Section 15.7. Memory Consistency<a name="SECTSMGMTMEMMODEL"></a></h3>



<p>
Scheme threads can expose the memory-consistency model of the
underlying processor, except to the degree that it would interfere
with the memory safety of Scheme programs. For example, if two threads
share a vector, then a <tt>vector-set!</tt> in one thread will not
allow the other thread to read the vector and see a partially
constructed primitive object installed into the vector; the Scheme
system includes a memory fence around operations and on platforms as
needed to preserve safety. There's no guarantee, for example, that
assigning to multiple slots in an fxvector will become visible in the
same order to other threads that share the vector, because no such
ordering is required to preserve memory safety.

<p>
<a name="./threads:s33"></a><span class=formdef><b>procedure</b>: <tt>(memory-order-acquire)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(memory-order-release)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>These procedures fence memory operations in a way that is consistent
with acquire-release patterns. Specifically,
<tt>memory-order-acquire</tt> ensures at least a load-load and
load-store fence, and <tt>memory-order-release</tt> ensures at least
a store-store and store-load fence.


<p>

<h3><a name="g150"></a><a name="./threads:h8"></a>Section 15.8. Thread Parameters<a name="SECTTHREADPARAMETERS"></a></h3>



<p>
<a name="./threads:s34"></a><span class=formdef><b>procedure</b>: <tt>(make-thread-parameter&nbsp;<i>object</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(make-thread-parameter&nbsp;<i>object</i>&nbsp;<i>procedure</i>)</tt></span>
<br>
<b>returns: </b>a new thread parameter
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>See Section&nbsp;<a href="./system.html#g127">12.13</a> for a general
discussion of parameters and the use of the optional second argument.

<p>
When a thread parameter is created, a separate location is set aside
in each current and future thread to hold the value of the parameter's
internal state variable.
(This location may be eliminated by the storage manager when the
parameter becomes inaccessible.)
Changes to the thread parameter in one thread are not seen by any
other thread.

<p>
When a new thread is created (see <tt>fork-thread</tt>),
the current value (not location) of each
thread parameter is inherited from the forking thread by the new thread.
Similarly, when a thread created by some other means is activated for the
first time (see <tt>Sactivate_thread</tt> in
Section&nbsp;<a href="./foreign.html#g35">4.9</a>), the current value (not location) of each
thread parameter is inherited from the main (original) thread by the new
thread.

<p>
Most built-in parameters are thread parameters, but some are global.
All are marked as global or thread where they are defined.
There is no distinction between built-in global and thread parameters
in the nonthreaded versions of the system.


<p>

<h3><a name="g151"></a><a name="./threads:h9"></a>Section 15.9. Buffered I/O<a name="SECTTHREADSBUFFEREDIO"></a></h3>



<p>
Chez Scheme buffers file I/O operations for efficiency, but buffered
I/O is not thread safe.
Two threads that write to or read from the same buffered port concurrently
can corrupt the port, resulting in buffer overruns and, ultimately,
invalid memory references.

<p>
Buffering on binary output ports can be disabled when opened with
buffer-mode <tt>none</tt>.
Buffering on input ports cannot be completely disabled, however, due to
the need to support lookahead, and buffering on textual ports, even
textual output ports, cannot be disabled completely because the
transcoders that convert between characters and bytes sometimes
require some lookahead.

<p>
Two threads should thus <i>never</i> read from or write to the same port
concurrently, except in the special case of a binary output port
opened buffer-mode <tt>none</tt>.
Alternatives include appointing one thread to perform all I/O for a
given port and providing a per-thread generic-port wrapper that
forwards requests to the port only after acquiring a mutex.

<p>
The initial console and current input and output ports are thread-safe,
as are transcript ports, so it is safe for multiple threads to print error
and/or debugging messages to the console.
The output may be interleaved, even within the same line, but the port
will not become corrupted.
Thread safety for these ports is accomplished at the high cost of
acquiring a mutex for each I/O operation.


<p>

<h3><a name="g152"></a><a name="./threads:h10"></a>Section 15.10. Example: Bounded Queues</h3>



<p>
The following code, taken from the article
"A Scheme for native threads&nbsp;[<a class=citation href="./bibliography.html#g167">10</a>],"
implements a bounded queue using many of the
thread-system features.
A bounded queue has a fixed number of available slots.  
Attempting to enqueue when the queue is full causes the calling thread
to block.  
Attempting to dequeue from an empty queue causes the calling thread
to block.


<p>

<p><tt>(define-record-type&nbsp;bq<br>

&nbsp;&nbsp;(fields<br>

&nbsp;&nbsp;&nbsp;&nbsp;(immutable&nbsp;data)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(mutable&nbsp;head)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(mutable&nbsp;tail)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(immutable&nbsp;mutex)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(immutable&nbsp;ready)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(immutable&nbsp;room))<br>

&nbsp;&nbsp;(protocol<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(new)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(bound)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(new&nbsp;(make-vector&nbsp;bound)&nbsp;0&nbsp;0&nbsp;(make-mutex)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-condition)&nbsp;(make-condition))))))
<br>
<br>
(define&nbsp;dequeue!<br>

&nbsp;&nbsp;(lambda&nbsp;(q)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(with-mutex&nbsp;(bq-mutex&nbsp;q)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;loop&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([head&nbsp;(bq-head&nbsp;q)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(=&nbsp;head&nbsp;(bq-tail&nbsp;q))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(condition-wait&nbsp;(bq-ready&nbsp;q)&nbsp;(bq-mutex&nbsp;q))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bq-head-set!&nbsp;q&nbsp;(incr&nbsp;q&nbsp;head))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(condition-signal&nbsp;(bq-room&nbsp;q))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-ref&nbsp;(bq-data&nbsp;q)&nbsp;head)]))))))
<br>
<br>
(define&nbsp;enqueue!<br>

&nbsp;&nbsp;(lambda&nbsp;(item&nbsp;q)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(with-mutex&nbsp;(bq-mutex&nbsp;q)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;loop&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;([tail&nbsp;(bq-tail&nbsp;q)]&nbsp;[tail^&nbsp;(incr&nbsp;q&nbsp;tail)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(=&nbsp;tail^&nbsp;(bq-head&nbsp;q))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(condition-wait&nbsp;(bq-room&nbsp;q)&nbsp;(bq-mutex&nbsp;q))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-set!&nbsp;(bq-data&nbsp;q)&nbsp;tail&nbsp;item)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bq-tail-set!&nbsp;q&nbsp;tail^)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(condition-signal&nbsp;(bq-ready&nbsp;q))]))))))
<br>
<br>
(define&nbsp;incr<br>

&nbsp;&nbsp;(lambda&nbsp;(q&nbsp;i)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(modulo&nbsp;(+&nbsp;i&nbsp;1)&nbsp;(vector-length&nbsp;(bq-data&nbsp;q)))))</tt>
<p>The code below demonstrates the use of the bounded queue abstraction
with a set of threads that act as consumers and producers of the
data in the queue.

<p>

<p><tt>(define&nbsp;job-queue)<br>

(define&nbsp;die?&nbsp;#f)
<br>
<br>
(define&nbsp;make-job<br>

&nbsp;&nbsp;(let&nbsp;([count&nbsp;0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;fib<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;n&nbsp;2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(fib&nbsp;(-&nbsp;n&nbsp;2))&nbsp;(fib&nbsp;(-&nbsp;n&nbsp;1))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;count&nbsp;(+&nbsp;count&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(printf&nbsp;"Adding&nbsp;job&nbsp;#~s&nbsp;=&nbsp;(lambda&nbsp;()&nbsp;(fib&nbsp;~s))\n"&nbsp;count&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;count&nbsp;(lambda&nbsp;()&nbsp;(fib&nbsp;n))))))
<br>
<br>
(define&nbsp;make-producer<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(rec&nbsp;producer<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(printf&nbsp;"producer&nbsp;~s&nbsp;posting&nbsp;a&nbsp;job\n"&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(enqueue!&nbsp;(make-job&nbsp;(+&nbsp;20&nbsp;(random&nbsp;10)))&nbsp;job-queue)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;die?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(printf&nbsp;"producer&nbsp;~s&nbsp;dying\n"&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(producer))))))
<br>
<br>
(define&nbsp;make-consumer<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(rec&nbsp;consumer<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(printf&nbsp;"consumer&nbsp;~s&nbsp;looking&nbsp;for&nbsp;a&nbsp;job~%"&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([job&nbsp;(dequeue!&nbsp;job-queue)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;die?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(printf&nbsp;"consumer&nbsp;~s&nbsp;dying\n"&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(printf&nbsp;"consumer&nbsp;~s&nbsp;executing&nbsp;job&nbsp;#~s~%"&nbsp;n&nbsp;(car&nbsp;job))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(printf&nbsp;"consumer&nbsp;~s&nbsp;computed:&nbsp;&nbsp;~s~%"&nbsp;n&nbsp;((cdr&nbsp;job)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(consumer))))))))
<br>
<br>
(define&nbsp;(bq-test&nbsp;np&nbsp;nc)<br>

&nbsp;&nbsp;(set!&nbsp;job-queue&nbsp;(make-bq&nbsp;(max&nbsp;nc&nbsp;np)))<br>

&nbsp;&nbsp;(do&nbsp;([np&nbsp;np&nbsp;(-&nbsp;np&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&lt;=&nbsp;np&nbsp;0))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fork-thread&nbsp;(make-producer&nbsp;np)))<br>

&nbsp;&nbsp;(do&nbsp;([nc&nbsp;nc&nbsp;(-&nbsp;nc&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&lt;=&nbsp;nc&nbsp;0))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fork-thread&nbsp;(make-consumer&nbsp;nc))))</tt>
<p>Here are a possible first several lines of output from a sample run of the example program.

<p>

<p><tt>&gt;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;(bq-test&nbsp;3&nbsp;4)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(system&nbsp;"sleep&nbsp;3")<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;die?&nbsp;#t))<br>

producer&nbsp;3&nbsp;posting&nbsp;a&nbsp;job<br>

Adding&nbsp;job&nbsp;#1&nbsp;=&nbsp;(lambda&nbsp;()&nbsp;(fib&nbsp;29))<br>

producer&nbsp;3&nbsp;posting&nbsp;a&nbsp;job<br>

Adding&nbsp;job&nbsp;#2&nbsp;=&nbsp;(lambda&nbsp;()&nbsp;(fib&nbsp;26))<br>

producer&nbsp;3&nbsp;posting&nbsp;a&nbsp;job<br>

Adding&nbsp;job&nbsp;#3&nbsp;=&nbsp;(lambda&nbsp;()&nbsp;(fib&nbsp;22))<br>

producer&nbsp;3&nbsp;posting&nbsp;a&nbsp;job<br>

Adding&nbsp;job&nbsp;#4&nbsp;=&nbsp;(lambda&nbsp;()&nbsp;(fib&nbsp;21))<br>

producer&nbsp;2&nbsp;posting&nbsp;a&nbsp;job<br>

Adding&nbsp;job&nbsp;#5&nbsp;=&nbsp;(lambda&nbsp;()&nbsp;(fib&nbsp;29))<br>

producer&nbsp;1&nbsp;posting&nbsp;a&nbsp;job<br>

Adding&nbsp;job&nbsp;#6&nbsp;=&nbsp;(lambda&nbsp;()&nbsp;(fib&nbsp;29))<br>

consumer&nbsp;4&nbsp;looking&nbsp;for&nbsp;a&nbsp;job<br>

producer&nbsp;3&nbsp;posting&nbsp;a&nbsp;job<br>

Adding&nbsp;job&nbsp;#7&nbsp;=&nbsp;(lambda&nbsp;()&nbsp;(fib&nbsp;24))<br>

consumer&nbsp;4&nbsp;executing&nbsp;job&nbsp;#1<br>

consumer&nbsp;3&nbsp;looking&nbsp;for&nbsp;a&nbsp;job<br>

producer&nbsp;2&nbsp;posting&nbsp;a&nbsp;job<br>

Adding&nbsp;job&nbsp;#8&nbsp;=&nbsp;(lambda&nbsp;()&nbsp;(fib&nbsp;26))<br>

consumer&nbsp;3&nbsp;executing&nbsp;job&nbsp;#2<br>

consumer&nbsp;3&nbsp;computed:&nbsp;&nbsp;121393<br>

consumer&nbsp;3&nbsp;looking&nbsp;for&nbsp;a&nbsp;job<br>

producer&nbsp;1&nbsp;posting&nbsp;a&nbsp;job<br>

Adding&nbsp;job&nbsp;#9&nbsp;=&nbsp;(lambda&nbsp;()&nbsp;(fib&nbsp;26))<br>

...</tt>
<p>Additional examples, including definitions of suspendable threads and
threads that automatically terminate when they become inaccessible, are
given in "A Scheme for native threads&nbsp;[<a class=citation href="./bibliography.html#g167">10</a>]."


<p>




<hr class=copyright align=left>
<p>
<a class=plain href="index.html">Chez Scheme Version 10 User's Guide</a><br>
Copyright &copy; 2024 Cisco Systems, Inc.<br>
Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License Version 2.0</a>
(<a class=plain href="canned/copyright.html">full copyright notice.</a>).</br>
Revised November 2024 for Chez Scheme Version 10.1.0<br>
<a class=plain href="canned/about.html">about this book</a>
</tr></table>
</body>
</html>
