<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Control Structures</title>
<link href="csug.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g43"></a>
<a name="./control:h0"></a>

<h1>Chapter 6. Control Structures<a name="CHPTCONTROL"></a></h1>





<p>
This chapter describes <i>Chez&nbsp;Scheme</i> extensions to the set of standard
control structures.
See Chapter&nbsp;<a href="http://scheme.com/tspl4/./control.html#g96">5</a> of <i>The Scheme Programming Language, 4th Edition</i> or the Revised<sup>6</sup> Report
on Scheme for a description of standard control structures.


<p>

<h3><a name="g44"></a><a name="./control:h1"></a>Section 6.1. Conditionals</h3>



<p>
<a name="./control:s0"></a><span class=formdef><b>syntax</b>: <tt>(exclusive-cond&nbsp;<i>clause<sub>1</sub></i>&nbsp;<i>clause<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>exclusive-cond</tt> is a version of <tt>cond</tt>
(Section&nbsp;<a href="http://scheme.com/tspl4/./control.html#g99">5.3</a> of TSPLFOUR) that differs
from <tt>cond</tt> in that the tests embedded within the clauses
are assumed to be exclusive in the sense that if one of the tests
is true, the others are not.
This allows the implementation to reorder clauses when profiling
information is available at expansion time (Section&nbsp;<a href="./system.html#g121">12.7</a>).

<p>
The <tt>(<i>test</i>)</tt> form of clause is not supported.
The order chosen when profiling information is available is based
on the relative numbers of times the RHS of each clause is executed,
and <tt>(<i>test</i>)</tt> has no RHS.
<tt>(<i>test</i>&nbsp;=&gt;&nbsp;values)</tt> is equivalent, albeit less concise.

<p>
<a name="./control:s1"></a><span class=formdef><b>syntax</b>: <tt>(case&nbsp;<i>expr<sub>0</sub></i>&nbsp;<i>clause<sub>1</sub></i>&nbsp;<i>clause<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Each clause but the last must take one of the forms:

<p>

<p><tt>((<i>key</i>&nbsp;...)&nbsp;<i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...)<br>

(<i>key</i>&nbsp;<i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...)</tt>
<p>where each <tt><i>key</i></tt> is a datum distinct from the other keys.
The last clause may be in the above form or it may be an
<a name="./control:s2"></a><tt>else</tt> clause of the form

<p>

<p><tt>(else&nbsp;<i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...)</tt>
<p><tt><i>expr<sub>0</sub></i></tt> is evaluated and the result is compared
(using <tt>equal?</tt>) against the keys of each clause in order.
If a clause containing a matching key is found, the
expressions <tt><i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...</tt> are evaluated in sequence
and the values of the last expression are returned.

<p>
If none of the clauses contains a matching key and an <tt>else</tt> clause
is present, the expressions <tt><i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...</tt> of the
<tt>else</tt> clause are evaluated in sequence and the values of the last
expression are returned.

<p>
If none of the clauses contains a matching key and no <tt>else</tt> clause
is present, the value or values are unspecified.

<p>
The Revised<sup>6</sup> Report version of <tt>case</tt> does not support singleton
keys (the second of the first two clause forms above) and uses
<tt>eqv?</tt> rather than <tt>equal?</tt> as the comparison procedure.
Both versions are defined in terms of <tt>exclusive-cond</tt> so that
if profiling information is available at expansion time, the clauses will
be reordered to put those that are most frequently executed first.

<p>

<p><tt>(let&nbsp;([ls&nbsp;'(ii&nbsp;iv)])<br>

&nbsp;&nbsp;(case&nbsp;(car&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;[i&nbsp;1]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[ii&nbsp;2]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[iii&nbsp;3]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(iiii&nbsp;iv)&nbsp;4]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;'out-of-range]))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2
<br>
<br>
(define&nbsp;p<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(case&nbsp;x<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[("abc"&nbsp;"def")&nbsp;'one]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[((a&nbsp;b&nbsp;c))&nbsp;'two]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;#f])))
<br>
<br>
(p&nbsp;(string&nbsp;#\d&nbsp;#\e&nbsp;#\f))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;one<br>

(p&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;two</tt>
<p><a name="./control:s3"></a><span class=formdef><b>syntax</b>: <tt>(record-case&nbsp;<i>expr</i>&nbsp;<i>clause<sub>1</sub></i>&nbsp;<i>clause<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see explanation
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>record-case</tt> is a restricted form of <tt>case</tt> that supports the
destructuring of <a name="./control:s4"></a><i>records</i>, or <a name="./control:s5"></a><i>tagged lists</i>.
A record has as its first element a tag that determines what "type"
of record it is; the remaining elements are the fields of the record.

<p>
Each clause but the last must take the form

<p>

<p><tt>((<i>key</i>&nbsp;...)&nbsp;<i>formals</i>&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p>where each <tt><i>key</i></tt> is a datum distinct from the other keys.
The last clause may be in the above form or it may be an
<a name="./control:s6"></a><tt>else</tt> clause of the form

<p>

<p><tt>(else&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p><tt><i>expr</i></tt> must evaluate to a pair.
<tt><i>expr</i></tt> is evaluated and the car of its value is compared
(using <tt>eqv?</tt>) against the keys of each clause in order.
If a clause containing a matching key is found, the variables in
<tt><i>formals</i></tt> are bound to the remaining elements
of the list and the expressions
<tt><i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...</tt> are evaluated in sequence.
The value of the last expression is returned.
The effect is identical to the application of

<p>

<p><tt>(lambda&nbsp;<i>formals</i>&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p>to the cdr of the list.

<p>
If none of the clauses contains a matching key and an <tt>else</tt> clause
is present, the expressions <tt><i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...</tt> of the
<tt>else</tt> clause are evaluated in sequence and the value of the last
expression is returned.

<p>
If none of the clauses contains a matching key and no <tt>else</tt> clause
is present, the value is unspecified.


<p>

<p><tt>(define&nbsp;calc<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(record-case&nbsp;x<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(add)&nbsp;(x&nbsp;y)&nbsp;(+&nbsp;x&nbsp;y)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(sub)&nbsp;(x&nbsp;y)&nbsp;(-&nbsp;x&nbsp;y)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(mul)&nbsp;(x&nbsp;y)&nbsp;(*&nbsp;x&nbsp;y)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(div)&nbsp;(x&nbsp;y)&nbsp;(/&nbsp;x&nbsp;y)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(assertion-violationf&nbsp;'calc&nbsp;"invalid&nbsp;expression&nbsp;~s"&nbsp;x)])))
<br>
<br>
(calc&nbsp;'(add&nbsp;3&nbsp;4))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;7<br>

(calc&nbsp;'(div&nbsp;3&nbsp;4))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3/4</tt>
<p>
<h3><a name="g45"></a><a name="./control:h2"></a>Section 6.2. Mapping and Folding</h3>



<p>
<a name="./control:s7"></a><span class=formdef><b>procedure</b>: <tt>(ormap&nbsp;<i>procedure</i>&nbsp;<i>list<sub>1</sub></i>&nbsp;<i>list<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see explanation
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>ormap</tt> is identical to the Revised<sup>6</sup> Report <tt>exists</tt>.

<p>
<a name="./control:s8"></a><span class=formdef><b>procedure</b>: <tt>(andmap&nbsp;<i>procedure</i>&nbsp;<i>list<sub>1</sub></i>&nbsp;<i>list<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see explanation
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>andmap</tt> is identical to the Revised<sup>6</sup> Report <tt>for-all</tt>.


<p>

<h3><a name="g46"></a><a name="./control:h3"></a>Section 6.3. Continuations</h3>



<p>
<i>Chez&nbsp;Scheme</i> supports one-shot continuations as well as the standard
multi-shot continuations obtainable via <tt>call/cc</tt>.
One-shot continuations are continuations that may be invoked at most
once, whether explicitly or implicitly.
They are obtained with <tt>call/1cc</tt>.

<p>
Continuation <i>marks</i> support efficient annotation of continuations
and inspection of those annotations. Each continuation has a table of
marks, where each mark is a key-value pair.  This table is updated using
the <tt>with-continuation-mark</tt> form to associate a key with a value,
replacing any existing association for that key.  Although each
continuation has a single immediate table of marks, a continuation may
extend another continuation that has its own marks.  The
<tt>current-continuation-marks</tt> function captures the sequence of mark
tables for a continuation and all continuations that it extends. Functions such as
<tt>continuation-marks-first</tt>,
<tt>continuation-marks-&gt;list</tt>, and
<tt>continuation-marks-&gt;iterator</tt> can be used to inspect mark
sequences. When a continuation is captured with <tt>call/cc</tt>, only the
marks of the rest of the continuation are captured, and
<tt>continuation-next-marks</tt> returns the captured marks.

<p>
<a name="./control:s9"></a><span class=formdef><b>procedure</b>: <tt>(call/1cc&nbsp;<i>procedure</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>call/1cc</tt> obtains its continuation and passes it to <tt><i>procedure</i></tt>,
which should accept one argument.
The continuation itself is represented by a procedure.
This procedure normally takes one argument but may take an arbitrary
number of arguments depending upon whether the context of the call
to <tt>call/1cc</tt>
expects multiple return values or not.
When this procedure is applied to a value or values, it returns the values
to the continuation of the <tt>call/1cc</tt> application.

<p>
The continuation obtained by <tt>call/1cc</tt> is a
<a name="./control:s10"></a>"one-shot continuation."
A one-shot continuation should not be returned to multiple times, either
by invoking the continuation or returning normally from <tt><i>procedure</i></tt> more
than once.
A one-shot continuation is "promoted" into a normal (multishot)
continuation, however, if it is 
still active when a
normal continuation is obtained by <tt>call/cc</tt>.
After a one-shot continuation is promoted into a multishot continuation,
it behaves exactly as if it had been obtained via <tt>call/cc</tt>.
This allows <tt>call/cc</tt> and <tt>call/1cc</tt> to be used together
transparently in many applications.

<p>
One-shot continuations may be more efficient for some applications than
multishot continuations.
See the paper "Representing control in the presence of one-shot
continuations"&nbsp;[<a class=citation href="./bibliography.html#g160">3</a>] for more information about
one-shot continuations, including how they are implemented in
<i>Chez&nbsp;Scheme</i>.

<p>
The following examples highlight the similarities and differences
between one-shot and normal continuations.

<p>

<p><tt>(define&nbsp;prod<br>

&nbsp;;&nbsp;compute&nbsp;the&nbsp;product&nbsp;of&nbsp;the&nbsp;elements&nbsp;of&nbsp;ls,&nbsp;bugging&nbsp;out<br>

&nbsp;;&nbsp;with&nbsp;no&nbsp;multiplications&nbsp;if&nbsp;a&nbsp;zero&nbsp;element&nbsp;is&nbsp;found<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;(car&nbsp;ls)&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(k&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(car&nbsp;ls)&nbsp;((prod&nbsp;(cdr&nbsp;ls))&nbsp;k)))))))
<br>
<br>
(call/cc&nbsp;(prod&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;24<br>

(call/1cc&nbsp;(prod&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;24
<br>
<br>
(call/cc&nbsp;(prod&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4&nbsp;0)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0<br>

(call/1cc&nbsp;(prod&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4&nbsp;0)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0
<br>
<br>
(let&nbsp;([k&nbsp;(call/cc&nbsp;(lambda&nbsp;(x)&nbsp;x))])<br>

&nbsp;&nbsp;(k&nbsp;(lambda&nbsp;(x)&nbsp;0)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;0
<br>
<br>
(let&nbsp;([k&nbsp;(call/1cc&nbsp;(lambda&nbsp;(x)&nbsp;x))])<br>

&nbsp;&nbsp;(k&nbsp;(lambda&nbsp;(x)&nbsp;0)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;<i>exception</i></tt>
<p><a name="./control:s11"></a><a name="dynamic-wind"></a>
<span class=formdef><b>procedure</b>: <tt>(dynamic-wind&nbsp;<i>in</i>&nbsp;<i>body</i>&nbsp;<i>out</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(dynamic-wind&nbsp;<i>critical?</i>&nbsp;<i>in</i>&nbsp;<i>body</i>&nbsp;<i>out</i>)</tt></span>
<br>
<b>returns: </b>values resulting from the application of <tt><i>body</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>The first form is identical to the Revised<sup>6</sup> Report <tt>dynamic-wind</tt>.
When the optional <tt><i>critical?</i></tt> argument is present and non-false,
the <tt><i>in</i></tt> thunk is invoked in a critical section along with the code
that records that the body has been entered, and the <tt><i>out</i></tt> thunk is
invoked in a critical section along with the code that records
that the body has been exited.
Extreme caution must be taken with this form of <tt>dynamic-wind</tt>,
since an error or long-running computation can leave interrupts
and automatic garbage collection disabled.

<p>
<a name="./control:s12"></a><a name="with-continuation-mark"></a>
<span class=formdef><b>syntax</b>: <tt>(with-continuation-mark&nbsp;<i>key</i>&nbsp;<i>val</i>&nbsp;<i>body</i>)</tt></span>
<br>
<b>returns: </b>the value of the <tt><i>body</i></tt> expression
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt>with-continuation-mark</tt> updates the table of marks
on the current continuation to map the result of the <tt><i>key</i></tt>
expression to the result of the <tt><i>val</i></tt> expression. If the current
continuation's table of marks already has a mapping for <tt><i>key</i></tt>
(based on <tt>eq?</tt> comparison), then the mark's value is replaced
with <tt><i>val</i></tt>, otherwise a mapping from <tt><i>key</i></tt> to <tt><i>val</i></tt> is
added to the table.

<p>

<p><tt>(with-continuation-mark<br>

&nbsp;'key&nbsp;"val"<br>

&nbsp;"hello")&nbsp;;&nbsp;=&gt;&nbsp;"hello"
<br>
<br>
(with-continuation-mark<br>

&nbsp;'key&nbsp;"val"<br>

&nbsp;(continuation-marks-first&nbsp;(current-continuation-marks)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'key))&nbsp;;&nbsp;=&gt;&nbsp;"val"
<br>
<br>
(with-continuation-mark<br>

&nbsp;'key&nbsp;"val"<br>

&nbsp;(continuation-marks-first&nbsp;(current-continuation-marks)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'other-key))&nbsp;;&nbsp;=&gt;&nbsp;#f
<br>
<br>
(with-continuation-mark<br>

&nbsp;'key&nbsp;"val"<br>

&nbsp;(with-continuation-mark<br>

&nbsp;&nbsp;'key&nbsp;"val2"<br>

&nbsp;&nbsp;(continuation-marks-first&nbsp;(current-continuation-marks)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'key)))&nbsp;;&nbsp;=&gt;&nbsp;"val2"
<br>
<br>
(with-continuation-mark<br>

&nbsp;'key&nbsp;"val"<br>

&nbsp;(with-continuation-mark<br>

&nbsp;&nbsp;'key&nbsp;"val2"<br>

&nbsp;&nbsp;(continuation-marks-&gt;list&nbsp;(current-continuation-marks)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'key)))&nbsp;;&nbsp;=&gt;&nbsp;("val2")
<br>
<br>
(with-continuation-mark<br>

&nbsp;'key&nbsp;"val"<br>

&nbsp;(values<br>

&nbsp;&nbsp;(with-continuation-mark<br>

&nbsp;&nbsp;&nbsp;'key&nbsp;"val2"<br>

&nbsp;&nbsp;&nbsp;(continuation-marks-&gt;list&nbsp;(current-continuation-marks)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'key))))&nbsp;;&nbsp;=&gt;&nbsp;("val2"&nbsp;"val")</tt>
<p><a name="./control:s13"></a><span class=formdef><b>procedure</b>: <tt>(continuation-marks?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>boolean
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>A predicate that recognizes a continuation mark sequence, which
can be produced by the functions <tt>current-continuation-marks</tt> and
<tt>continuation-next-marks</tt>.

<p>
<a name="./control:s14"></a><span class=formdef><b>procedure</b>: <tt>(current-continuation-marks)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(continuation-next-marks&nbsp;<i>cont</i>)</tt></span>
<br>
<b>returns: </b>a continuation mark sequence
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Returns a captured sequence of mark tables, either the
current continuation's marks in the case of
<tt>current-continuation-marks</tt> or the marks of the rest of
<tt><i>cont</i></tt> in the case of <tt>continuation-next-marks</tt>. In the
latter case, <tt><i>cont</i></tt> must be a continuation.

<p>
This function takes constant time. The size of the resulting mark sequence
is proportional to the number of distinct key-value mappings in the
overall mark-table sequence; that size is bounded by the length of the
continuation times the number of distinct values used as keys, but
since many continuations have no keys or fewer than all possible keys
in their tables, the size tends to be much less than the bound.

<p>

<p><tt>(continuation-marks?&nbsp;(current-continuation-marks))&nbsp;;&nbsp;=&gt;&nbsp;#t<br>

(continuation-marks?&nbsp;(continuation-next-marks<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(call/cc&nbsp;(lambda&nbsp;(k)&nbsp;k))))&nbsp;;&nbsp;=&gt;&nbsp;#t</tt>
<p><a name="./control:s15"></a><span class=formdef><b>procedure</b>: <tt>(continuation-marks-first&nbsp;<i>marks</i>&nbsp;<i>key</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(continuation-marks-first&nbsp;<i>marks</i>&nbsp;<i>key</i>&nbsp;<i>none-val</i>)</tt></span>
<br>
<b>returns: </b>the value for <tt><i>key</i></tt> in <tt><i>marks</i></tt> or <tt><i>none-val</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Extracts the first value found for <tt><i>key</i></tt> in
<tt><i>marks</i></tt>, checking the mark table of a continuation before
checking the table of the continuation that it extends (if any). Keys are
compared using <tt>eq?</tt>. If no mark for <tt><i>key</i></tt> is found,
<tt><i>none-val</i></tt> is returned; if <tt><i>none-val</i></tt> is not provided, it
defaults to <tt>#f</tt>.

<p>
This function takes amortized time proportional to the number of
distinct values used as keys in <tt><i>marks</i></tt>. Typically the number of
keys used in an application is bounded, which makes the computation
amortized constant-time for those applications.

<p>

<p><tt>(with-continuation-mark<br>

&nbsp;'key&nbsp;"val"<br>

&nbsp;(values<br>

&nbsp;&nbsp;(with-continuation-mark<br>

&nbsp;&nbsp;&nbsp;'key&nbsp;"val2"<br>

&nbsp;&nbsp;&nbsp;(continuation-marks-first&nbsp;(current-continuation-marks)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'key))))&nbsp;;&nbsp;=&gt;&nbsp;"val2"
<br>
<br>
(with-continuation-mark<br>

&nbsp;'key&nbsp;"val"<br>

&nbsp;(continuation-marks-first&nbsp;(current-continuation-marks)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'other<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"nope"))&nbsp;;&nbsp;=&gt;&nbsp;"nope"</tt>
<p><a name="./control:s16"></a><span class=formdef><b>procedure</b>: <tt>(continuation-marks-&gt;list&nbsp;<i>marks</i>&nbsp;<i>key</i>)</tt></span>
<br>
<b>returns: </b>a list
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Returns the list of all values associated with <tt><i>key</i></tt> in
<tt><i>marks</i></tt>, with the value from a continuation's mark
table appearing before the values from the mark tables of any other
continuation that it extends.  Keys are compared using
<tt>eq?</tt>.

<p>
This function takes time proportional to the size of the captured mark
sequence.

<p>

<p><tt>(with-continuation-mark<br>

&nbsp;'key&nbsp;"val"<br>

&nbsp;(values<br>

&nbsp;&nbsp;(with-continuation-mark<br>

&nbsp;&nbsp;&nbsp;'key&nbsp;"val2"<br>

&nbsp;&nbsp;&nbsp;(continuation-marks-&gt;list&nbsp;(current-continuation-marks)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'key))))&nbsp;;&nbsp;=&gt;&nbsp;("val2"&nbsp;"val")
<br>
<br>
(with-continuation-mark<br>

&nbsp;'key&nbsp;"val"<br>

&nbsp;(continuation-marks-&gt;list&nbsp;(current-continuation-marks)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'other))&nbsp;;&nbsp;=&gt;&nbsp;()</tt>
<p><a name="./control:s17"></a><span class=formdef><b>procedure</b>: <tt>(continuation-marks-&gt;iterator&nbsp;<i>marks</i>&nbsp;<i>key-vector</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(continuation-marks-&gt;iterator&nbsp;<i>marks</i>&nbsp;<i>key-vector</i>&nbsp;<i>none-val</i>)</tt></span>
<br>
<b>returns: </b>a procedure
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Generalizes the mark sequence traversal of
<tt>continuation-marks-&gt;list</tt> to a functional iterator. The
<tt><i>marks</i></tt> argument must be a continuation mark sequence, and the
<tt><i>key-vector</i></tt> argument must be a vector of values to be used as
keys. The result is an iterator procedure of zero arguments.

<p>
Calling the result iterator procedure (with no arguments) returns two values:

<p>
<ul>

<p>
<li>The first result is either a vector of values, one for each key in
  <tt><i>key-vector</i></tt> (in the order given in <tt><i>key-vector</i></tt>) and drawn from
  a single continuation's mark table, or <tt>#f</tt> if no more values for
  any keys are available. The given <tt><i>none-val</i></tt>, which defaults to
  <tt>#f</tt>, is used for each key that has no value in the table. Only
  mark tables with mappings for at least one of the keys in
  <tt><i>key-vector</i></tt> are represented in the iteration, so a result vector
  will never consist solely of <tt><i>none-val</i></tt> values (unless one or more of the keys
  is explicitly mapped to <tt><i>none-val</i></tt>).

<p>
<li>The second result is a new iterator procedure to obtain
the next vector of values, and so on. When the first result is
<tt>#f</tt>, the second result is an iterator procedure that will still
return <tt>#f</tt> as its first result (and a procedure functionally
equivalent to itself as the second result).

<p>
</ul>
<p>

<p>
Obtaining an iterator from <tt>continuation-marks-&gt;iterator</tt> takes
constant time. Each call to an iterator takes time proportional to the
size of continuation mark tables that are traversed to find one of the
keys in <tt><i>key-vector</i></tt>.

<p>

<p><tt>(with-continuation-mark<br>

&nbsp;'key&nbsp;"val"<br>

&nbsp;(with-continuation-mark<br>

&nbsp;&nbsp;'other&nbsp;"also"<br>

&nbsp;&nbsp;(values<br>

&nbsp;&nbsp;&nbsp;(with-continuation-mark<br>

&nbsp;&nbsp;&nbsp;&nbsp;'key&nbsp;"val2"<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;loop&nbsp;([iter&nbsp;(continuation-marks-&gt;iterator<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(current-continuation-marks)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'#(key&nbsp;other))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let-values&nbsp;([(vec&nbsp;iter)&nbsp;(iter)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;vec<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;vec&nbsp;(loop&nbsp;iter))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'())))))))&nbsp;;&nbsp;=&gt;&nbsp;(#("val2"&nbsp;#f)&nbsp;#("val"&nbsp;"also"))</tt>
<p><a name="./control:s18"></a><span class=formdef><b>procedure</b>: <tt>(call-with-immediate-continuation-mark&nbsp;<i>key</i>&nbsp;<i>proc</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(call-with-immediate-continuation-mark&nbsp;<i>key</i>&nbsp;<i>none-val</i>&nbsp;<i>proc</i>)</tt></span>
<br>
<b>returns: </b>the value produced by calling <tt><i>proc</i></tt>
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>Similar to

<p><tt>&nbsp;(continuation-marks-first&nbsp;(current-continuation-marks)&nbsp;<i>key</i>&nbsp;<i>none-val</i>)</tt>
<p>but only the immediate continuation's mark table is checked, and the result is
delivered to <tt><i>proc</i></tt> instead of returned. The <tt><i>proc</i></tt>, which must be
a procedure that accepts one argument, is called
in tail position, so its continuation is the same as the one whose
table is checked.

<p>

<p><tt>(with-continuation-mark<br>

&nbsp;'key&nbsp;"val"<br>

&nbsp;(call-with-immediate-continuation-mark&nbsp;'key&nbsp;list))&nbsp;;&nbsp;=&gt;&nbsp;("val")
<br>
<br>
(with-continuation-mark<br>

&nbsp;'key&nbsp;"val"<br>

&nbsp;(vector&nbsp;(call-with-immediate-continuation-mark&nbsp;'key&nbsp;list)))&nbsp;;&nbsp;=&gt;&nbsp;#((#f))<br>

(with-continuation-mark<br>

&nbsp;'key&nbsp;"val"<br>

&nbsp;(vector&nbsp;(call-with-immediate-continuation-mark&nbsp;'key&nbsp;'no&nbsp;list)))&nbsp;;&nbsp;=&gt;&nbsp;#((no))</tt>
<p><a name="./control:s19"></a><span class=formdef><b>procedure</b>: <tt>(call-in-continuation&nbsp;<i>continuation</i>&nbsp;<i>procedure</i>)</tt></span>
<br><span class=formdef><b>procedure</b>: <tt>(call-in-continuation&nbsp;<i>continuation</i>&nbsp;<i>marks</i>&nbsp;<i>procedure</i>)</tt></span>
<br>
<b>returns: </b>does not return
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p><tt><i>continuation</i></tt> must be a continuation,
<tt><i>procedure</i></tt> must be a procedure that accepts zero arguments, and
<tt><i>marks</i></tt> (if provided) must be a continuation mark sequence.

<p>
Applies <tt><i>procedure</i></tt> to zero arguments with <tt><i>continuation</i></tt> as
the continuation of the call, escaping from the current continuation.
This operation is similar to applying <tt><i>continuation</i></tt> to values,
except that the values delivered to the continuation are the ones
produced by <tt><i>procedure</i></tt> as it runs within the applied
continuation.

<p>
If <tt><i>marks</i></tt> is not provided, then <tt><i>procedure</i></tt> starts with no
immediate mark table. Otherwise, <tt><i>marks</i></tt> must be
consistent with the result of <tt>continuation-next-marks</tt> on
<tt><i>continuation</i></tt>: either the same content or one additional mark
table, and the additional mark table becomes the immediate mark table
when calling <tt><i>procedure</i></tt>.


<p>

<h3><a name="g47"></a><a name="./control:h4"></a>Section 6.4. Engines<a name="SECTENGINES"></a></h3>



<p>
<a name="./control:s20"></a>Engines are a high-level process abstraction supporting
<a name="./control:s21"></a><i>timed preemption</i>&nbsp;[<a class=citation href="./bibliography.html#g172">15</a>,<a class=citation href="./bibliography.html#g181">24</a>].
Engines may be used to simulate <a name="./control:s22"></a>multiprocessing, implement operating
system kernels, and perform <a name="./control:s23"></a>nondeterministic computations.

<p>
<a name="./control:s24"></a><span class=formdef><b>procedure</b>: <tt>(make-engine&nbsp;<i>thunk</i>)</tt></span>
<br>
<b>returns: </b>an engine
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>An engine is created by passing a thunk (no argument procedure)
to <tt>make-engine</tt>.
The body of the thunk is the computation to be performed by the engine.
An engine itself is a procedure of three arguments:

<p>
<dl compact>
<dt><tt><i>ticks</i></tt>:<dd>
<a name="./control:s25"></a>a positive integer that specifies
the amount of <i>fuel</i> to be given
to the engine.
An engine executes until this fuel runs out or until its computation
finishes.

<p>
<dt><tt><i>complete</i></tt>:<dd>
<a name="./control:s26"></a>a procedure of one or more
arguments that
specifies what to do if the computation finishes.
Its arguments are the amount of fuel left over and the
values produced by the computation.

<p>
<dt><tt><i>expire</i></tt>:<dd>
<a name="./control:s27"></a>a procedure of one argument that
specifies what to do if the fuel runs
out before the computation finishes.
Its argument is a new engine capable of continuing the computation
from the point of interruption.
</dl>

<p>
When an engine is applied to its arguments, it sets up a timer
to fire in <tt><i>ticks</i></tt> time units.
(See <tt>set-timer</tt> on page&nbsp;<a href="./system.html#desc:set-timer">359</a>.)
If the engine computation completes before the timer expires, the
system invokes <tt><i>complete</i></tt>, passing 
it the number of <tt><i>ticks</i></tt> left over and
the values produced by the computation.
If, on the other hand, the timer goes off before the engine computation
completes, the system creates a new engine from the continuation of
the interrupted computation and passes this engine to <tt><i>expire</i></tt>.
<tt><i>complete</i></tt> and <tt><i>expire</i></tt> are invoked in the continuation
of the engine invocation.

<p>
An implementation of engines is given
in Section&nbsp;<a href="http://scheme.com/tspl4/./examples.html#g208">12.11</a>.
of <i>The Scheme Programming Language, 4th Edition</i>.

<p>
Do not use the timer interrupt (see <a name="./control:s28"></a><tt>set-timer</tt>) and <a name="./control:s29"></a>engines
at the same time, since engines are implemented in terms of the timer.

<p>
The following example creates an engine from a trivial computation,
3, and gives the engine 10 ticks.

<p>

<p><tt>(define&nbsp;eng<br>

&nbsp;&nbsp;(make-engine<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;3)))
<br>
<br>
(eng&nbsp;10<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ticks&nbsp;value)&nbsp;value)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;x))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3</tt>
<p>It is often useful to pass <tt>list</tt> as the <tt><i>complete</i></tt>
procedure to an engine, causing an engine that completes to return a
list whose first element is the ticks remaining and whose remaining elements
are the values returned by the computation.

<p>

<p><tt>(define&nbsp;eng<br>

&nbsp;&nbsp;(make-engine<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;3)))
<br>
<br>
(eng&nbsp;10<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;x))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(9&nbsp;3)</tt>
<p>In the example above, the value is 3 and there are 9 ticks left over,
i.e., it takes one unit of fuel to evaluate 3.
(The fuel amounts given here are for illustration only.
Your mileage may vary.)

<p>
Typically, the engine computation does not finish in one try.
<a name="./control:s30"></a>The following example displays the use of an engine to
compute the 10th Fibonacci number in steps.

<p>

<p><tt>(define&nbsp;fibonacci<br>

&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;fib&nbsp;([i&nbsp;n])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(=&nbsp;i&nbsp;0)&nbsp;0]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(=&nbsp;i&nbsp;1)&nbsp;1]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(+&nbsp;(fib&nbsp;(-&nbsp;i&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fib&nbsp;(-&nbsp;i&nbsp;2)))]))))
<br>
<br>
(define&nbsp;eng<br>

&nbsp;&nbsp;(make-engine<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fibonacci&nbsp;10))))
<br>
<br>
(eng&nbsp;50<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;eng&nbsp;new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"expired"))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"expired"
<br>
<br>
(eng&nbsp;50<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;eng&nbsp;new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"expired"))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"expired"
<br>
<br>
(eng&nbsp;50<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;eng&nbsp;new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"expired"))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"expired"
<br>
<br>
(eng&nbsp;50<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;eng&nbsp;new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"expired"))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(21&nbsp;55)</tt>
<p>Each time the engine's fuel runs out, the <tt><i>expire</i></tt> procedure assigns
<tt>eng</tt> to the new engine.
The entire computation requires four blocks of 50 ticks to complete; of the
last 50 it uses all but 21.
Thus, the total amount of fuel used is 179 ticks.
This leads to the following procedure, <tt>mileage</tt>, which "times" a
computation using engines:

<p>

<p><tt>(define&nbsp;mileage<br>

&nbsp;&nbsp;(lambda&nbsp;(thunk)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;loop&nbsp;([eng&nbsp;(make-engine&nbsp;thunk)]&nbsp;[total-ticks&nbsp;0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eng&nbsp;50<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ticks&nbsp;.&nbsp;values)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;total-ticks&nbsp;(-&nbsp;50&nbsp;ticks)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;new-eng<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;total-ticks&nbsp;50)))))))
<br>
<br>
(mileage&nbsp;(lambda&nbsp;()&nbsp;(fibonacci&nbsp;10)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;179</tt>
<p>The choice of 50 for the number of ticks to use each time is
arbitrary, of course.
It might make more sense to pass a much larger number, say 10000,
in order to reduce the number of times the computation is interrupted.

<p>
The next procedure is similar to <tt>mileage</tt>, but it returns a list
of engines, one for each tick it takes to complete the computation.
Each of the engines in the list represents a "snapshot" of the
computation, analogous to a single frame of a moving picture.
<tt>snapshot</tt> might be useful for "single stepping" a computation.

<p>

<p><tt>(define&nbsp;snapshot<br>

&nbsp;&nbsp;(lambda&nbsp;(thunk)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;again&nbsp;([eng&nbsp;(make-engine&nbsp;thunk)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;eng<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eng&nbsp;1&nbsp;(lambda&nbsp;(t&nbsp;.&nbsp;v)&nbsp;'())&nbsp;again)))))</tt>
<p>The recursion embedded in this procedure is rather strange.
The complete procedure performs the base case, returning the empty
list, and the expire procedure performs the recursion.

<p>
The next procedure, <a name="./control:s31"></a><tt>round-robin</tt>, could be the basis for a simple
time-sharing <a name="./control:s32"></a>operating system.
<tt>round-robin</tt> maintains a queue of processes (a list of engines),
cycling through the queue in a <i>round-robin</i> fashion, allowing each
process to run for a set amount of time.
<tt>round-robin</tt> returns a list of the values returned by the engine
computations in the order that the computations complete.
Each computation is assumed to produce exactly one value.

<p>

<p><tt>(define&nbsp;round-robin<br>

&nbsp;&nbsp;(lambda&nbsp;(engs)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;engs)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((car&nbsp;engs)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ticks&nbsp;value)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;value&nbsp;(round-robin&nbsp;(cdr&nbsp;engs))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(round-robin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append&nbsp;(cdr&nbsp;engs)&nbsp;(list&nbsp;eng))))))))</tt>
<p>Since the amount of fuel supplied each time, one tick, is constant,
the effect of <tt>round-robin</tt> is to return a list of the values sorted
from the quickest to complete to the slowest to complete.
Thus, when we call <tt>round-robin</tt> on a list of engines, each computing
one of the Fibonacci numbers, the output list is sorted with the earlier
Fibonacci numbers first, regardless of the order of the input list.

<p>

<p><tt>(round-robin<br>

&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-engine<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fibonacci&nbsp;x))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(4&nbsp;5&nbsp;2&nbsp;8&nbsp;3&nbsp;7&nbsp;6&nbsp;2)))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(1&nbsp;1&nbsp;2&nbsp;3&nbsp;5&nbsp;8&nbsp;13&nbsp;21)</tt>
<p>More interesting things can happen if the amount of fuel varies
each time through the loop.
<a name="./control:s33"></a>In this case, the computation would
be nondeterministic, i.e., the results would vary from call to call.

<p>
The following syntactic form, <a name="./control:s34"></a><tt>por</tt> (parallel-or), returns the
first of its expressions to complete with a true value.
<tt>por</tt> is implemented with the procedure <tt>first-true</tt>, which is
similar to <tt>round-robin</tt> but quits when any of the engines
completes with a true value.
If all of the engines complete, but none with a true value,
<tt>first-true</tt> (and hence <tt>por</tt>) returns <tt>#f</tt>.
Also, although <tt>first-true</tt> passes a fixed amount of fuel to each
engine, it chooses the next engine to run at random, and is thus
nondeterministic.

<p>

<p><tt>(define-syntax&nbsp;por<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(first-true<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(make-engine&nbsp;(lambda&nbsp;()&nbsp;x))&nbsp;...))]))
<br>
<br>
(define&nbsp;first-true<br>

&nbsp;&nbsp;(let&nbsp;([pick<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-ref&nbsp;ls&nbsp;(random&nbsp;(length&nbsp;ls))))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(engs)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;engs)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#f<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([eng&nbsp;(pick&nbsp;engs)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eng&nbsp;1<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ticks&nbsp;value)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;value<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(first-true<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(remq&nbsp;eng&nbsp;engs))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(new-eng)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(first-true<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;new-eng<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(remq&nbsp;eng&nbsp;engs))))))))))</tt>
<p>The list of engines is maintained with <tt>pick</tt>, which randomly
chooses an element of the list, and <tt>remq</tt>, which removes the
chosen engine from the list.
Since <tt>por</tt> is nondeterministic, subsequent uses with the same
expressions may not return the same values.

<p>

<p><tt>(por&nbsp;1&nbsp;2&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2<br>

(por&nbsp;1&nbsp;2&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;3<br>

(por&nbsp;1&nbsp;2&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2<br>

(por&nbsp;1&nbsp;2&nbsp;3)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;1</tt>
<p>Furthermore, even if one of the expressions is an infinite loop,
<tt>por</tt> still finishes as long as one of the other expressions
completes and returns a true value.

<p>

<p><tt>(por&nbsp;(let&nbsp;loop&nbsp;()&nbsp;(loop))&nbsp;2)&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;2</tt>
<p>With <tt>engine-return</tt> and <tt>engine-block</tt>, it is possible to
terminate an engine explicitly.
<tt>engine-return</tt> causes the engine to complete, as if the
computation had finished.
Its arguments are passed to the <tt><i>complete</i></tt> procedure along with the
number of ticks remaining.
It is essentially a nonlocal exit from the engine.
Similarly, <tt>engine-block</tt> causes the engine to expire, as if the
timer had run out.
A new engine is made from the continuation of the call to <tt>engine-block</tt>
and passed to the <tt><i>expire</i></tt> procedure.


<p>
<a name="./control:s35"></a><span class=formdef><b>procedure</b>: <tt>(engine-block)</tt></span>
<br>
<b>returns: </b>does not return
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This causes a running engine to stop, create a new engine capable
of continuing the computation, and pass the new engine to the original
engine's third argument
(the expire procedure).
Any remaining fuel is forfeited.

<p>

<p><tt>(define&nbsp;eng<br>

&nbsp;&nbsp;(make-engine<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(engine-block)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"completed")))
<br>
<br>
(eng&nbsp;100<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ticks&nbsp;value)&nbsp;value)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;eng&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"expired"))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"expired"
<br>
<br>
(eng&nbsp;100<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ticks&nbsp;value)&nbsp;value)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;eng&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"expired"))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;"completed"</tt>
<p><a name="./control:s36"></a><span class=formdef><b>procedure</b>: <tt>(engine-return&nbsp;<i>obj</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>does not return
<br>
<b>libraries: </b><tt>(chezscheme)</tt>

<p>This causes a running engine to stop and pass control to the
engine's <tt><i>complete</i></tt> argument.
The first argument passed to the complete procedure is the amount of
fuel remaining, as usual, and
the remaining arguments are the objects <tt><i>obj</i>&nbsp;...</tt>
passed to <tt>engine-return</tt>.

<p>

<p><tt>(define&nbsp;eng<br>

&nbsp;&nbsp;(make-engine<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reverse&nbsp;(engine-return&nbsp;'a&nbsp;'b&nbsp;'c)))))
<br>
<br>
(eng&nbsp;100<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ticks&nbsp;.&nbsp;values)&nbsp;values)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(new-eng)&nbsp;"expired"))&nbsp;<img src="math/csug/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)</tt>
<p>



<hr class=copyright align=left>
<p>
<a class=plain href="index.html">Chez Scheme Version 10 User's Guide</a><br>
Copyright &copy; 2024 Cisco Systems, Inc.<br>
Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License Version 2.0</a>
(<a class=plain href="canned/copyright.html">full copyright notice.</a>).</br>
Revised November 2024 for Chez Scheme Version 10.1.0<br>
<a class=plain href="canned/about.html">about this book</a>
</tr></table>
</body>
</html>
